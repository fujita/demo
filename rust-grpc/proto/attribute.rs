// This file is generated by rust-protobuf 2.8.1. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `attribute.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_1;

#[derive(PartialEq,Clone,Default)]
pub struct OriginAttribute {
    // message fields
    pub origin: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OriginAttribute {
    fn default() -> &'a OriginAttribute {
        <OriginAttribute as ::protobuf::Message>::default_instance()
    }
}

impl OriginAttribute {
    pub fn new() -> OriginAttribute {
        ::std::default::Default::default()
    }

    // uint32 origin = 1;


    pub fn get_origin(&self) -> u32 {
        self.origin
    }
    pub fn clear_origin(&mut self) {
        self.origin = 0;
    }

    // Param is passed by value, moved
    pub fn set_origin(&mut self, v: u32) {
        self.origin = v;
    }
}

impl ::protobuf::Message for OriginAttribute {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.origin = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.origin != 0 {
            my_size += ::protobuf::rt::value_size(1, self.origin, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.origin != 0 {
            os.write_uint32(1, self.origin)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OriginAttribute {
        OriginAttribute::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "origin",
                    |m: &OriginAttribute| { &m.origin },
                    |m: &mut OriginAttribute| { &mut m.origin },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OriginAttribute>(
                    "OriginAttribute",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static OriginAttribute {
        static mut instance: ::protobuf::lazy::Lazy<OriginAttribute> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OriginAttribute,
        };
        unsafe {
            instance.get(OriginAttribute::new)
        }
    }
}

impl ::protobuf::Clear for OriginAttribute {
    fn clear(&mut self) {
        self.origin = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OriginAttribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OriginAttribute {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AsSegment {
    // message fields
    pub field_type: u32,
    pub numbers: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AsSegment {
    fn default() -> &'a AsSegment {
        <AsSegment as ::protobuf::Message>::default_instance()
    }
}

impl AsSegment {
    pub fn new() -> AsSegment {
        ::std::default::Default::default()
    }

    // uint32 type = 1;


    pub fn get_field_type(&self) -> u32 {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = 0;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: u32) {
        self.field_type = v;
    }

    // repeated uint32 numbers = 2;


    pub fn get_numbers(&self) -> &[u32] {
        &self.numbers
    }
    pub fn clear_numbers(&mut self) {
        self.numbers.clear();
    }

    // Param is passed by value, moved
    pub fn set_numbers(&mut self, v: ::std::vec::Vec<u32>) {
        self.numbers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_numbers(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.numbers
    }

    // Take field
    pub fn take_numbers(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.numbers, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for AsSegment {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.field_type = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.numbers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != 0 {
            my_size += ::protobuf::rt::value_size(1, self.field_type, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.numbers {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != 0 {
            os.write_uint32(1, self.field_type)?;
        }
        for v in &self.numbers {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AsSegment {
        AsSegment::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "type",
                    |m: &AsSegment| { &m.field_type },
                    |m: &mut AsSegment| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "numbers",
                    |m: &AsSegment| { &m.numbers },
                    |m: &mut AsSegment| { &mut m.numbers },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AsSegment>(
                    "AsSegment",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AsSegment {
        static mut instance: ::protobuf::lazy::Lazy<AsSegment> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AsSegment,
        };
        unsafe {
            instance.get(AsSegment::new)
        }
    }
}

impl ::protobuf::Clear for AsSegment {
    fn clear(&mut self) {
        self.field_type = 0;
        self.numbers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AsSegment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AsSegment {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AsPathAttribute {
    // message fields
    pub segments: ::protobuf::RepeatedField<AsSegment>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AsPathAttribute {
    fn default() -> &'a AsPathAttribute {
        <AsPathAttribute as ::protobuf::Message>::default_instance()
    }
}

impl AsPathAttribute {
    pub fn new() -> AsPathAttribute {
        ::std::default::Default::default()
    }

    // repeated .gobgpapi.AsSegment segments = 1;


    pub fn get_segments(&self) -> &[AsSegment] {
        &self.segments
    }
    pub fn clear_segments(&mut self) {
        self.segments.clear();
    }

    // Param is passed by value, moved
    pub fn set_segments(&mut self, v: ::protobuf::RepeatedField<AsSegment>) {
        self.segments = v;
    }

    // Mutable pointer to the field.
    pub fn mut_segments(&mut self) -> &mut ::protobuf::RepeatedField<AsSegment> {
        &mut self.segments
    }

    // Take field
    pub fn take_segments(&mut self) -> ::protobuf::RepeatedField<AsSegment> {
        ::std::mem::replace(&mut self.segments, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AsPathAttribute {
    fn is_initialized(&self) -> bool {
        for v in &self.segments {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.segments)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.segments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.segments {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AsPathAttribute {
        AsPathAttribute::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AsSegment>>(
                    "segments",
                    |m: &AsPathAttribute| { &m.segments },
                    |m: &mut AsPathAttribute| { &mut m.segments },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AsPathAttribute>(
                    "AsPathAttribute",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AsPathAttribute {
        static mut instance: ::protobuf::lazy::Lazy<AsPathAttribute> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AsPathAttribute,
        };
        unsafe {
            instance.get(AsPathAttribute::new)
        }
    }
}

impl ::protobuf::Clear for AsPathAttribute {
    fn clear(&mut self) {
        self.segments.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AsPathAttribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AsPathAttribute {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NextHopAttribute {
    // message fields
    pub next_hop: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NextHopAttribute {
    fn default() -> &'a NextHopAttribute {
        <NextHopAttribute as ::protobuf::Message>::default_instance()
    }
}

impl NextHopAttribute {
    pub fn new() -> NextHopAttribute {
        ::std::default::Default::default()
    }

    // string next_hop = 1;


    pub fn get_next_hop(&self) -> &str {
        &self.next_hop
    }
    pub fn clear_next_hop(&mut self) {
        self.next_hop.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_hop(&mut self, v: ::std::string::String) {
        self.next_hop = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_hop(&mut self) -> &mut ::std::string::String {
        &mut self.next_hop
    }

    // Take field
    pub fn take_next_hop(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_hop, ::std::string::String::new())
    }
}

impl ::protobuf::Message for NextHopAttribute {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_hop)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.next_hop.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.next_hop);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.next_hop.is_empty() {
            os.write_string(1, &self.next_hop)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NextHopAttribute {
        NextHopAttribute::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "next_hop",
                    |m: &NextHopAttribute| { &m.next_hop },
                    |m: &mut NextHopAttribute| { &mut m.next_hop },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NextHopAttribute>(
                    "NextHopAttribute",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NextHopAttribute {
        static mut instance: ::protobuf::lazy::Lazy<NextHopAttribute> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NextHopAttribute,
        };
        unsafe {
            instance.get(NextHopAttribute::new)
        }
    }
}

impl ::protobuf::Clear for NextHopAttribute {
    fn clear(&mut self) {
        self.next_hop.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NextHopAttribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NextHopAttribute {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiExitDiscAttribute {
    // message fields
    pub med: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiExitDiscAttribute {
    fn default() -> &'a MultiExitDiscAttribute {
        <MultiExitDiscAttribute as ::protobuf::Message>::default_instance()
    }
}

impl MultiExitDiscAttribute {
    pub fn new() -> MultiExitDiscAttribute {
        ::std::default::Default::default()
    }

    // uint32 med = 1;


    pub fn get_med(&self) -> u32 {
        self.med
    }
    pub fn clear_med(&mut self) {
        self.med = 0;
    }

    // Param is passed by value, moved
    pub fn set_med(&mut self, v: u32) {
        self.med = v;
    }
}

impl ::protobuf::Message for MultiExitDiscAttribute {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.med = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.med != 0 {
            my_size += ::protobuf::rt::value_size(1, self.med, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.med != 0 {
            os.write_uint32(1, self.med)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiExitDiscAttribute {
        MultiExitDiscAttribute::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "med",
                    |m: &MultiExitDiscAttribute| { &m.med },
                    |m: &mut MultiExitDiscAttribute| { &mut m.med },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MultiExitDiscAttribute>(
                    "MultiExitDiscAttribute",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MultiExitDiscAttribute {
        static mut instance: ::protobuf::lazy::Lazy<MultiExitDiscAttribute> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MultiExitDiscAttribute,
        };
        unsafe {
            instance.get(MultiExitDiscAttribute::new)
        }
    }
}

impl ::protobuf::Clear for MultiExitDiscAttribute {
    fn clear(&mut self) {
        self.med = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiExitDiscAttribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiExitDiscAttribute {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LocalPrefAttribute {
    // message fields
    pub local_pref: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LocalPrefAttribute {
    fn default() -> &'a LocalPrefAttribute {
        <LocalPrefAttribute as ::protobuf::Message>::default_instance()
    }
}

impl LocalPrefAttribute {
    pub fn new() -> LocalPrefAttribute {
        ::std::default::Default::default()
    }

    // uint32 local_pref = 1;


    pub fn get_local_pref(&self) -> u32 {
        self.local_pref
    }
    pub fn clear_local_pref(&mut self) {
        self.local_pref = 0;
    }

    // Param is passed by value, moved
    pub fn set_local_pref(&mut self, v: u32) {
        self.local_pref = v;
    }
}

impl ::protobuf::Message for LocalPrefAttribute {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.local_pref = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.local_pref != 0 {
            my_size += ::protobuf::rt::value_size(1, self.local_pref, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.local_pref != 0 {
            os.write_uint32(1, self.local_pref)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LocalPrefAttribute {
        LocalPrefAttribute::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "local_pref",
                    |m: &LocalPrefAttribute| { &m.local_pref },
                    |m: &mut LocalPrefAttribute| { &mut m.local_pref },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LocalPrefAttribute>(
                    "LocalPrefAttribute",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LocalPrefAttribute {
        static mut instance: ::protobuf::lazy::Lazy<LocalPrefAttribute> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LocalPrefAttribute,
        };
        unsafe {
            instance.get(LocalPrefAttribute::new)
        }
    }
}

impl ::protobuf::Clear for LocalPrefAttribute {
    fn clear(&mut self) {
        self.local_pref = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LocalPrefAttribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LocalPrefAttribute {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AtomicAggregateAttribute {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AtomicAggregateAttribute {
    fn default() -> &'a AtomicAggregateAttribute {
        <AtomicAggregateAttribute as ::protobuf::Message>::default_instance()
    }
}

impl AtomicAggregateAttribute {
    pub fn new() -> AtomicAggregateAttribute {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AtomicAggregateAttribute {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AtomicAggregateAttribute {
        AtomicAggregateAttribute::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<AtomicAggregateAttribute>(
                    "AtomicAggregateAttribute",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AtomicAggregateAttribute {
        static mut instance: ::protobuf::lazy::Lazy<AtomicAggregateAttribute> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AtomicAggregateAttribute,
        };
        unsafe {
            instance.get(AtomicAggregateAttribute::new)
        }
    }
}

impl ::protobuf::Clear for AtomicAggregateAttribute {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AtomicAggregateAttribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AtomicAggregateAttribute {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AggregatorAttribute {
    // message fields
    pub field_as: u32,
    pub address: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AggregatorAttribute {
    fn default() -> &'a AggregatorAttribute {
        <AggregatorAttribute as ::protobuf::Message>::default_instance()
    }
}

impl AggregatorAttribute {
    pub fn new() -> AggregatorAttribute {
        ::std::default::Default::default()
    }

    // uint32 as = 2;


    pub fn get_field_as(&self) -> u32 {
        self.field_as
    }
    pub fn clear_field_as(&mut self) {
        self.field_as = 0;
    }

    // Param is passed by value, moved
    pub fn set_field_as(&mut self, v: u32) {
        self.field_as = v;
    }

    // string address = 3;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AggregatorAttribute {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.field_as = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_as != 0 {
            my_size += ::protobuf::rt::value_size(2, self.field_as, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_as != 0 {
            os.write_uint32(2, self.field_as)?;
        }
        if !self.address.is_empty() {
            os.write_string(3, &self.address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AggregatorAttribute {
        AggregatorAttribute::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "as",
                    |m: &AggregatorAttribute| { &m.field_as },
                    |m: &mut AggregatorAttribute| { &mut m.field_as },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "address",
                    |m: &AggregatorAttribute| { &m.address },
                    |m: &mut AggregatorAttribute| { &mut m.address },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AggregatorAttribute>(
                    "AggregatorAttribute",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AggregatorAttribute {
        static mut instance: ::protobuf::lazy::Lazy<AggregatorAttribute> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AggregatorAttribute,
        };
        unsafe {
            instance.get(AggregatorAttribute::new)
        }
    }
}

impl ::protobuf::Clear for AggregatorAttribute {
    fn clear(&mut self) {
        self.field_as = 0;
        self.address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AggregatorAttribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AggregatorAttribute {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommunitiesAttribute {
    // message fields
    pub communities: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommunitiesAttribute {
    fn default() -> &'a CommunitiesAttribute {
        <CommunitiesAttribute as ::protobuf::Message>::default_instance()
    }
}

impl CommunitiesAttribute {
    pub fn new() -> CommunitiesAttribute {
        ::std::default::Default::default()
    }

    // repeated uint32 communities = 1;


    pub fn get_communities(&self) -> &[u32] {
        &self.communities
    }
    pub fn clear_communities(&mut self) {
        self.communities.clear();
    }

    // Param is passed by value, moved
    pub fn set_communities(&mut self, v: ::std::vec::Vec<u32>) {
        self.communities = v;
    }

    // Mutable pointer to the field.
    pub fn mut_communities(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.communities
    }

    // Take field
    pub fn take_communities(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.communities, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CommunitiesAttribute {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.communities)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.communities {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.communities {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommunitiesAttribute {
        CommunitiesAttribute::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "communities",
                    |m: &CommunitiesAttribute| { &m.communities },
                    |m: &mut CommunitiesAttribute| { &mut m.communities },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CommunitiesAttribute>(
                    "CommunitiesAttribute",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CommunitiesAttribute {
        static mut instance: ::protobuf::lazy::Lazy<CommunitiesAttribute> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommunitiesAttribute,
        };
        unsafe {
            instance.get(CommunitiesAttribute::new)
        }
    }
}

impl ::protobuf::Clear for CommunitiesAttribute {
    fn clear(&mut self) {
        self.communities.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommunitiesAttribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommunitiesAttribute {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OriginatorIdAttribute {
    // message fields
    pub id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OriginatorIdAttribute {
    fn default() -> &'a OriginatorIdAttribute {
        <OriginatorIdAttribute as ::protobuf::Message>::default_instance()
    }
}

impl OriginatorIdAttribute {
    pub fn new() -> OriginatorIdAttribute {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for OriginatorIdAttribute {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OriginatorIdAttribute {
        OriginatorIdAttribute::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &OriginatorIdAttribute| { &m.id },
                    |m: &mut OriginatorIdAttribute| { &mut m.id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OriginatorIdAttribute>(
                    "OriginatorIdAttribute",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static OriginatorIdAttribute {
        static mut instance: ::protobuf::lazy::Lazy<OriginatorIdAttribute> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OriginatorIdAttribute,
        };
        unsafe {
            instance.get(OriginatorIdAttribute::new)
        }
    }
}

impl ::protobuf::Clear for OriginatorIdAttribute {
    fn clear(&mut self) {
        self.id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OriginatorIdAttribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OriginatorIdAttribute {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClusterListAttribute {
    // message fields
    pub ids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClusterListAttribute {
    fn default() -> &'a ClusterListAttribute {
        <ClusterListAttribute as ::protobuf::Message>::default_instance()
    }
}

impl ClusterListAttribute {
    pub fn new() -> ClusterListAttribute {
        ::std::default::Default::default()
    }

    // repeated string ids = 1;


    pub fn get_ids(&self) -> &[::std::string::String] {
        &self.ids
    }
    pub fn clear_ids(&mut self) {
        self.ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ids
    }

    // Take field
    pub fn take_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ClusterListAttribute {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.ids {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClusterListAttribute {
        ClusterListAttribute::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ids",
                    |m: &ClusterListAttribute| { &m.ids },
                    |m: &mut ClusterListAttribute| { &mut m.ids },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ClusterListAttribute>(
                    "ClusterListAttribute",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ClusterListAttribute {
        static mut instance: ::protobuf::lazy::Lazy<ClusterListAttribute> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ClusterListAttribute,
        };
        unsafe {
            instance.get(ClusterListAttribute::new)
        }
    }
}

impl ::protobuf::Clear for ClusterListAttribute {
    fn clear(&mut self) {
        self.ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClusterListAttribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClusterListAttribute {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IPAddressPrefix {
    // message fields
    pub prefix_len: u32,
    pub prefix: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IPAddressPrefix {
    fn default() -> &'a IPAddressPrefix {
        <IPAddressPrefix as ::protobuf::Message>::default_instance()
    }
}

impl IPAddressPrefix {
    pub fn new() -> IPAddressPrefix {
        ::std::default::Default::default()
    }

    // uint32 prefix_len = 1;


    pub fn get_prefix_len(&self) -> u32 {
        self.prefix_len
    }
    pub fn clear_prefix_len(&mut self) {
        self.prefix_len = 0;
    }

    // Param is passed by value, moved
    pub fn set_prefix_len(&mut self, v: u32) {
        self.prefix_len = v;
    }

    // string prefix = 2;


    pub fn get_prefix(&self) -> &str {
        &self.prefix
    }
    pub fn clear_prefix(&mut self) {
        self.prefix.clear();
    }

    // Param is passed by value, moved
    pub fn set_prefix(&mut self, v: ::std::string::String) {
        self.prefix = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prefix(&mut self) -> &mut ::std::string::String {
        &mut self.prefix
    }

    // Take field
    pub fn take_prefix(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.prefix, ::std::string::String::new())
    }
}

impl ::protobuf::Message for IPAddressPrefix {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.prefix_len = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.prefix)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.prefix_len != 0 {
            my_size += ::protobuf::rt::value_size(1, self.prefix_len, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.prefix.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.prefix);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.prefix_len != 0 {
            os.write_uint32(1, self.prefix_len)?;
        }
        if !self.prefix.is_empty() {
            os.write_string(2, &self.prefix)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IPAddressPrefix {
        IPAddressPrefix::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "prefix_len",
                    |m: &IPAddressPrefix| { &m.prefix_len },
                    |m: &mut IPAddressPrefix| { &mut m.prefix_len },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "prefix",
                    |m: &IPAddressPrefix| { &m.prefix },
                    |m: &mut IPAddressPrefix| { &mut m.prefix },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<IPAddressPrefix>(
                    "IPAddressPrefix",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static IPAddressPrefix {
        static mut instance: ::protobuf::lazy::Lazy<IPAddressPrefix> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IPAddressPrefix,
        };
        unsafe {
            instance.get(IPAddressPrefix::new)
        }
    }
}

impl ::protobuf::Clear for IPAddressPrefix {
    fn clear(&mut self) {
        self.prefix_len = 0;
        self.prefix.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IPAddressPrefix {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IPAddressPrefix {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LabeledIPAddressPrefix {
    // message fields
    pub labels: ::std::vec::Vec<u32>,
    pub prefix_len: u32,
    pub prefix: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LabeledIPAddressPrefix {
    fn default() -> &'a LabeledIPAddressPrefix {
        <LabeledIPAddressPrefix as ::protobuf::Message>::default_instance()
    }
}

impl LabeledIPAddressPrefix {
    pub fn new() -> LabeledIPAddressPrefix {
        ::std::default::Default::default()
    }

    // repeated uint32 labels = 1;


    pub fn get_labels(&self) -> &[u32] {
        &self.labels
    }
    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: ::std::vec::Vec<u32>) {
        self.labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_labels(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.labels
    }

    // Take field
    pub fn take_labels(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.labels, ::std::vec::Vec::new())
    }

    // uint32 prefix_len = 2;


    pub fn get_prefix_len(&self) -> u32 {
        self.prefix_len
    }
    pub fn clear_prefix_len(&mut self) {
        self.prefix_len = 0;
    }

    // Param is passed by value, moved
    pub fn set_prefix_len(&mut self, v: u32) {
        self.prefix_len = v;
    }

    // string prefix = 3;


    pub fn get_prefix(&self) -> &str {
        &self.prefix
    }
    pub fn clear_prefix(&mut self) {
        self.prefix.clear();
    }

    // Param is passed by value, moved
    pub fn set_prefix(&mut self, v: ::std::string::String) {
        self.prefix = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prefix(&mut self) -> &mut ::std::string::String {
        &mut self.prefix
    }

    // Take field
    pub fn take_prefix(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.prefix, ::std::string::String::new())
    }
}

impl ::protobuf::Message for LabeledIPAddressPrefix {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.labels)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.prefix_len = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.prefix)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.labels {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.prefix_len != 0 {
            my_size += ::protobuf::rt::value_size(2, self.prefix_len, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.prefix.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.prefix);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.labels {
            os.write_uint32(1, *v)?;
        };
        if self.prefix_len != 0 {
            os.write_uint32(2, self.prefix_len)?;
        }
        if !self.prefix.is_empty() {
            os.write_string(3, &self.prefix)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LabeledIPAddressPrefix {
        LabeledIPAddressPrefix::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "labels",
                    |m: &LabeledIPAddressPrefix| { &m.labels },
                    |m: &mut LabeledIPAddressPrefix| { &mut m.labels },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "prefix_len",
                    |m: &LabeledIPAddressPrefix| { &m.prefix_len },
                    |m: &mut LabeledIPAddressPrefix| { &mut m.prefix_len },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "prefix",
                    |m: &LabeledIPAddressPrefix| { &m.prefix },
                    |m: &mut LabeledIPAddressPrefix| { &mut m.prefix },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LabeledIPAddressPrefix>(
                    "LabeledIPAddressPrefix",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LabeledIPAddressPrefix {
        static mut instance: ::protobuf::lazy::Lazy<LabeledIPAddressPrefix> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LabeledIPAddressPrefix,
        };
        unsafe {
            instance.get(LabeledIPAddressPrefix::new)
        }
    }
}

impl ::protobuf::Clear for LabeledIPAddressPrefix {
    fn clear(&mut self) {
        self.labels.clear();
        self.prefix_len = 0;
        self.prefix.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LabeledIPAddressPrefix {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LabeledIPAddressPrefix {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EncapsulationNLRI {
    // message fields
    pub address: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EncapsulationNLRI {
    fn default() -> &'a EncapsulationNLRI {
        <EncapsulationNLRI as ::protobuf::Message>::default_instance()
    }
}

impl EncapsulationNLRI {
    pub fn new() -> EncapsulationNLRI {
        ::std::default::Default::default()
    }

    // string address = 1;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }
}

impl ::protobuf::Message for EncapsulationNLRI {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EncapsulationNLRI {
        EncapsulationNLRI::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "address",
                    |m: &EncapsulationNLRI| { &m.address },
                    |m: &mut EncapsulationNLRI| { &mut m.address },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EncapsulationNLRI>(
                    "EncapsulationNLRI",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EncapsulationNLRI {
        static mut instance: ::protobuf::lazy::Lazy<EncapsulationNLRI> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EncapsulationNLRI,
        };
        unsafe {
            instance.get(EncapsulationNLRI::new)
        }
    }
}

impl ::protobuf::Clear for EncapsulationNLRI {
    fn clear(&mut self) {
        self.address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EncapsulationNLRI {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EncapsulationNLRI {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RouteDistinguisherTwoOctetAS {
    // message fields
    pub admin: u32,
    pub assigned: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RouteDistinguisherTwoOctetAS {
    fn default() -> &'a RouteDistinguisherTwoOctetAS {
        <RouteDistinguisherTwoOctetAS as ::protobuf::Message>::default_instance()
    }
}

impl RouteDistinguisherTwoOctetAS {
    pub fn new() -> RouteDistinguisherTwoOctetAS {
        ::std::default::Default::default()
    }

    // uint32 admin = 1;


    pub fn get_admin(&self) -> u32 {
        self.admin
    }
    pub fn clear_admin(&mut self) {
        self.admin = 0;
    }

    // Param is passed by value, moved
    pub fn set_admin(&mut self, v: u32) {
        self.admin = v;
    }

    // uint32 assigned = 2;


    pub fn get_assigned(&self) -> u32 {
        self.assigned
    }
    pub fn clear_assigned(&mut self) {
        self.assigned = 0;
    }

    // Param is passed by value, moved
    pub fn set_assigned(&mut self, v: u32) {
        self.assigned = v;
    }
}

impl ::protobuf::Message for RouteDistinguisherTwoOctetAS {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.admin = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.assigned = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.admin != 0 {
            my_size += ::protobuf::rt::value_size(1, self.admin, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.assigned != 0 {
            my_size += ::protobuf::rt::value_size(2, self.assigned, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.admin != 0 {
            os.write_uint32(1, self.admin)?;
        }
        if self.assigned != 0 {
            os.write_uint32(2, self.assigned)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouteDistinguisherTwoOctetAS {
        RouteDistinguisherTwoOctetAS::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "admin",
                    |m: &RouteDistinguisherTwoOctetAS| { &m.admin },
                    |m: &mut RouteDistinguisherTwoOctetAS| { &mut m.admin },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "assigned",
                    |m: &RouteDistinguisherTwoOctetAS| { &m.assigned },
                    |m: &mut RouteDistinguisherTwoOctetAS| { &mut m.assigned },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RouteDistinguisherTwoOctetAS>(
                    "RouteDistinguisherTwoOctetAS",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RouteDistinguisherTwoOctetAS {
        static mut instance: ::protobuf::lazy::Lazy<RouteDistinguisherTwoOctetAS> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RouteDistinguisherTwoOctetAS,
        };
        unsafe {
            instance.get(RouteDistinguisherTwoOctetAS::new)
        }
    }
}

impl ::protobuf::Clear for RouteDistinguisherTwoOctetAS {
    fn clear(&mut self) {
        self.admin = 0;
        self.assigned = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouteDistinguisherTwoOctetAS {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteDistinguisherTwoOctetAS {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RouteDistinguisherIPAddress {
    // message fields
    pub admin: ::std::string::String,
    pub assigned: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RouteDistinguisherIPAddress {
    fn default() -> &'a RouteDistinguisherIPAddress {
        <RouteDistinguisherIPAddress as ::protobuf::Message>::default_instance()
    }
}

impl RouteDistinguisherIPAddress {
    pub fn new() -> RouteDistinguisherIPAddress {
        ::std::default::Default::default()
    }

    // string admin = 1;


    pub fn get_admin(&self) -> &str {
        &self.admin
    }
    pub fn clear_admin(&mut self) {
        self.admin.clear();
    }

    // Param is passed by value, moved
    pub fn set_admin(&mut self, v: ::std::string::String) {
        self.admin = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_admin(&mut self) -> &mut ::std::string::String {
        &mut self.admin
    }

    // Take field
    pub fn take_admin(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.admin, ::std::string::String::new())
    }

    // uint32 assigned = 2;


    pub fn get_assigned(&self) -> u32 {
        self.assigned
    }
    pub fn clear_assigned(&mut self) {
        self.assigned = 0;
    }

    // Param is passed by value, moved
    pub fn set_assigned(&mut self, v: u32) {
        self.assigned = v;
    }
}

impl ::protobuf::Message for RouteDistinguisherIPAddress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.admin)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.assigned = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.admin.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.admin);
        }
        if self.assigned != 0 {
            my_size += ::protobuf::rt::value_size(2, self.assigned, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.admin.is_empty() {
            os.write_string(1, &self.admin)?;
        }
        if self.assigned != 0 {
            os.write_uint32(2, self.assigned)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouteDistinguisherIPAddress {
        RouteDistinguisherIPAddress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "admin",
                    |m: &RouteDistinguisherIPAddress| { &m.admin },
                    |m: &mut RouteDistinguisherIPAddress| { &mut m.admin },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "assigned",
                    |m: &RouteDistinguisherIPAddress| { &m.assigned },
                    |m: &mut RouteDistinguisherIPAddress| { &mut m.assigned },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RouteDistinguisherIPAddress>(
                    "RouteDistinguisherIPAddress",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RouteDistinguisherIPAddress {
        static mut instance: ::protobuf::lazy::Lazy<RouteDistinguisherIPAddress> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RouteDistinguisherIPAddress,
        };
        unsafe {
            instance.get(RouteDistinguisherIPAddress::new)
        }
    }
}

impl ::protobuf::Clear for RouteDistinguisherIPAddress {
    fn clear(&mut self) {
        self.admin.clear();
        self.assigned = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouteDistinguisherIPAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteDistinguisherIPAddress {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RouteDistinguisherFourOctetAS {
    // message fields
    pub admin: u32,
    pub assigned: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RouteDistinguisherFourOctetAS {
    fn default() -> &'a RouteDistinguisherFourOctetAS {
        <RouteDistinguisherFourOctetAS as ::protobuf::Message>::default_instance()
    }
}

impl RouteDistinguisherFourOctetAS {
    pub fn new() -> RouteDistinguisherFourOctetAS {
        ::std::default::Default::default()
    }

    // uint32 admin = 1;


    pub fn get_admin(&self) -> u32 {
        self.admin
    }
    pub fn clear_admin(&mut self) {
        self.admin = 0;
    }

    // Param is passed by value, moved
    pub fn set_admin(&mut self, v: u32) {
        self.admin = v;
    }

    // uint32 assigned = 2;


    pub fn get_assigned(&self) -> u32 {
        self.assigned
    }
    pub fn clear_assigned(&mut self) {
        self.assigned = 0;
    }

    // Param is passed by value, moved
    pub fn set_assigned(&mut self, v: u32) {
        self.assigned = v;
    }
}

impl ::protobuf::Message for RouteDistinguisherFourOctetAS {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.admin = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.assigned = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.admin != 0 {
            my_size += ::protobuf::rt::value_size(1, self.admin, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.assigned != 0 {
            my_size += ::protobuf::rt::value_size(2, self.assigned, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.admin != 0 {
            os.write_uint32(1, self.admin)?;
        }
        if self.assigned != 0 {
            os.write_uint32(2, self.assigned)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouteDistinguisherFourOctetAS {
        RouteDistinguisherFourOctetAS::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "admin",
                    |m: &RouteDistinguisherFourOctetAS| { &m.admin },
                    |m: &mut RouteDistinguisherFourOctetAS| { &mut m.admin },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "assigned",
                    |m: &RouteDistinguisherFourOctetAS| { &m.assigned },
                    |m: &mut RouteDistinguisherFourOctetAS| { &mut m.assigned },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RouteDistinguisherFourOctetAS>(
                    "RouteDistinguisherFourOctetAS",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RouteDistinguisherFourOctetAS {
        static mut instance: ::protobuf::lazy::Lazy<RouteDistinguisherFourOctetAS> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RouteDistinguisherFourOctetAS,
        };
        unsafe {
            instance.get(RouteDistinguisherFourOctetAS::new)
        }
    }
}

impl ::protobuf::Clear for RouteDistinguisherFourOctetAS {
    fn clear(&mut self) {
        self.admin = 0;
        self.assigned = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouteDistinguisherFourOctetAS {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteDistinguisherFourOctetAS {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EthernetSegmentIdentifier {
    // message fields
    pub field_type: u32,
    pub value: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EthernetSegmentIdentifier {
    fn default() -> &'a EthernetSegmentIdentifier {
        <EthernetSegmentIdentifier as ::protobuf::Message>::default_instance()
    }
}

impl EthernetSegmentIdentifier {
    pub fn new() -> EthernetSegmentIdentifier {
        ::std::default::Default::default()
    }

    // uint32 type = 1;


    pub fn get_field_type(&self) -> u32 {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = 0;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: u32) {
        self.field_type = v;
    }

    // bytes value = 2;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for EthernetSegmentIdentifier {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.field_type = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != 0 {
            my_size += ::protobuf::rt::value_size(1, self.field_type, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != 0 {
            os.write_uint32(1, self.field_type)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(2, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EthernetSegmentIdentifier {
        EthernetSegmentIdentifier::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "type",
                    |m: &EthernetSegmentIdentifier| { &m.field_type },
                    |m: &mut EthernetSegmentIdentifier| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "value",
                    |m: &EthernetSegmentIdentifier| { &m.value },
                    |m: &mut EthernetSegmentIdentifier| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EthernetSegmentIdentifier>(
                    "EthernetSegmentIdentifier",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EthernetSegmentIdentifier {
        static mut instance: ::protobuf::lazy::Lazy<EthernetSegmentIdentifier> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EthernetSegmentIdentifier,
        };
        unsafe {
            instance.get(EthernetSegmentIdentifier::new)
        }
    }
}

impl ::protobuf::Clear for EthernetSegmentIdentifier {
    fn clear(&mut self) {
        self.field_type = 0;
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EthernetSegmentIdentifier {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EthernetSegmentIdentifier {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EVPNEthernetAutoDiscoveryRoute {
    // message fields
    pub rd: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    pub esi: ::protobuf::SingularPtrField<EthernetSegmentIdentifier>,
    pub ethernet_tag: u32,
    pub label: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EVPNEthernetAutoDiscoveryRoute {
    fn default() -> &'a EVPNEthernetAutoDiscoveryRoute {
        <EVPNEthernetAutoDiscoveryRoute as ::protobuf::Message>::default_instance()
    }
}

impl EVPNEthernetAutoDiscoveryRoute {
    pub fn new() -> EVPNEthernetAutoDiscoveryRoute {
        ::std::default::Default::default()
    }

    // .google.protobuf.Any rd = 1;


    pub fn get_rd(&self) -> &::protobuf::well_known_types::Any {
        self.rd.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Any::default_instance())
    }
    pub fn clear_rd(&mut self) {
        self.rd.clear();
    }

    pub fn has_rd(&self) -> bool {
        self.rd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rd(&mut self, v: ::protobuf::well_known_types::Any) {
        self.rd = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rd(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.rd.is_none() {
            self.rd.set_default();
        }
        self.rd.as_mut().unwrap()
    }

    // Take field
    pub fn take_rd(&mut self) -> ::protobuf::well_known_types::Any {
        self.rd.take().unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }

    // .gobgpapi.EthernetSegmentIdentifier esi = 2;


    pub fn get_esi(&self) -> &EthernetSegmentIdentifier {
        self.esi.as_ref().unwrap_or_else(|| EthernetSegmentIdentifier::default_instance())
    }
    pub fn clear_esi(&mut self) {
        self.esi.clear();
    }

    pub fn has_esi(&self) -> bool {
        self.esi.is_some()
    }

    // Param is passed by value, moved
    pub fn set_esi(&mut self, v: EthernetSegmentIdentifier) {
        self.esi = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_esi(&mut self) -> &mut EthernetSegmentIdentifier {
        if self.esi.is_none() {
            self.esi.set_default();
        }
        self.esi.as_mut().unwrap()
    }

    // Take field
    pub fn take_esi(&mut self) -> EthernetSegmentIdentifier {
        self.esi.take().unwrap_or_else(|| EthernetSegmentIdentifier::new())
    }

    // uint32 ethernet_tag = 3;


    pub fn get_ethernet_tag(&self) -> u32 {
        self.ethernet_tag
    }
    pub fn clear_ethernet_tag(&mut self) {
        self.ethernet_tag = 0;
    }

    // Param is passed by value, moved
    pub fn set_ethernet_tag(&mut self, v: u32) {
        self.ethernet_tag = v;
    }

    // uint32 label = 4;


    pub fn get_label(&self) -> u32 {
        self.label
    }
    pub fn clear_label(&mut self) {
        self.label = 0;
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: u32) {
        self.label = v;
    }
}

impl ::protobuf::Message for EVPNEthernetAutoDiscoveryRoute {
    fn is_initialized(&self) -> bool {
        for v in &self.rd {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.esi {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rd)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.esi)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ethernet_tag = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.label = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.rd.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.esi.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.ethernet_tag != 0 {
            my_size += ::protobuf::rt::value_size(3, self.ethernet_tag, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.label != 0 {
            my_size += ::protobuf::rt::value_size(4, self.label, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.rd.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.esi.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.ethernet_tag != 0 {
            os.write_uint32(3, self.ethernet_tag)?;
        }
        if self.label != 0 {
            os.write_uint32(4, self.label)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EVPNEthernetAutoDiscoveryRoute {
        EVPNEthernetAutoDiscoveryRoute::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                    "rd",
                    |m: &EVPNEthernetAutoDiscoveryRoute| { &m.rd },
                    |m: &mut EVPNEthernetAutoDiscoveryRoute| { &mut m.rd },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EthernetSegmentIdentifier>>(
                    "esi",
                    |m: &EVPNEthernetAutoDiscoveryRoute| { &m.esi },
                    |m: &mut EVPNEthernetAutoDiscoveryRoute| { &mut m.esi },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ethernet_tag",
                    |m: &EVPNEthernetAutoDiscoveryRoute| { &m.ethernet_tag },
                    |m: &mut EVPNEthernetAutoDiscoveryRoute| { &mut m.ethernet_tag },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "label",
                    |m: &EVPNEthernetAutoDiscoveryRoute| { &m.label },
                    |m: &mut EVPNEthernetAutoDiscoveryRoute| { &mut m.label },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EVPNEthernetAutoDiscoveryRoute>(
                    "EVPNEthernetAutoDiscoveryRoute",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EVPNEthernetAutoDiscoveryRoute {
        static mut instance: ::protobuf::lazy::Lazy<EVPNEthernetAutoDiscoveryRoute> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EVPNEthernetAutoDiscoveryRoute,
        };
        unsafe {
            instance.get(EVPNEthernetAutoDiscoveryRoute::new)
        }
    }
}

impl ::protobuf::Clear for EVPNEthernetAutoDiscoveryRoute {
    fn clear(&mut self) {
        self.rd.clear();
        self.esi.clear();
        self.ethernet_tag = 0;
        self.label = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EVPNEthernetAutoDiscoveryRoute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EVPNEthernetAutoDiscoveryRoute {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EVPNMACIPAdvertisementRoute {
    // message fields
    pub rd: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    pub esi: ::protobuf::SingularPtrField<EthernetSegmentIdentifier>,
    pub ethernet_tag: u32,
    pub mac_address: ::std::string::String,
    pub ip_address: ::std::string::String,
    pub labels: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EVPNMACIPAdvertisementRoute {
    fn default() -> &'a EVPNMACIPAdvertisementRoute {
        <EVPNMACIPAdvertisementRoute as ::protobuf::Message>::default_instance()
    }
}

impl EVPNMACIPAdvertisementRoute {
    pub fn new() -> EVPNMACIPAdvertisementRoute {
        ::std::default::Default::default()
    }

    // .google.protobuf.Any rd = 1;


    pub fn get_rd(&self) -> &::protobuf::well_known_types::Any {
        self.rd.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Any::default_instance())
    }
    pub fn clear_rd(&mut self) {
        self.rd.clear();
    }

    pub fn has_rd(&self) -> bool {
        self.rd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rd(&mut self, v: ::protobuf::well_known_types::Any) {
        self.rd = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rd(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.rd.is_none() {
            self.rd.set_default();
        }
        self.rd.as_mut().unwrap()
    }

    // Take field
    pub fn take_rd(&mut self) -> ::protobuf::well_known_types::Any {
        self.rd.take().unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }

    // .gobgpapi.EthernetSegmentIdentifier esi = 2;


    pub fn get_esi(&self) -> &EthernetSegmentIdentifier {
        self.esi.as_ref().unwrap_or_else(|| EthernetSegmentIdentifier::default_instance())
    }
    pub fn clear_esi(&mut self) {
        self.esi.clear();
    }

    pub fn has_esi(&self) -> bool {
        self.esi.is_some()
    }

    // Param is passed by value, moved
    pub fn set_esi(&mut self, v: EthernetSegmentIdentifier) {
        self.esi = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_esi(&mut self) -> &mut EthernetSegmentIdentifier {
        if self.esi.is_none() {
            self.esi.set_default();
        }
        self.esi.as_mut().unwrap()
    }

    // Take field
    pub fn take_esi(&mut self) -> EthernetSegmentIdentifier {
        self.esi.take().unwrap_or_else(|| EthernetSegmentIdentifier::new())
    }

    // uint32 ethernet_tag = 3;


    pub fn get_ethernet_tag(&self) -> u32 {
        self.ethernet_tag
    }
    pub fn clear_ethernet_tag(&mut self) {
        self.ethernet_tag = 0;
    }

    // Param is passed by value, moved
    pub fn set_ethernet_tag(&mut self, v: u32) {
        self.ethernet_tag = v;
    }

    // string mac_address = 4;


    pub fn get_mac_address(&self) -> &str {
        &self.mac_address
    }
    pub fn clear_mac_address(&mut self) {
        self.mac_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_mac_address(&mut self, v: ::std::string::String) {
        self.mac_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mac_address(&mut self) -> &mut ::std::string::String {
        &mut self.mac_address
    }

    // Take field
    pub fn take_mac_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mac_address, ::std::string::String::new())
    }

    // string ip_address = 5;


    pub fn get_ip_address(&self) -> &str {
        &self.ip_address
    }
    pub fn clear_ip_address(&mut self) {
        self.ip_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_ip_address(&mut self, v: ::std::string::String) {
        self.ip_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip_address(&mut self) -> &mut ::std::string::String {
        &mut self.ip_address
    }

    // Take field
    pub fn take_ip_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ip_address, ::std::string::String::new())
    }

    // repeated uint32 labels = 6;


    pub fn get_labels(&self) -> &[u32] {
        &self.labels
    }
    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: ::std::vec::Vec<u32>) {
        self.labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_labels(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.labels
    }

    // Take field
    pub fn take_labels(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.labels, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for EVPNMACIPAdvertisementRoute {
    fn is_initialized(&self) -> bool {
        for v in &self.rd {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.esi {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rd)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.esi)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ethernet_tag = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.mac_address)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ip_address)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.labels)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.rd.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.esi.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.ethernet_tag != 0 {
            my_size += ::protobuf::rt::value_size(3, self.ethernet_tag, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.mac_address.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.mac_address);
        }
        if !self.ip_address.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.ip_address);
        }
        for value in &self.labels {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.rd.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.esi.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.ethernet_tag != 0 {
            os.write_uint32(3, self.ethernet_tag)?;
        }
        if !self.mac_address.is_empty() {
            os.write_string(4, &self.mac_address)?;
        }
        if !self.ip_address.is_empty() {
            os.write_string(5, &self.ip_address)?;
        }
        for v in &self.labels {
            os.write_uint32(6, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EVPNMACIPAdvertisementRoute {
        EVPNMACIPAdvertisementRoute::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                    "rd",
                    |m: &EVPNMACIPAdvertisementRoute| { &m.rd },
                    |m: &mut EVPNMACIPAdvertisementRoute| { &mut m.rd },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EthernetSegmentIdentifier>>(
                    "esi",
                    |m: &EVPNMACIPAdvertisementRoute| { &m.esi },
                    |m: &mut EVPNMACIPAdvertisementRoute| { &mut m.esi },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ethernet_tag",
                    |m: &EVPNMACIPAdvertisementRoute| { &m.ethernet_tag },
                    |m: &mut EVPNMACIPAdvertisementRoute| { &mut m.ethernet_tag },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "mac_address",
                    |m: &EVPNMACIPAdvertisementRoute| { &m.mac_address },
                    |m: &mut EVPNMACIPAdvertisementRoute| { &mut m.mac_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ip_address",
                    |m: &EVPNMACIPAdvertisementRoute| { &m.ip_address },
                    |m: &mut EVPNMACIPAdvertisementRoute| { &mut m.ip_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "labels",
                    |m: &EVPNMACIPAdvertisementRoute| { &m.labels },
                    |m: &mut EVPNMACIPAdvertisementRoute| { &mut m.labels },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EVPNMACIPAdvertisementRoute>(
                    "EVPNMACIPAdvertisementRoute",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EVPNMACIPAdvertisementRoute {
        static mut instance: ::protobuf::lazy::Lazy<EVPNMACIPAdvertisementRoute> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EVPNMACIPAdvertisementRoute,
        };
        unsafe {
            instance.get(EVPNMACIPAdvertisementRoute::new)
        }
    }
}

impl ::protobuf::Clear for EVPNMACIPAdvertisementRoute {
    fn clear(&mut self) {
        self.rd.clear();
        self.esi.clear();
        self.ethernet_tag = 0;
        self.mac_address.clear();
        self.ip_address.clear();
        self.labels.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EVPNMACIPAdvertisementRoute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EVPNMACIPAdvertisementRoute {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EVPNInclusiveMulticastEthernetTagRoute {
    // message fields
    pub rd: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    pub ethernet_tag: u32,
    pub ip_address: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EVPNInclusiveMulticastEthernetTagRoute {
    fn default() -> &'a EVPNInclusiveMulticastEthernetTagRoute {
        <EVPNInclusiveMulticastEthernetTagRoute as ::protobuf::Message>::default_instance()
    }
}

impl EVPNInclusiveMulticastEthernetTagRoute {
    pub fn new() -> EVPNInclusiveMulticastEthernetTagRoute {
        ::std::default::Default::default()
    }

    // .google.protobuf.Any rd = 1;


    pub fn get_rd(&self) -> &::protobuf::well_known_types::Any {
        self.rd.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Any::default_instance())
    }
    pub fn clear_rd(&mut self) {
        self.rd.clear();
    }

    pub fn has_rd(&self) -> bool {
        self.rd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rd(&mut self, v: ::protobuf::well_known_types::Any) {
        self.rd = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rd(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.rd.is_none() {
            self.rd.set_default();
        }
        self.rd.as_mut().unwrap()
    }

    // Take field
    pub fn take_rd(&mut self) -> ::protobuf::well_known_types::Any {
        self.rd.take().unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }

    // uint32 ethernet_tag = 2;


    pub fn get_ethernet_tag(&self) -> u32 {
        self.ethernet_tag
    }
    pub fn clear_ethernet_tag(&mut self) {
        self.ethernet_tag = 0;
    }

    // Param is passed by value, moved
    pub fn set_ethernet_tag(&mut self, v: u32) {
        self.ethernet_tag = v;
    }

    // string ip_address = 3;


    pub fn get_ip_address(&self) -> &str {
        &self.ip_address
    }
    pub fn clear_ip_address(&mut self) {
        self.ip_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_ip_address(&mut self, v: ::std::string::String) {
        self.ip_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip_address(&mut self) -> &mut ::std::string::String {
        &mut self.ip_address
    }

    // Take field
    pub fn take_ip_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ip_address, ::std::string::String::new())
    }
}

impl ::protobuf::Message for EVPNInclusiveMulticastEthernetTagRoute {
    fn is_initialized(&self) -> bool {
        for v in &self.rd {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rd)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ethernet_tag = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ip_address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.rd.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.ethernet_tag != 0 {
            my_size += ::protobuf::rt::value_size(2, self.ethernet_tag, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.ip_address.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.ip_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.rd.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.ethernet_tag != 0 {
            os.write_uint32(2, self.ethernet_tag)?;
        }
        if !self.ip_address.is_empty() {
            os.write_string(3, &self.ip_address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EVPNInclusiveMulticastEthernetTagRoute {
        EVPNInclusiveMulticastEthernetTagRoute::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                    "rd",
                    |m: &EVPNInclusiveMulticastEthernetTagRoute| { &m.rd },
                    |m: &mut EVPNInclusiveMulticastEthernetTagRoute| { &mut m.rd },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ethernet_tag",
                    |m: &EVPNInclusiveMulticastEthernetTagRoute| { &m.ethernet_tag },
                    |m: &mut EVPNInclusiveMulticastEthernetTagRoute| { &mut m.ethernet_tag },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ip_address",
                    |m: &EVPNInclusiveMulticastEthernetTagRoute| { &m.ip_address },
                    |m: &mut EVPNInclusiveMulticastEthernetTagRoute| { &mut m.ip_address },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EVPNInclusiveMulticastEthernetTagRoute>(
                    "EVPNInclusiveMulticastEthernetTagRoute",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EVPNInclusiveMulticastEthernetTagRoute {
        static mut instance: ::protobuf::lazy::Lazy<EVPNInclusiveMulticastEthernetTagRoute> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EVPNInclusiveMulticastEthernetTagRoute,
        };
        unsafe {
            instance.get(EVPNInclusiveMulticastEthernetTagRoute::new)
        }
    }
}

impl ::protobuf::Clear for EVPNInclusiveMulticastEthernetTagRoute {
    fn clear(&mut self) {
        self.rd.clear();
        self.ethernet_tag = 0;
        self.ip_address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EVPNInclusiveMulticastEthernetTagRoute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EVPNInclusiveMulticastEthernetTagRoute {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EVPNEthernetSegmentRoute {
    // message fields
    pub rd: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    pub esi: ::protobuf::SingularPtrField<EthernetSegmentIdentifier>,
    pub ip_address: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EVPNEthernetSegmentRoute {
    fn default() -> &'a EVPNEthernetSegmentRoute {
        <EVPNEthernetSegmentRoute as ::protobuf::Message>::default_instance()
    }
}

impl EVPNEthernetSegmentRoute {
    pub fn new() -> EVPNEthernetSegmentRoute {
        ::std::default::Default::default()
    }

    // .google.protobuf.Any rd = 1;


    pub fn get_rd(&self) -> &::protobuf::well_known_types::Any {
        self.rd.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Any::default_instance())
    }
    pub fn clear_rd(&mut self) {
        self.rd.clear();
    }

    pub fn has_rd(&self) -> bool {
        self.rd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rd(&mut self, v: ::protobuf::well_known_types::Any) {
        self.rd = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rd(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.rd.is_none() {
            self.rd.set_default();
        }
        self.rd.as_mut().unwrap()
    }

    // Take field
    pub fn take_rd(&mut self) -> ::protobuf::well_known_types::Any {
        self.rd.take().unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }

    // .gobgpapi.EthernetSegmentIdentifier esi = 2;


    pub fn get_esi(&self) -> &EthernetSegmentIdentifier {
        self.esi.as_ref().unwrap_or_else(|| EthernetSegmentIdentifier::default_instance())
    }
    pub fn clear_esi(&mut self) {
        self.esi.clear();
    }

    pub fn has_esi(&self) -> bool {
        self.esi.is_some()
    }

    // Param is passed by value, moved
    pub fn set_esi(&mut self, v: EthernetSegmentIdentifier) {
        self.esi = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_esi(&mut self) -> &mut EthernetSegmentIdentifier {
        if self.esi.is_none() {
            self.esi.set_default();
        }
        self.esi.as_mut().unwrap()
    }

    // Take field
    pub fn take_esi(&mut self) -> EthernetSegmentIdentifier {
        self.esi.take().unwrap_or_else(|| EthernetSegmentIdentifier::new())
    }

    // string ip_address = 3;


    pub fn get_ip_address(&self) -> &str {
        &self.ip_address
    }
    pub fn clear_ip_address(&mut self) {
        self.ip_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_ip_address(&mut self, v: ::std::string::String) {
        self.ip_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip_address(&mut self) -> &mut ::std::string::String {
        &mut self.ip_address
    }

    // Take field
    pub fn take_ip_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ip_address, ::std::string::String::new())
    }
}

impl ::protobuf::Message for EVPNEthernetSegmentRoute {
    fn is_initialized(&self) -> bool {
        for v in &self.rd {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.esi {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rd)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.esi)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ip_address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.rd.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.esi.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.ip_address.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.ip_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.rd.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.esi.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.ip_address.is_empty() {
            os.write_string(3, &self.ip_address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EVPNEthernetSegmentRoute {
        EVPNEthernetSegmentRoute::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                    "rd",
                    |m: &EVPNEthernetSegmentRoute| { &m.rd },
                    |m: &mut EVPNEthernetSegmentRoute| { &mut m.rd },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EthernetSegmentIdentifier>>(
                    "esi",
                    |m: &EVPNEthernetSegmentRoute| { &m.esi },
                    |m: &mut EVPNEthernetSegmentRoute| { &mut m.esi },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ip_address",
                    |m: &EVPNEthernetSegmentRoute| { &m.ip_address },
                    |m: &mut EVPNEthernetSegmentRoute| { &mut m.ip_address },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EVPNEthernetSegmentRoute>(
                    "EVPNEthernetSegmentRoute",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EVPNEthernetSegmentRoute {
        static mut instance: ::protobuf::lazy::Lazy<EVPNEthernetSegmentRoute> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EVPNEthernetSegmentRoute,
        };
        unsafe {
            instance.get(EVPNEthernetSegmentRoute::new)
        }
    }
}

impl ::protobuf::Clear for EVPNEthernetSegmentRoute {
    fn clear(&mut self) {
        self.rd.clear();
        self.esi.clear();
        self.ip_address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EVPNEthernetSegmentRoute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EVPNEthernetSegmentRoute {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EVPNIPPrefixRoute {
    // message fields
    pub rd: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    pub esi: ::protobuf::SingularPtrField<EthernetSegmentIdentifier>,
    pub ethernet_tag: u32,
    pub ip_prefix: ::std::string::String,
    pub ip_prefix_len: u32,
    pub gw_address: ::std::string::String,
    pub label: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EVPNIPPrefixRoute {
    fn default() -> &'a EVPNIPPrefixRoute {
        <EVPNIPPrefixRoute as ::protobuf::Message>::default_instance()
    }
}

impl EVPNIPPrefixRoute {
    pub fn new() -> EVPNIPPrefixRoute {
        ::std::default::Default::default()
    }

    // .google.protobuf.Any rd = 1;


    pub fn get_rd(&self) -> &::protobuf::well_known_types::Any {
        self.rd.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Any::default_instance())
    }
    pub fn clear_rd(&mut self) {
        self.rd.clear();
    }

    pub fn has_rd(&self) -> bool {
        self.rd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rd(&mut self, v: ::protobuf::well_known_types::Any) {
        self.rd = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rd(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.rd.is_none() {
            self.rd.set_default();
        }
        self.rd.as_mut().unwrap()
    }

    // Take field
    pub fn take_rd(&mut self) -> ::protobuf::well_known_types::Any {
        self.rd.take().unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }

    // .gobgpapi.EthernetSegmentIdentifier esi = 2;


    pub fn get_esi(&self) -> &EthernetSegmentIdentifier {
        self.esi.as_ref().unwrap_or_else(|| EthernetSegmentIdentifier::default_instance())
    }
    pub fn clear_esi(&mut self) {
        self.esi.clear();
    }

    pub fn has_esi(&self) -> bool {
        self.esi.is_some()
    }

    // Param is passed by value, moved
    pub fn set_esi(&mut self, v: EthernetSegmentIdentifier) {
        self.esi = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_esi(&mut self) -> &mut EthernetSegmentIdentifier {
        if self.esi.is_none() {
            self.esi.set_default();
        }
        self.esi.as_mut().unwrap()
    }

    // Take field
    pub fn take_esi(&mut self) -> EthernetSegmentIdentifier {
        self.esi.take().unwrap_or_else(|| EthernetSegmentIdentifier::new())
    }

    // uint32 ethernet_tag = 3;


    pub fn get_ethernet_tag(&self) -> u32 {
        self.ethernet_tag
    }
    pub fn clear_ethernet_tag(&mut self) {
        self.ethernet_tag = 0;
    }

    // Param is passed by value, moved
    pub fn set_ethernet_tag(&mut self, v: u32) {
        self.ethernet_tag = v;
    }

    // string ip_prefix = 4;


    pub fn get_ip_prefix(&self) -> &str {
        &self.ip_prefix
    }
    pub fn clear_ip_prefix(&mut self) {
        self.ip_prefix.clear();
    }

    // Param is passed by value, moved
    pub fn set_ip_prefix(&mut self, v: ::std::string::String) {
        self.ip_prefix = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip_prefix(&mut self) -> &mut ::std::string::String {
        &mut self.ip_prefix
    }

    // Take field
    pub fn take_ip_prefix(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ip_prefix, ::std::string::String::new())
    }

    // uint32 ip_prefix_len = 5;


    pub fn get_ip_prefix_len(&self) -> u32 {
        self.ip_prefix_len
    }
    pub fn clear_ip_prefix_len(&mut self) {
        self.ip_prefix_len = 0;
    }

    // Param is passed by value, moved
    pub fn set_ip_prefix_len(&mut self, v: u32) {
        self.ip_prefix_len = v;
    }

    // string gw_address = 6;


    pub fn get_gw_address(&self) -> &str {
        &self.gw_address
    }
    pub fn clear_gw_address(&mut self) {
        self.gw_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_gw_address(&mut self, v: ::std::string::String) {
        self.gw_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gw_address(&mut self) -> &mut ::std::string::String {
        &mut self.gw_address
    }

    // Take field
    pub fn take_gw_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.gw_address, ::std::string::String::new())
    }

    // uint32 label = 7;


    pub fn get_label(&self) -> u32 {
        self.label
    }
    pub fn clear_label(&mut self) {
        self.label = 0;
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: u32) {
        self.label = v;
    }
}

impl ::protobuf::Message for EVPNIPPrefixRoute {
    fn is_initialized(&self) -> bool {
        for v in &self.rd {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.esi {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rd)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.esi)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ethernet_tag = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ip_prefix)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ip_prefix_len = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.gw_address)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.label = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.rd.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.esi.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.ethernet_tag != 0 {
            my_size += ::protobuf::rt::value_size(3, self.ethernet_tag, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.ip_prefix.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.ip_prefix);
        }
        if self.ip_prefix_len != 0 {
            my_size += ::protobuf::rt::value_size(5, self.ip_prefix_len, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.gw_address.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.gw_address);
        }
        if self.label != 0 {
            my_size += ::protobuf::rt::value_size(7, self.label, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.rd.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.esi.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.ethernet_tag != 0 {
            os.write_uint32(3, self.ethernet_tag)?;
        }
        if !self.ip_prefix.is_empty() {
            os.write_string(4, &self.ip_prefix)?;
        }
        if self.ip_prefix_len != 0 {
            os.write_uint32(5, self.ip_prefix_len)?;
        }
        if !self.gw_address.is_empty() {
            os.write_string(6, &self.gw_address)?;
        }
        if self.label != 0 {
            os.write_uint32(7, self.label)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EVPNIPPrefixRoute {
        EVPNIPPrefixRoute::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                    "rd",
                    |m: &EVPNIPPrefixRoute| { &m.rd },
                    |m: &mut EVPNIPPrefixRoute| { &mut m.rd },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EthernetSegmentIdentifier>>(
                    "esi",
                    |m: &EVPNIPPrefixRoute| { &m.esi },
                    |m: &mut EVPNIPPrefixRoute| { &mut m.esi },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ethernet_tag",
                    |m: &EVPNIPPrefixRoute| { &m.ethernet_tag },
                    |m: &mut EVPNIPPrefixRoute| { &mut m.ethernet_tag },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ip_prefix",
                    |m: &EVPNIPPrefixRoute| { &m.ip_prefix },
                    |m: &mut EVPNIPPrefixRoute| { &mut m.ip_prefix },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ip_prefix_len",
                    |m: &EVPNIPPrefixRoute| { &m.ip_prefix_len },
                    |m: &mut EVPNIPPrefixRoute| { &mut m.ip_prefix_len },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "gw_address",
                    |m: &EVPNIPPrefixRoute| { &m.gw_address },
                    |m: &mut EVPNIPPrefixRoute| { &mut m.gw_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "label",
                    |m: &EVPNIPPrefixRoute| { &m.label },
                    |m: &mut EVPNIPPrefixRoute| { &mut m.label },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EVPNIPPrefixRoute>(
                    "EVPNIPPrefixRoute",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EVPNIPPrefixRoute {
        static mut instance: ::protobuf::lazy::Lazy<EVPNIPPrefixRoute> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EVPNIPPrefixRoute,
        };
        unsafe {
            instance.get(EVPNIPPrefixRoute::new)
        }
    }
}

impl ::protobuf::Clear for EVPNIPPrefixRoute {
    fn clear(&mut self) {
        self.rd.clear();
        self.esi.clear();
        self.ethernet_tag = 0;
        self.ip_prefix.clear();
        self.ip_prefix_len = 0;
        self.gw_address.clear();
        self.label = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EVPNIPPrefixRoute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EVPNIPPrefixRoute {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EVPNIPMSIRoute {
    // message fields
    pub rd: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    pub ethernet_tag: u32,
    pub rt: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EVPNIPMSIRoute {
    fn default() -> &'a EVPNIPMSIRoute {
        <EVPNIPMSIRoute as ::protobuf::Message>::default_instance()
    }
}

impl EVPNIPMSIRoute {
    pub fn new() -> EVPNIPMSIRoute {
        ::std::default::Default::default()
    }

    // .google.protobuf.Any rd = 1;


    pub fn get_rd(&self) -> &::protobuf::well_known_types::Any {
        self.rd.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Any::default_instance())
    }
    pub fn clear_rd(&mut self) {
        self.rd.clear();
    }

    pub fn has_rd(&self) -> bool {
        self.rd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rd(&mut self, v: ::protobuf::well_known_types::Any) {
        self.rd = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rd(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.rd.is_none() {
            self.rd.set_default();
        }
        self.rd.as_mut().unwrap()
    }

    // Take field
    pub fn take_rd(&mut self) -> ::protobuf::well_known_types::Any {
        self.rd.take().unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }

    // uint32 ethernet_tag = 2;


    pub fn get_ethernet_tag(&self) -> u32 {
        self.ethernet_tag
    }
    pub fn clear_ethernet_tag(&mut self) {
        self.ethernet_tag = 0;
    }

    // Param is passed by value, moved
    pub fn set_ethernet_tag(&mut self, v: u32) {
        self.ethernet_tag = v;
    }

    // .google.protobuf.Any rt = 3;


    pub fn get_rt(&self) -> &::protobuf::well_known_types::Any {
        self.rt.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Any::default_instance())
    }
    pub fn clear_rt(&mut self) {
        self.rt.clear();
    }

    pub fn has_rt(&self) -> bool {
        self.rt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rt(&mut self, v: ::protobuf::well_known_types::Any) {
        self.rt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rt(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.rt.is_none() {
            self.rt.set_default();
        }
        self.rt.as_mut().unwrap()
    }

    // Take field
    pub fn take_rt(&mut self) -> ::protobuf::well_known_types::Any {
        self.rt.take().unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }
}

impl ::protobuf::Message for EVPNIPMSIRoute {
    fn is_initialized(&self) -> bool {
        for v in &self.rd {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rt {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rd)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ethernet_tag = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rt)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.rd.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.ethernet_tag != 0 {
            my_size += ::protobuf::rt::value_size(2, self.ethernet_tag, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.rt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.rd.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.ethernet_tag != 0 {
            os.write_uint32(2, self.ethernet_tag)?;
        }
        if let Some(ref v) = self.rt.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EVPNIPMSIRoute {
        EVPNIPMSIRoute::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                    "rd",
                    |m: &EVPNIPMSIRoute| { &m.rd },
                    |m: &mut EVPNIPMSIRoute| { &mut m.rd },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ethernet_tag",
                    |m: &EVPNIPMSIRoute| { &m.ethernet_tag },
                    |m: &mut EVPNIPMSIRoute| { &mut m.ethernet_tag },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                    "rt",
                    |m: &EVPNIPMSIRoute| { &m.rt },
                    |m: &mut EVPNIPMSIRoute| { &mut m.rt },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EVPNIPMSIRoute>(
                    "EVPNIPMSIRoute",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EVPNIPMSIRoute {
        static mut instance: ::protobuf::lazy::Lazy<EVPNIPMSIRoute> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EVPNIPMSIRoute,
        };
        unsafe {
            instance.get(EVPNIPMSIRoute::new)
        }
    }
}

impl ::protobuf::Clear for EVPNIPMSIRoute {
    fn clear(&mut self) {
        self.rd.clear();
        self.ethernet_tag = 0;
        self.rt.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EVPNIPMSIRoute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EVPNIPMSIRoute {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LabeledVPNIPAddressPrefix {
    // message fields
    pub labels: ::std::vec::Vec<u32>,
    pub rd: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    pub prefix_len: u32,
    pub prefix: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LabeledVPNIPAddressPrefix {
    fn default() -> &'a LabeledVPNIPAddressPrefix {
        <LabeledVPNIPAddressPrefix as ::protobuf::Message>::default_instance()
    }
}

impl LabeledVPNIPAddressPrefix {
    pub fn new() -> LabeledVPNIPAddressPrefix {
        ::std::default::Default::default()
    }

    // repeated uint32 labels = 1;


    pub fn get_labels(&self) -> &[u32] {
        &self.labels
    }
    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: ::std::vec::Vec<u32>) {
        self.labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_labels(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.labels
    }

    // Take field
    pub fn take_labels(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.labels, ::std::vec::Vec::new())
    }

    // .google.protobuf.Any rd = 2;


    pub fn get_rd(&self) -> &::protobuf::well_known_types::Any {
        self.rd.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Any::default_instance())
    }
    pub fn clear_rd(&mut self) {
        self.rd.clear();
    }

    pub fn has_rd(&self) -> bool {
        self.rd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rd(&mut self, v: ::protobuf::well_known_types::Any) {
        self.rd = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rd(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.rd.is_none() {
            self.rd.set_default();
        }
        self.rd.as_mut().unwrap()
    }

    // Take field
    pub fn take_rd(&mut self) -> ::protobuf::well_known_types::Any {
        self.rd.take().unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }

    // uint32 prefix_len = 3;


    pub fn get_prefix_len(&self) -> u32 {
        self.prefix_len
    }
    pub fn clear_prefix_len(&mut self) {
        self.prefix_len = 0;
    }

    // Param is passed by value, moved
    pub fn set_prefix_len(&mut self, v: u32) {
        self.prefix_len = v;
    }

    // string prefix = 4;


    pub fn get_prefix(&self) -> &str {
        &self.prefix
    }
    pub fn clear_prefix(&mut self) {
        self.prefix.clear();
    }

    // Param is passed by value, moved
    pub fn set_prefix(&mut self, v: ::std::string::String) {
        self.prefix = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prefix(&mut self) -> &mut ::std::string::String {
        &mut self.prefix
    }

    // Take field
    pub fn take_prefix(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.prefix, ::std::string::String::new())
    }
}

impl ::protobuf::Message for LabeledVPNIPAddressPrefix {
    fn is_initialized(&self) -> bool {
        for v in &self.rd {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.labels)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rd)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.prefix_len = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.prefix)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.labels {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(ref v) = self.rd.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.prefix_len != 0 {
            my_size += ::protobuf::rt::value_size(3, self.prefix_len, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.prefix.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.prefix);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.labels {
            os.write_uint32(1, *v)?;
        };
        if let Some(ref v) = self.rd.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.prefix_len != 0 {
            os.write_uint32(3, self.prefix_len)?;
        }
        if !self.prefix.is_empty() {
            os.write_string(4, &self.prefix)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LabeledVPNIPAddressPrefix {
        LabeledVPNIPAddressPrefix::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "labels",
                    |m: &LabeledVPNIPAddressPrefix| { &m.labels },
                    |m: &mut LabeledVPNIPAddressPrefix| { &mut m.labels },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                    "rd",
                    |m: &LabeledVPNIPAddressPrefix| { &m.rd },
                    |m: &mut LabeledVPNIPAddressPrefix| { &mut m.rd },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "prefix_len",
                    |m: &LabeledVPNIPAddressPrefix| { &m.prefix_len },
                    |m: &mut LabeledVPNIPAddressPrefix| { &mut m.prefix_len },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "prefix",
                    |m: &LabeledVPNIPAddressPrefix| { &m.prefix },
                    |m: &mut LabeledVPNIPAddressPrefix| { &mut m.prefix },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LabeledVPNIPAddressPrefix>(
                    "LabeledVPNIPAddressPrefix",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LabeledVPNIPAddressPrefix {
        static mut instance: ::protobuf::lazy::Lazy<LabeledVPNIPAddressPrefix> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LabeledVPNIPAddressPrefix,
        };
        unsafe {
            instance.get(LabeledVPNIPAddressPrefix::new)
        }
    }
}

impl ::protobuf::Clear for LabeledVPNIPAddressPrefix {
    fn clear(&mut self) {
        self.labels.clear();
        self.rd.clear();
        self.prefix_len = 0;
        self.prefix.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LabeledVPNIPAddressPrefix {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LabeledVPNIPAddressPrefix {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RouteTargetMembershipNLRI {
    // message fields
    pub field_as: u32,
    pub rt: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RouteTargetMembershipNLRI {
    fn default() -> &'a RouteTargetMembershipNLRI {
        <RouteTargetMembershipNLRI as ::protobuf::Message>::default_instance()
    }
}

impl RouteTargetMembershipNLRI {
    pub fn new() -> RouteTargetMembershipNLRI {
        ::std::default::Default::default()
    }

    // uint32 as = 1;


    pub fn get_field_as(&self) -> u32 {
        self.field_as
    }
    pub fn clear_field_as(&mut self) {
        self.field_as = 0;
    }

    // Param is passed by value, moved
    pub fn set_field_as(&mut self, v: u32) {
        self.field_as = v;
    }

    // .google.protobuf.Any rt = 2;


    pub fn get_rt(&self) -> &::protobuf::well_known_types::Any {
        self.rt.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Any::default_instance())
    }
    pub fn clear_rt(&mut self) {
        self.rt.clear();
    }

    pub fn has_rt(&self) -> bool {
        self.rt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rt(&mut self, v: ::protobuf::well_known_types::Any) {
        self.rt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rt(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.rt.is_none() {
            self.rt.set_default();
        }
        self.rt.as_mut().unwrap()
    }

    // Take field
    pub fn take_rt(&mut self) -> ::protobuf::well_known_types::Any {
        self.rt.take().unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }
}

impl ::protobuf::Message for RouteTargetMembershipNLRI {
    fn is_initialized(&self) -> bool {
        for v in &self.rt {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.field_as = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rt)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_as != 0 {
            my_size += ::protobuf::rt::value_size(1, self.field_as, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.rt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_as != 0 {
            os.write_uint32(1, self.field_as)?;
        }
        if let Some(ref v) = self.rt.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouteTargetMembershipNLRI {
        RouteTargetMembershipNLRI::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "as",
                    |m: &RouteTargetMembershipNLRI| { &m.field_as },
                    |m: &mut RouteTargetMembershipNLRI| { &mut m.field_as },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                    "rt",
                    |m: &RouteTargetMembershipNLRI| { &m.rt },
                    |m: &mut RouteTargetMembershipNLRI| { &mut m.rt },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RouteTargetMembershipNLRI>(
                    "RouteTargetMembershipNLRI",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RouteTargetMembershipNLRI {
        static mut instance: ::protobuf::lazy::Lazy<RouteTargetMembershipNLRI> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RouteTargetMembershipNLRI,
        };
        unsafe {
            instance.get(RouteTargetMembershipNLRI::new)
        }
    }
}

impl ::protobuf::Clear for RouteTargetMembershipNLRI {
    fn clear(&mut self) {
        self.field_as = 0;
        self.rt.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouteTargetMembershipNLRI {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteTargetMembershipNLRI {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FlowSpecIPPrefix {
    // message fields
    pub field_type: u32,
    pub prefix_len: u32,
    pub prefix: ::std::string::String,
    pub offset: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FlowSpecIPPrefix {
    fn default() -> &'a FlowSpecIPPrefix {
        <FlowSpecIPPrefix as ::protobuf::Message>::default_instance()
    }
}

impl FlowSpecIPPrefix {
    pub fn new() -> FlowSpecIPPrefix {
        ::std::default::Default::default()
    }

    // uint32 type = 1;


    pub fn get_field_type(&self) -> u32 {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = 0;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: u32) {
        self.field_type = v;
    }

    // uint32 prefix_len = 2;


    pub fn get_prefix_len(&self) -> u32 {
        self.prefix_len
    }
    pub fn clear_prefix_len(&mut self) {
        self.prefix_len = 0;
    }

    // Param is passed by value, moved
    pub fn set_prefix_len(&mut self, v: u32) {
        self.prefix_len = v;
    }

    // string prefix = 3;


    pub fn get_prefix(&self) -> &str {
        &self.prefix
    }
    pub fn clear_prefix(&mut self) {
        self.prefix.clear();
    }

    // Param is passed by value, moved
    pub fn set_prefix(&mut self, v: ::std::string::String) {
        self.prefix = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prefix(&mut self) -> &mut ::std::string::String {
        &mut self.prefix
    }

    // Take field
    pub fn take_prefix(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.prefix, ::std::string::String::new())
    }

    // uint32 offset = 4;


    pub fn get_offset(&self) -> u32 {
        self.offset
    }
    pub fn clear_offset(&mut self) {
        self.offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u32) {
        self.offset = v;
    }
}

impl ::protobuf::Message for FlowSpecIPPrefix {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.field_type = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.prefix_len = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.prefix)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.offset = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != 0 {
            my_size += ::protobuf::rt::value_size(1, self.field_type, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.prefix_len != 0 {
            my_size += ::protobuf::rt::value_size(2, self.prefix_len, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.prefix.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.prefix);
        }
        if self.offset != 0 {
            my_size += ::protobuf::rt::value_size(4, self.offset, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != 0 {
            os.write_uint32(1, self.field_type)?;
        }
        if self.prefix_len != 0 {
            os.write_uint32(2, self.prefix_len)?;
        }
        if !self.prefix.is_empty() {
            os.write_string(3, &self.prefix)?;
        }
        if self.offset != 0 {
            os.write_uint32(4, self.offset)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FlowSpecIPPrefix {
        FlowSpecIPPrefix::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "type",
                    |m: &FlowSpecIPPrefix| { &m.field_type },
                    |m: &mut FlowSpecIPPrefix| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "prefix_len",
                    |m: &FlowSpecIPPrefix| { &m.prefix_len },
                    |m: &mut FlowSpecIPPrefix| { &mut m.prefix_len },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "prefix",
                    |m: &FlowSpecIPPrefix| { &m.prefix },
                    |m: &mut FlowSpecIPPrefix| { &mut m.prefix },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "offset",
                    |m: &FlowSpecIPPrefix| { &m.offset },
                    |m: &mut FlowSpecIPPrefix| { &mut m.offset },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FlowSpecIPPrefix>(
                    "FlowSpecIPPrefix",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FlowSpecIPPrefix {
        static mut instance: ::protobuf::lazy::Lazy<FlowSpecIPPrefix> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FlowSpecIPPrefix,
        };
        unsafe {
            instance.get(FlowSpecIPPrefix::new)
        }
    }
}

impl ::protobuf::Clear for FlowSpecIPPrefix {
    fn clear(&mut self) {
        self.field_type = 0;
        self.prefix_len = 0;
        self.prefix.clear();
        self.offset = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FlowSpecIPPrefix {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FlowSpecIPPrefix {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FlowSpecMAC {
    // message fields
    pub field_type: u32,
    pub address: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FlowSpecMAC {
    fn default() -> &'a FlowSpecMAC {
        <FlowSpecMAC as ::protobuf::Message>::default_instance()
    }
}

impl FlowSpecMAC {
    pub fn new() -> FlowSpecMAC {
        ::std::default::Default::default()
    }

    // uint32 type = 1;


    pub fn get_field_type(&self) -> u32 {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = 0;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: u32) {
        self.field_type = v;
    }

    // string address = 2;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }
}

impl ::protobuf::Message for FlowSpecMAC {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.field_type = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != 0 {
            my_size += ::protobuf::rt::value_size(1, self.field_type, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != 0 {
            os.write_uint32(1, self.field_type)?;
        }
        if !self.address.is_empty() {
            os.write_string(2, &self.address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FlowSpecMAC {
        FlowSpecMAC::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "type",
                    |m: &FlowSpecMAC| { &m.field_type },
                    |m: &mut FlowSpecMAC| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "address",
                    |m: &FlowSpecMAC| { &m.address },
                    |m: &mut FlowSpecMAC| { &mut m.address },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FlowSpecMAC>(
                    "FlowSpecMAC",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FlowSpecMAC {
        static mut instance: ::protobuf::lazy::Lazy<FlowSpecMAC> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FlowSpecMAC,
        };
        unsafe {
            instance.get(FlowSpecMAC::new)
        }
    }
}

impl ::protobuf::Clear for FlowSpecMAC {
    fn clear(&mut self) {
        self.field_type = 0;
        self.address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FlowSpecMAC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FlowSpecMAC {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FlowSpecComponentItem {
    // message fields
    pub op: u32,
    pub value: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FlowSpecComponentItem {
    fn default() -> &'a FlowSpecComponentItem {
        <FlowSpecComponentItem as ::protobuf::Message>::default_instance()
    }
}

impl FlowSpecComponentItem {
    pub fn new() -> FlowSpecComponentItem {
        ::std::default::Default::default()
    }

    // uint32 op = 1;


    pub fn get_op(&self) -> u32 {
        self.op
    }
    pub fn clear_op(&mut self) {
        self.op = 0;
    }

    // Param is passed by value, moved
    pub fn set_op(&mut self, v: u32) {
        self.op = v;
    }

    // uint64 value = 2;


    pub fn get_value(&self) -> u64 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u64) {
        self.value = v;
    }
}

impl ::protobuf::Message for FlowSpecComponentItem {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.op = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.value = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.op != 0 {
            my_size += ::protobuf::rt::value_size(1, self.op, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.value != 0 {
            my_size += ::protobuf::rt::value_size(2, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.op != 0 {
            os.write_uint32(1, self.op)?;
        }
        if self.value != 0 {
            os.write_uint64(2, self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FlowSpecComponentItem {
        FlowSpecComponentItem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "op",
                    |m: &FlowSpecComponentItem| { &m.op },
                    |m: &mut FlowSpecComponentItem| { &mut m.op },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "value",
                    |m: &FlowSpecComponentItem| { &m.value },
                    |m: &mut FlowSpecComponentItem| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FlowSpecComponentItem>(
                    "FlowSpecComponentItem",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FlowSpecComponentItem {
        static mut instance: ::protobuf::lazy::Lazy<FlowSpecComponentItem> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FlowSpecComponentItem,
        };
        unsafe {
            instance.get(FlowSpecComponentItem::new)
        }
    }
}

impl ::protobuf::Clear for FlowSpecComponentItem {
    fn clear(&mut self) {
        self.op = 0;
        self.value = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FlowSpecComponentItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FlowSpecComponentItem {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FlowSpecComponent {
    // message fields
    pub field_type: u32,
    pub items: ::protobuf::RepeatedField<FlowSpecComponentItem>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FlowSpecComponent {
    fn default() -> &'a FlowSpecComponent {
        <FlowSpecComponent as ::protobuf::Message>::default_instance()
    }
}

impl FlowSpecComponent {
    pub fn new() -> FlowSpecComponent {
        ::std::default::Default::default()
    }

    // uint32 type = 1;


    pub fn get_field_type(&self) -> u32 {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = 0;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: u32) {
        self.field_type = v;
    }

    // repeated .gobgpapi.FlowSpecComponentItem items = 2;


    pub fn get_items(&self) -> &[FlowSpecComponentItem] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<FlowSpecComponentItem>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<FlowSpecComponentItem> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<FlowSpecComponentItem> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for FlowSpecComponent {
    fn is_initialized(&self) -> bool {
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.field_type = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != 0 {
            my_size += ::protobuf::rt::value_size(1, self.field_type, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != 0 {
            os.write_uint32(1, self.field_type)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FlowSpecComponent {
        FlowSpecComponent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "type",
                    |m: &FlowSpecComponent| { &m.field_type },
                    |m: &mut FlowSpecComponent| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FlowSpecComponentItem>>(
                    "items",
                    |m: &FlowSpecComponent| { &m.items },
                    |m: &mut FlowSpecComponent| { &mut m.items },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FlowSpecComponent>(
                    "FlowSpecComponent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FlowSpecComponent {
        static mut instance: ::protobuf::lazy::Lazy<FlowSpecComponent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FlowSpecComponent,
        };
        unsafe {
            instance.get(FlowSpecComponent::new)
        }
    }
}

impl ::protobuf::Clear for FlowSpecComponent {
    fn clear(&mut self) {
        self.field_type = 0;
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FlowSpecComponent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FlowSpecComponent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FlowSpecNLRI {
    // message fields
    pub rules: ::protobuf::RepeatedField<::protobuf::well_known_types::Any>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FlowSpecNLRI {
    fn default() -> &'a FlowSpecNLRI {
        <FlowSpecNLRI as ::protobuf::Message>::default_instance()
    }
}

impl FlowSpecNLRI {
    pub fn new() -> FlowSpecNLRI {
        ::std::default::Default::default()
    }

    // repeated .google.protobuf.Any rules = 1;


    pub fn get_rules(&self) -> &[::protobuf::well_known_types::Any] {
        &self.rules
    }
    pub fn clear_rules(&mut self) {
        self.rules.clear();
    }

    // Param is passed by value, moved
    pub fn set_rules(&mut self, v: ::protobuf::RepeatedField<::protobuf::well_known_types::Any>) {
        self.rules = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rules(&mut self) -> &mut ::protobuf::RepeatedField<::protobuf::well_known_types::Any> {
        &mut self.rules
    }

    // Take field
    pub fn take_rules(&mut self) -> ::protobuf::RepeatedField<::protobuf::well_known_types::Any> {
        ::std::mem::replace(&mut self.rules, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for FlowSpecNLRI {
    fn is_initialized(&self) -> bool {
        for v in &self.rules {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.rules)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.rules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.rules {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FlowSpecNLRI {
        FlowSpecNLRI::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                    "rules",
                    |m: &FlowSpecNLRI| { &m.rules },
                    |m: &mut FlowSpecNLRI| { &mut m.rules },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FlowSpecNLRI>(
                    "FlowSpecNLRI",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FlowSpecNLRI {
        static mut instance: ::protobuf::lazy::Lazy<FlowSpecNLRI> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FlowSpecNLRI,
        };
        unsafe {
            instance.get(FlowSpecNLRI::new)
        }
    }
}

impl ::protobuf::Clear for FlowSpecNLRI {
    fn clear(&mut self) {
        self.rules.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FlowSpecNLRI {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FlowSpecNLRI {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VPNFlowSpecNLRI {
    // message fields
    pub rd: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    pub rules: ::protobuf::RepeatedField<::protobuf::well_known_types::Any>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VPNFlowSpecNLRI {
    fn default() -> &'a VPNFlowSpecNLRI {
        <VPNFlowSpecNLRI as ::protobuf::Message>::default_instance()
    }
}

impl VPNFlowSpecNLRI {
    pub fn new() -> VPNFlowSpecNLRI {
        ::std::default::Default::default()
    }

    // .google.protobuf.Any rd = 1;


    pub fn get_rd(&self) -> &::protobuf::well_known_types::Any {
        self.rd.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Any::default_instance())
    }
    pub fn clear_rd(&mut self) {
        self.rd.clear();
    }

    pub fn has_rd(&self) -> bool {
        self.rd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rd(&mut self, v: ::protobuf::well_known_types::Any) {
        self.rd = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rd(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.rd.is_none() {
            self.rd.set_default();
        }
        self.rd.as_mut().unwrap()
    }

    // Take field
    pub fn take_rd(&mut self) -> ::protobuf::well_known_types::Any {
        self.rd.take().unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }

    // repeated .google.protobuf.Any rules = 2;


    pub fn get_rules(&self) -> &[::protobuf::well_known_types::Any] {
        &self.rules
    }
    pub fn clear_rules(&mut self) {
        self.rules.clear();
    }

    // Param is passed by value, moved
    pub fn set_rules(&mut self, v: ::protobuf::RepeatedField<::protobuf::well_known_types::Any>) {
        self.rules = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rules(&mut self) -> &mut ::protobuf::RepeatedField<::protobuf::well_known_types::Any> {
        &mut self.rules
    }

    // Take field
    pub fn take_rules(&mut self) -> ::protobuf::RepeatedField<::protobuf::well_known_types::Any> {
        ::std::mem::replace(&mut self.rules, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for VPNFlowSpecNLRI {
    fn is_initialized(&self) -> bool {
        for v in &self.rd {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rules {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rd)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.rules)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.rd.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.rules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.rd.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.rules {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VPNFlowSpecNLRI {
        VPNFlowSpecNLRI::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                    "rd",
                    |m: &VPNFlowSpecNLRI| { &m.rd },
                    |m: &mut VPNFlowSpecNLRI| { &mut m.rd },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                    "rules",
                    |m: &VPNFlowSpecNLRI| { &m.rules },
                    |m: &mut VPNFlowSpecNLRI| { &mut m.rules },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<VPNFlowSpecNLRI>(
                    "VPNFlowSpecNLRI",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VPNFlowSpecNLRI {
        static mut instance: ::protobuf::lazy::Lazy<VPNFlowSpecNLRI> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const VPNFlowSpecNLRI,
        };
        unsafe {
            instance.get(VPNFlowSpecNLRI::new)
        }
    }
}

impl ::protobuf::Clear for VPNFlowSpecNLRI {
    fn clear(&mut self) {
        self.rd.clear();
        self.rules.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VPNFlowSpecNLRI {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VPNFlowSpecNLRI {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OpaqueNLRI {
    // message fields
    pub key: ::std::vec::Vec<u8>,
    pub value: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OpaqueNLRI {
    fn default() -> &'a OpaqueNLRI {
        <OpaqueNLRI as ::protobuf::Message>::default_instance()
    }
}

impl OpaqueNLRI {
    pub fn new() -> OpaqueNLRI {
        ::std::default::Default::default()
    }

    // bytes key = 1;


    pub fn get_key(&self) -> &[u8] {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.key, ::std::vec::Vec::new())
    }

    // bytes value = 2;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for OpaqueNLRI {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_bytes(1, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(2, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OpaqueNLRI {
        OpaqueNLRI::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "key",
                    |m: &OpaqueNLRI| { &m.key },
                    |m: &mut OpaqueNLRI| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "value",
                    |m: &OpaqueNLRI| { &m.value },
                    |m: &mut OpaqueNLRI| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OpaqueNLRI>(
                    "OpaqueNLRI",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static OpaqueNLRI {
        static mut instance: ::protobuf::lazy::Lazy<OpaqueNLRI> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OpaqueNLRI,
        };
        unsafe {
            instance.get(OpaqueNLRI::new)
        }
    }
}

impl ::protobuf::Clear for OpaqueNLRI {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OpaqueNLRI {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpaqueNLRI {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LsNodeDescriptor {
    // message fields
    pub asn: u32,
    pub bgp_ls_id: u32,
    pub ospf_area_id: u32,
    pub pseudonode: bool,
    pub igp_router_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LsNodeDescriptor {
    fn default() -> &'a LsNodeDescriptor {
        <LsNodeDescriptor as ::protobuf::Message>::default_instance()
    }
}

impl LsNodeDescriptor {
    pub fn new() -> LsNodeDescriptor {
        ::std::default::Default::default()
    }

    // uint32 asn = 1;


    pub fn get_asn(&self) -> u32 {
        self.asn
    }
    pub fn clear_asn(&mut self) {
        self.asn = 0;
    }

    // Param is passed by value, moved
    pub fn set_asn(&mut self, v: u32) {
        self.asn = v;
    }

    // uint32 bgp_ls_id = 2;


    pub fn get_bgp_ls_id(&self) -> u32 {
        self.bgp_ls_id
    }
    pub fn clear_bgp_ls_id(&mut self) {
        self.bgp_ls_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_bgp_ls_id(&mut self, v: u32) {
        self.bgp_ls_id = v;
    }

    // uint32 ospf_area_id = 3;


    pub fn get_ospf_area_id(&self) -> u32 {
        self.ospf_area_id
    }
    pub fn clear_ospf_area_id(&mut self) {
        self.ospf_area_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_ospf_area_id(&mut self, v: u32) {
        self.ospf_area_id = v;
    }

    // bool pseudonode = 4;


    pub fn get_pseudonode(&self) -> bool {
        self.pseudonode
    }
    pub fn clear_pseudonode(&mut self) {
        self.pseudonode = false;
    }

    // Param is passed by value, moved
    pub fn set_pseudonode(&mut self, v: bool) {
        self.pseudonode = v;
    }

    // string igp_router_id = 5;


    pub fn get_igp_router_id(&self) -> &str {
        &self.igp_router_id
    }
    pub fn clear_igp_router_id(&mut self) {
        self.igp_router_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_igp_router_id(&mut self, v: ::std::string::String) {
        self.igp_router_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_igp_router_id(&mut self) -> &mut ::std::string::String {
        &mut self.igp_router_id
    }

    // Take field
    pub fn take_igp_router_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.igp_router_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for LsNodeDescriptor {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.asn = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.bgp_ls_id = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ospf_area_id = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.pseudonode = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.igp_router_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.asn != 0 {
            my_size += ::protobuf::rt::value_size(1, self.asn, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.bgp_ls_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.bgp_ls_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.ospf_area_id != 0 {
            my_size += ::protobuf::rt::value_size(3, self.ospf_area_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.pseudonode != false {
            my_size += 2;
        }
        if !self.igp_router_id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.igp_router_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.asn != 0 {
            os.write_uint32(1, self.asn)?;
        }
        if self.bgp_ls_id != 0 {
            os.write_uint32(2, self.bgp_ls_id)?;
        }
        if self.ospf_area_id != 0 {
            os.write_uint32(3, self.ospf_area_id)?;
        }
        if self.pseudonode != false {
            os.write_bool(4, self.pseudonode)?;
        }
        if !self.igp_router_id.is_empty() {
            os.write_string(5, &self.igp_router_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LsNodeDescriptor {
        LsNodeDescriptor::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "asn",
                    |m: &LsNodeDescriptor| { &m.asn },
                    |m: &mut LsNodeDescriptor| { &mut m.asn },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "bgp_ls_id",
                    |m: &LsNodeDescriptor| { &m.bgp_ls_id },
                    |m: &mut LsNodeDescriptor| { &mut m.bgp_ls_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ospf_area_id",
                    |m: &LsNodeDescriptor| { &m.ospf_area_id },
                    |m: &mut LsNodeDescriptor| { &mut m.ospf_area_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "pseudonode",
                    |m: &LsNodeDescriptor| { &m.pseudonode },
                    |m: &mut LsNodeDescriptor| { &mut m.pseudonode },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "igp_router_id",
                    |m: &LsNodeDescriptor| { &m.igp_router_id },
                    |m: &mut LsNodeDescriptor| { &mut m.igp_router_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LsNodeDescriptor>(
                    "LsNodeDescriptor",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LsNodeDescriptor {
        static mut instance: ::protobuf::lazy::Lazy<LsNodeDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LsNodeDescriptor,
        };
        unsafe {
            instance.get(LsNodeDescriptor::new)
        }
    }
}

impl ::protobuf::Clear for LsNodeDescriptor {
    fn clear(&mut self) {
        self.asn = 0;
        self.bgp_ls_id = 0;
        self.ospf_area_id = 0;
        self.pseudonode = false;
        self.igp_router_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LsNodeDescriptor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LsNodeDescriptor {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LsLinkDescriptor {
    // message fields
    pub link_local_id: u32,
    pub link_remote_id: u32,
    pub interface_addr_ipv4: ::std::string::String,
    pub neighbor_addr_ipv4: ::std::string::String,
    pub interface_addr_ipv6: ::std::string::String,
    pub neighbor_addr_ipv6: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LsLinkDescriptor {
    fn default() -> &'a LsLinkDescriptor {
        <LsLinkDescriptor as ::protobuf::Message>::default_instance()
    }
}

impl LsLinkDescriptor {
    pub fn new() -> LsLinkDescriptor {
        ::std::default::Default::default()
    }

    // uint32 link_local_id = 1;


    pub fn get_link_local_id(&self) -> u32 {
        self.link_local_id
    }
    pub fn clear_link_local_id(&mut self) {
        self.link_local_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_link_local_id(&mut self, v: u32) {
        self.link_local_id = v;
    }

    // uint32 link_remote_id = 2;


    pub fn get_link_remote_id(&self) -> u32 {
        self.link_remote_id
    }
    pub fn clear_link_remote_id(&mut self) {
        self.link_remote_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_link_remote_id(&mut self, v: u32) {
        self.link_remote_id = v;
    }

    // string interface_addr_ipv4 = 3;


    pub fn get_interface_addr_ipv4(&self) -> &str {
        &self.interface_addr_ipv4
    }
    pub fn clear_interface_addr_ipv4(&mut self) {
        self.interface_addr_ipv4.clear();
    }

    // Param is passed by value, moved
    pub fn set_interface_addr_ipv4(&mut self, v: ::std::string::String) {
        self.interface_addr_ipv4 = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_interface_addr_ipv4(&mut self) -> &mut ::std::string::String {
        &mut self.interface_addr_ipv4
    }

    // Take field
    pub fn take_interface_addr_ipv4(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.interface_addr_ipv4, ::std::string::String::new())
    }

    // string neighbor_addr_ipv4 = 4;


    pub fn get_neighbor_addr_ipv4(&self) -> &str {
        &self.neighbor_addr_ipv4
    }
    pub fn clear_neighbor_addr_ipv4(&mut self) {
        self.neighbor_addr_ipv4.clear();
    }

    // Param is passed by value, moved
    pub fn set_neighbor_addr_ipv4(&mut self, v: ::std::string::String) {
        self.neighbor_addr_ipv4 = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_neighbor_addr_ipv4(&mut self) -> &mut ::std::string::String {
        &mut self.neighbor_addr_ipv4
    }

    // Take field
    pub fn take_neighbor_addr_ipv4(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.neighbor_addr_ipv4, ::std::string::String::new())
    }

    // string interface_addr_ipv6 = 5;


    pub fn get_interface_addr_ipv6(&self) -> &str {
        &self.interface_addr_ipv6
    }
    pub fn clear_interface_addr_ipv6(&mut self) {
        self.interface_addr_ipv6.clear();
    }

    // Param is passed by value, moved
    pub fn set_interface_addr_ipv6(&mut self, v: ::std::string::String) {
        self.interface_addr_ipv6 = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_interface_addr_ipv6(&mut self) -> &mut ::std::string::String {
        &mut self.interface_addr_ipv6
    }

    // Take field
    pub fn take_interface_addr_ipv6(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.interface_addr_ipv6, ::std::string::String::new())
    }

    // string neighbor_addr_ipv6 = 6;


    pub fn get_neighbor_addr_ipv6(&self) -> &str {
        &self.neighbor_addr_ipv6
    }
    pub fn clear_neighbor_addr_ipv6(&mut self) {
        self.neighbor_addr_ipv6.clear();
    }

    // Param is passed by value, moved
    pub fn set_neighbor_addr_ipv6(&mut self, v: ::std::string::String) {
        self.neighbor_addr_ipv6 = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_neighbor_addr_ipv6(&mut self) -> &mut ::std::string::String {
        &mut self.neighbor_addr_ipv6
    }

    // Take field
    pub fn take_neighbor_addr_ipv6(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.neighbor_addr_ipv6, ::std::string::String::new())
    }
}

impl ::protobuf::Message for LsLinkDescriptor {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.link_local_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.link_remote_id = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.interface_addr_ipv4)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.neighbor_addr_ipv4)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.interface_addr_ipv6)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.neighbor_addr_ipv6)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.link_local_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.link_local_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.link_remote_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.link_remote_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.interface_addr_ipv4.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.interface_addr_ipv4);
        }
        if !self.neighbor_addr_ipv4.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.neighbor_addr_ipv4);
        }
        if !self.interface_addr_ipv6.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.interface_addr_ipv6);
        }
        if !self.neighbor_addr_ipv6.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.neighbor_addr_ipv6);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.link_local_id != 0 {
            os.write_uint32(1, self.link_local_id)?;
        }
        if self.link_remote_id != 0 {
            os.write_uint32(2, self.link_remote_id)?;
        }
        if !self.interface_addr_ipv4.is_empty() {
            os.write_string(3, &self.interface_addr_ipv4)?;
        }
        if !self.neighbor_addr_ipv4.is_empty() {
            os.write_string(4, &self.neighbor_addr_ipv4)?;
        }
        if !self.interface_addr_ipv6.is_empty() {
            os.write_string(5, &self.interface_addr_ipv6)?;
        }
        if !self.neighbor_addr_ipv6.is_empty() {
            os.write_string(6, &self.neighbor_addr_ipv6)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LsLinkDescriptor {
        LsLinkDescriptor::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "link_local_id",
                    |m: &LsLinkDescriptor| { &m.link_local_id },
                    |m: &mut LsLinkDescriptor| { &mut m.link_local_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "link_remote_id",
                    |m: &LsLinkDescriptor| { &m.link_remote_id },
                    |m: &mut LsLinkDescriptor| { &mut m.link_remote_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "interface_addr_ipv4",
                    |m: &LsLinkDescriptor| { &m.interface_addr_ipv4 },
                    |m: &mut LsLinkDescriptor| { &mut m.interface_addr_ipv4 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "neighbor_addr_ipv4",
                    |m: &LsLinkDescriptor| { &m.neighbor_addr_ipv4 },
                    |m: &mut LsLinkDescriptor| { &mut m.neighbor_addr_ipv4 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "interface_addr_ipv6",
                    |m: &LsLinkDescriptor| { &m.interface_addr_ipv6 },
                    |m: &mut LsLinkDescriptor| { &mut m.interface_addr_ipv6 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "neighbor_addr_ipv6",
                    |m: &LsLinkDescriptor| { &m.neighbor_addr_ipv6 },
                    |m: &mut LsLinkDescriptor| { &mut m.neighbor_addr_ipv6 },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LsLinkDescriptor>(
                    "LsLinkDescriptor",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LsLinkDescriptor {
        static mut instance: ::protobuf::lazy::Lazy<LsLinkDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LsLinkDescriptor,
        };
        unsafe {
            instance.get(LsLinkDescriptor::new)
        }
    }
}

impl ::protobuf::Clear for LsLinkDescriptor {
    fn clear(&mut self) {
        self.link_local_id = 0;
        self.link_remote_id = 0;
        self.interface_addr_ipv4.clear();
        self.neighbor_addr_ipv4.clear();
        self.interface_addr_ipv6.clear();
        self.neighbor_addr_ipv6.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LsLinkDescriptor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LsLinkDescriptor {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LsPrefixDescriptor {
    // message fields
    pub ip_reachability: ::protobuf::RepeatedField<::std::string::String>,
    pub ospf_route_type: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LsPrefixDescriptor {
    fn default() -> &'a LsPrefixDescriptor {
        <LsPrefixDescriptor as ::protobuf::Message>::default_instance()
    }
}

impl LsPrefixDescriptor {
    pub fn new() -> LsPrefixDescriptor {
        ::std::default::Default::default()
    }

    // repeated string ip_reachability = 1;


    pub fn get_ip_reachability(&self) -> &[::std::string::String] {
        &self.ip_reachability
    }
    pub fn clear_ip_reachability(&mut self) {
        self.ip_reachability.clear();
    }

    // Param is passed by value, moved
    pub fn set_ip_reachability(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ip_reachability = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ip_reachability(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ip_reachability
    }

    // Take field
    pub fn take_ip_reachability(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ip_reachability, ::protobuf::RepeatedField::new())
    }

    // string ospf_route_type = 2;


    pub fn get_ospf_route_type(&self) -> &str {
        &self.ospf_route_type
    }
    pub fn clear_ospf_route_type(&mut self) {
        self.ospf_route_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_ospf_route_type(&mut self, v: ::std::string::String) {
        self.ospf_route_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ospf_route_type(&mut self) -> &mut ::std::string::String {
        &mut self.ospf_route_type
    }

    // Take field
    pub fn take_ospf_route_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ospf_route_type, ::std::string::String::new())
    }
}

impl ::protobuf::Message for LsPrefixDescriptor {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ip_reachability)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ospf_route_type)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.ip_reachability {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if !self.ospf_route_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.ospf_route_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.ip_reachability {
            os.write_string(1, &v)?;
        };
        if !self.ospf_route_type.is_empty() {
            os.write_string(2, &self.ospf_route_type)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LsPrefixDescriptor {
        LsPrefixDescriptor::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ip_reachability",
                    |m: &LsPrefixDescriptor| { &m.ip_reachability },
                    |m: &mut LsPrefixDescriptor| { &mut m.ip_reachability },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ospf_route_type",
                    |m: &LsPrefixDescriptor| { &m.ospf_route_type },
                    |m: &mut LsPrefixDescriptor| { &mut m.ospf_route_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LsPrefixDescriptor>(
                    "LsPrefixDescriptor",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LsPrefixDescriptor {
        static mut instance: ::protobuf::lazy::Lazy<LsPrefixDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LsPrefixDescriptor,
        };
        unsafe {
            instance.get(LsPrefixDescriptor::new)
        }
    }
}

impl ::protobuf::Clear for LsPrefixDescriptor {
    fn clear(&mut self) {
        self.ip_reachability.clear();
        self.ospf_route_type.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LsPrefixDescriptor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LsPrefixDescriptor {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LsNodeNLRI {
    // message fields
    pub local_node: ::protobuf::SingularPtrField<LsNodeDescriptor>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LsNodeNLRI {
    fn default() -> &'a LsNodeNLRI {
        <LsNodeNLRI as ::protobuf::Message>::default_instance()
    }
}

impl LsNodeNLRI {
    pub fn new() -> LsNodeNLRI {
        ::std::default::Default::default()
    }

    // .gobgpapi.LsNodeDescriptor local_node = 1;


    pub fn get_local_node(&self) -> &LsNodeDescriptor {
        self.local_node.as_ref().unwrap_or_else(|| LsNodeDescriptor::default_instance())
    }
    pub fn clear_local_node(&mut self) {
        self.local_node.clear();
    }

    pub fn has_local_node(&self) -> bool {
        self.local_node.is_some()
    }

    // Param is passed by value, moved
    pub fn set_local_node(&mut self, v: LsNodeDescriptor) {
        self.local_node = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_local_node(&mut self) -> &mut LsNodeDescriptor {
        if self.local_node.is_none() {
            self.local_node.set_default();
        }
        self.local_node.as_mut().unwrap()
    }

    // Take field
    pub fn take_local_node(&mut self) -> LsNodeDescriptor {
        self.local_node.take().unwrap_or_else(|| LsNodeDescriptor::new())
    }
}

impl ::protobuf::Message for LsNodeNLRI {
    fn is_initialized(&self) -> bool {
        for v in &self.local_node {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.local_node)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.local_node.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.local_node.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LsNodeNLRI {
        LsNodeNLRI::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LsNodeDescriptor>>(
                    "local_node",
                    |m: &LsNodeNLRI| { &m.local_node },
                    |m: &mut LsNodeNLRI| { &mut m.local_node },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LsNodeNLRI>(
                    "LsNodeNLRI",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LsNodeNLRI {
        static mut instance: ::protobuf::lazy::Lazy<LsNodeNLRI> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LsNodeNLRI,
        };
        unsafe {
            instance.get(LsNodeNLRI::new)
        }
    }
}

impl ::protobuf::Clear for LsNodeNLRI {
    fn clear(&mut self) {
        self.local_node.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LsNodeNLRI {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LsNodeNLRI {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LsLinkNLRI {
    // message fields
    pub local_node: ::protobuf::SingularPtrField<LsNodeDescriptor>,
    pub remote_node: ::protobuf::SingularPtrField<LsNodeDescriptor>,
    pub link_descriptor: ::protobuf::SingularPtrField<LsLinkDescriptor>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LsLinkNLRI {
    fn default() -> &'a LsLinkNLRI {
        <LsLinkNLRI as ::protobuf::Message>::default_instance()
    }
}

impl LsLinkNLRI {
    pub fn new() -> LsLinkNLRI {
        ::std::default::Default::default()
    }

    // .gobgpapi.LsNodeDescriptor local_node = 1;


    pub fn get_local_node(&self) -> &LsNodeDescriptor {
        self.local_node.as_ref().unwrap_or_else(|| LsNodeDescriptor::default_instance())
    }
    pub fn clear_local_node(&mut self) {
        self.local_node.clear();
    }

    pub fn has_local_node(&self) -> bool {
        self.local_node.is_some()
    }

    // Param is passed by value, moved
    pub fn set_local_node(&mut self, v: LsNodeDescriptor) {
        self.local_node = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_local_node(&mut self) -> &mut LsNodeDescriptor {
        if self.local_node.is_none() {
            self.local_node.set_default();
        }
        self.local_node.as_mut().unwrap()
    }

    // Take field
    pub fn take_local_node(&mut self) -> LsNodeDescriptor {
        self.local_node.take().unwrap_or_else(|| LsNodeDescriptor::new())
    }

    // .gobgpapi.LsNodeDescriptor remote_node = 2;


    pub fn get_remote_node(&self) -> &LsNodeDescriptor {
        self.remote_node.as_ref().unwrap_or_else(|| LsNodeDescriptor::default_instance())
    }
    pub fn clear_remote_node(&mut self) {
        self.remote_node.clear();
    }

    pub fn has_remote_node(&self) -> bool {
        self.remote_node.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remote_node(&mut self, v: LsNodeDescriptor) {
        self.remote_node = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remote_node(&mut self) -> &mut LsNodeDescriptor {
        if self.remote_node.is_none() {
            self.remote_node.set_default();
        }
        self.remote_node.as_mut().unwrap()
    }

    // Take field
    pub fn take_remote_node(&mut self) -> LsNodeDescriptor {
        self.remote_node.take().unwrap_or_else(|| LsNodeDescriptor::new())
    }

    // .gobgpapi.LsLinkDescriptor link_descriptor = 3;


    pub fn get_link_descriptor(&self) -> &LsLinkDescriptor {
        self.link_descriptor.as_ref().unwrap_or_else(|| LsLinkDescriptor::default_instance())
    }
    pub fn clear_link_descriptor(&mut self) {
        self.link_descriptor.clear();
    }

    pub fn has_link_descriptor(&self) -> bool {
        self.link_descriptor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_link_descriptor(&mut self, v: LsLinkDescriptor) {
        self.link_descriptor = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_link_descriptor(&mut self) -> &mut LsLinkDescriptor {
        if self.link_descriptor.is_none() {
            self.link_descriptor.set_default();
        }
        self.link_descriptor.as_mut().unwrap()
    }

    // Take field
    pub fn take_link_descriptor(&mut self) -> LsLinkDescriptor {
        self.link_descriptor.take().unwrap_or_else(|| LsLinkDescriptor::new())
    }
}

impl ::protobuf::Message for LsLinkNLRI {
    fn is_initialized(&self) -> bool {
        for v in &self.local_node {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.remote_node {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.link_descriptor {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.local_node)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.remote_node)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.link_descriptor)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.local_node.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.remote_node.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.link_descriptor.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.local_node.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.remote_node.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.link_descriptor.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LsLinkNLRI {
        LsLinkNLRI::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LsNodeDescriptor>>(
                    "local_node",
                    |m: &LsLinkNLRI| { &m.local_node },
                    |m: &mut LsLinkNLRI| { &mut m.local_node },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LsNodeDescriptor>>(
                    "remote_node",
                    |m: &LsLinkNLRI| { &m.remote_node },
                    |m: &mut LsLinkNLRI| { &mut m.remote_node },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LsLinkDescriptor>>(
                    "link_descriptor",
                    |m: &LsLinkNLRI| { &m.link_descriptor },
                    |m: &mut LsLinkNLRI| { &mut m.link_descriptor },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LsLinkNLRI>(
                    "LsLinkNLRI",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LsLinkNLRI {
        static mut instance: ::protobuf::lazy::Lazy<LsLinkNLRI> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LsLinkNLRI,
        };
        unsafe {
            instance.get(LsLinkNLRI::new)
        }
    }
}

impl ::protobuf::Clear for LsLinkNLRI {
    fn clear(&mut self) {
        self.local_node.clear();
        self.remote_node.clear();
        self.link_descriptor.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LsLinkNLRI {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LsLinkNLRI {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LsPrefixV4NLRI {
    // message fields
    pub local_node: ::protobuf::SingularPtrField<LsNodeDescriptor>,
    pub prefix_descriptor: ::protobuf::SingularPtrField<LsPrefixDescriptor>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LsPrefixV4NLRI {
    fn default() -> &'a LsPrefixV4NLRI {
        <LsPrefixV4NLRI as ::protobuf::Message>::default_instance()
    }
}

impl LsPrefixV4NLRI {
    pub fn new() -> LsPrefixV4NLRI {
        ::std::default::Default::default()
    }

    // .gobgpapi.LsNodeDescriptor local_node = 1;


    pub fn get_local_node(&self) -> &LsNodeDescriptor {
        self.local_node.as_ref().unwrap_or_else(|| LsNodeDescriptor::default_instance())
    }
    pub fn clear_local_node(&mut self) {
        self.local_node.clear();
    }

    pub fn has_local_node(&self) -> bool {
        self.local_node.is_some()
    }

    // Param is passed by value, moved
    pub fn set_local_node(&mut self, v: LsNodeDescriptor) {
        self.local_node = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_local_node(&mut self) -> &mut LsNodeDescriptor {
        if self.local_node.is_none() {
            self.local_node.set_default();
        }
        self.local_node.as_mut().unwrap()
    }

    // Take field
    pub fn take_local_node(&mut self) -> LsNodeDescriptor {
        self.local_node.take().unwrap_or_else(|| LsNodeDescriptor::new())
    }

    // .gobgpapi.LsPrefixDescriptor prefix_descriptor = 2;


    pub fn get_prefix_descriptor(&self) -> &LsPrefixDescriptor {
        self.prefix_descriptor.as_ref().unwrap_or_else(|| LsPrefixDescriptor::default_instance())
    }
    pub fn clear_prefix_descriptor(&mut self) {
        self.prefix_descriptor.clear();
    }

    pub fn has_prefix_descriptor(&self) -> bool {
        self.prefix_descriptor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prefix_descriptor(&mut self, v: LsPrefixDescriptor) {
        self.prefix_descriptor = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prefix_descriptor(&mut self) -> &mut LsPrefixDescriptor {
        if self.prefix_descriptor.is_none() {
            self.prefix_descriptor.set_default();
        }
        self.prefix_descriptor.as_mut().unwrap()
    }

    // Take field
    pub fn take_prefix_descriptor(&mut self) -> LsPrefixDescriptor {
        self.prefix_descriptor.take().unwrap_or_else(|| LsPrefixDescriptor::new())
    }
}

impl ::protobuf::Message for LsPrefixV4NLRI {
    fn is_initialized(&self) -> bool {
        for v in &self.local_node {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.prefix_descriptor {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.local_node)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.prefix_descriptor)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.local_node.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.prefix_descriptor.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.local_node.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.prefix_descriptor.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LsPrefixV4NLRI {
        LsPrefixV4NLRI::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LsNodeDescriptor>>(
                    "local_node",
                    |m: &LsPrefixV4NLRI| { &m.local_node },
                    |m: &mut LsPrefixV4NLRI| { &mut m.local_node },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LsPrefixDescriptor>>(
                    "prefix_descriptor",
                    |m: &LsPrefixV4NLRI| { &m.prefix_descriptor },
                    |m: &mut LsPrefixV4NLRI| { &mut m.prefix_descriptor },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LsPrefixV4NLRI>(
                    "LsPrefixV4NLRI",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LsPrefixV4NLRI {
        static mut instance: ::protobuf::lazy::Lazy<LsPrefixV4NLRI> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LsPrefixV4NLRI,
        };
        unsafe {
            instance.get(LsPrefixV4NLRI::new)
        }
    }
}

impl ::protobuf::Clear for LsPrefixV4NLRI {
    fn clear(&mut self) {
        self.local_node.clear();
        self.prefix_descriptor.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LsPrefixV4NLRI {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LsPrefixV4NLRI {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LsPrefixV6NLRI {
    // message fields
    pub local_node: ::protobuf::SingularPtrField<LsNodeDescriptor>,
    pub prefix_descriptor: ::protobuf::SingularPtrField<LsPrefixDescriptor>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LsPrefixV6NLRI {
    fn default() -> &'a LsPrefixV6NLRI {
        <LsPrefixV6NLRI as ::protobuf::Message>::default_instance()
    }
}

impl LsPrefixV6NLRI {
    pub fn new() -> LsPrefixV6NLRI {
        ::std::default::Default::default()
    }

    // .gobgpapi.LsNodeDescriptor local_node = 1;


    pub fn get_local_node(&self) -> &LsNodeDescriptor {
        self.local_node.as_ref().unwrap_or_else(|| LsNodeDescriptor::default_instance())
    }
    pub fn clear_local_node(&mut self) {
        self.local_node.clear();
    }

    pub fn has_local_node(&self) -> bool {
        self.local_node.is_some()
    }

    // Param is passed by value, moved
    pub fn set_local_node(&mut self, v: LsNodeDescriptor) {
        self.local_node = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_local_node(&mut self) -> &mut LsNodeDescriptor {
        if self.local_node.is_none() {
            self.local_node.set_default();
        }
        self.local_node.as_mut().unwrap()
    }

    // Take field
    pub fn take_local_node(&mut self) -> LsNodeDescriptor {
        self.local_node.take().unwrap_or_else(|| LsNodeDescriptor::new())
    }

    // .gobgpapi.LsPrefixDescriptor prefix_descriptor = 2;


    pub fn get_prefix_descriptor(&self) -> &LsPrefixDescriptor {
        self.prefix_descriptor.as_ref().unwrap_or_else(|| LsPrefixDescriptor::default_instance())
    }
    pub fn clear_prefix_descriptor(&mut self) {
        self.prefix_descriptor.clear();
    }

    pub fn has_prefix_descriptor(&self) -> bool {
        self.prefix_descriptor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prefix_descriptor(&mut self, v: LsPrefixDescriptor) {
        self.prefix_descriptor = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prefix_descriptor(&mut self) -> &mut LsPrefixDescriptor {
        if self.prefix_descriptor.is_none() {
            self.prefix_descriptor.set_default();
        }
        self.prefix_descriptor.as_mut().unwrap()
    }

    // Take field
    pub fn take_prefix_descriptor(&mut self) -> LsPrefixDescriptor {
        self.prefix_descriptor.take().unwrap_or_else(|| LsPrefixDescriptor::new())
    }
}

impl ::protobuf::Message for LsPrefixV6NLRI {
    fn is_initialized(&self) -> bool {
        for v in &self.local_node {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.prefix_descriptor {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.local_node)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.prefix_descriptor)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.local_node.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.prefix_descriptor.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.local_node.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.prefix_descriptor.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LsPrefixV6NLRI {
        LsPrefixV6NLRI::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LsNodeDescriptor>>(
                    "local_node",
                    |m: &LsPrefixV6NLRI| { &m.local_node },
                    |m: &mut LsPrefixV6NLRI| { &mut m.local_node },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LsPrefixDescriptor>>(
                    "prefix_descriptor",
                    |m: &LsPrefixV6NLRI| { &m.prefix_descriptor },
                    |m: &mut LsPrefixV6NLRI| { &mut m.prefix_descriptor },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LsPrefixV6NLRI>(
                    "LsPrefixV6NLRI",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LsPrefixV6NLRI {
        static mut instance: ::protobuf::lazy::Lazy<LsPrefixV6NLRI> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LsPrefixV6NLRI,
        };
        unsafe {
            instance.get(LsPrefixV6NLRI::new)
        }
    }
}

impl ::protobuf::Clear for LsPrefixV6NLRI {
    fn clear(&mut self) {
        self.local_node.clear();
        self.prefix_descriptor.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LsPrefixV6NLRI {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LsPrefixV6NLRI {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LsAddrPrefix {
    // message fields
    pub field_type: LsNLRIType,
    pub nlri: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LsAddrPrefix {
    fn default() -> &'a LsAddrPrefix {
        <LsAddrPrefix as ::protobuf::Message>::default_instance()
    }
}

impl LsAddrPrefix {
    pub fn new() -> LsAddrPrefix {
        ::std::default::Default::default()
    }

    // .gobgpapi.LsNLRIType type = 1;


    pub fn get_field_type(&self) -> LsNLRIType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = LsNLRIType::LS_NLRI_UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: LsNLRIType) {
        self.field_type = v;
    }

    // .google.protobuf.Any nlri = 2;


    pub fn get_nlri(&self) -> &::protobuf::well_known_types::Any {
        self.nlri.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Any::default_instance())
    }
    pub fn clear_nlri(&mut self) {
        self.nlri.clear();
    }

    pub fn has_nlri(&self) -> bool {
        self.nlri.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nlri(&mut self, v: ::protobuf::well_known_types::Any) {
        self.nlri = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nlri(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.nlri.is_none() {
            self.nlri.set_default();
        }
        self.nlri.as_mut().unwrap()
    }

    // Take field
    pub fn take_nlri(&mut self) -> ::protobuf::well_known_types::Any {
        self.nlri.take().unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }
}

impl ::protobuf::Message for LsAddrPrefix {
    fn is_initialized(&self) -> bool {
        for v in &self.nlri {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.nlri)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != LsNLRIType::LS_NLRI_UNKNOWN {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if let Some(ref v) = self.nlri.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != LsNLRIType::LS_NLRI_UNKNOWN {
            os.write_enum(1, self.field_type.value())?;
        }
        if let Some(ref v) = self.nlri.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LsAddrPrefix {
        LsAddrPrefix::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<LsNLRIType>>(
                    "type",
                    |m: &LsAddrPrefix| { &m.field_type },
                    |m: &mut LsAddrPrefix| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                    "nlri",
                    |m: &LsAddrPrefix| { &m.nlri },
                    |m: &mut LsAddrPrefix| { &mut m.nlri },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LsAddrPrefix>(
                    "LsAddrPrefix",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LsAddrPrefix {
        static mut instance: ::protobuf::lazy::Lazy<LsAddrPrefix> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LsAddrPrefix,
        };
        unsafe {
            instance.get(LsAddrPrefix::new)
        }
    }
}

impl ::protobuf::Clear for LsAddrPrefix {
    fn clear(&mut self) {
        self.field_type = LsNLRIType::LS_NLRI_UNKNOWN;
        self.nlri.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LsAddrPrefix {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LsAddrPrefix {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MpReachNLRIAttribute {
    // message fields
    pub family: ::protobuf::SingularPtrField<super::gobgp::Family>,
    pub next_hops: ::protobuf::RepeatedField<::std::string::String>,
    pub nlris: ::protobuf::RepeatedField<::protobuf::well_known_types::Any>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MpReachNLRIAttribute {
    fn default() -> &'a MpReachNLRIAttribute {
        <MpReachNLRIAttribute as ::protobuf::Message>::default_instance()
    }
}

impl MpReachNLRIAttribute {
    pub fn new() -> MpReachNLRIAttribute {
        ::std::default::Default::default()
    }

    // .gobgpapi.Family family = 1;


    pub fn get_family(&self) -> &super::gobgp::Family {
        self.family.as_ref().unwrap_or_else(|| super::gobgp::Family::default_instance())
    }
    pub fn clear_family(&mut self) {
        self.family.clear();
    }

    pub fn has_family(&self) -> bool {
        self.family.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family(&mut self, v: super::gobgp::Family) {
        self.family = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_family(&mut self) -> &mut super::gobgp::Family {
        if self.family.is_none() {
            self.family.set_default();
        }
        self.family.as_mut().unwrap()
    }

    // Take field
    pub fn take_family(&mut self) -> super::gobgp::Family {
        self.family.take().unwrap_or_else(|| super::gobgp::Family::new())
    }

    // repeated string next_hops = 2;


    pub fn get_next_hops(&self) -> &[::std::string::String] {
        &self.next_hops
    }
    pub fn clear_next_hops(&mut self) {
        self.next_hops.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_hops(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.next_hops = v;
    }

    // Mutable pointer to the field.
    pub fn mut_next_hops(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.next_hops
    }

    // Take field
    pub fn take_next_hops(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.next_hops, ::protobuf::RepeatedField::new())
    }

    // repeated .google.protobuf.Any nlris = 3;


    pub fn get_nlris(&self) -> &[::protobuf::well_known_types::Any] {
        &self.nlris
    }
    pub fn clear_nlris(&mut self) {
        self.nlris.clear();
    }

    // Param is passed by value, moved
    pub fn set_nlris(&mut self, v: ::protobuf::RepeatedField<::protobuf::well_known_types::Any>) {
        self.nlris = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nlris(&mut self) -> &mut ::protobuf::RepeatedField<::protobuf::well_known_types::Any> {
        &mut self.nlris
    }

    // Take field
    pub fn take_nlris(&mut self) -> ::protobuf::RepeatedField<::protobuf::well_known_types::Any> {
        ::std::mem::replace(&mut self.nlris, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MpReachNLRIAttribute {
    fn is_initialized(&self) -> bool {
        for v in &self.family {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.nlris {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.family)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.next_hops)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.nlris)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.family.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.next_hops {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.nlris {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.family.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.next_hops {
            os.write_string(2, &v)?;
        };
        for v in &self.nlris {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MpReachNLRIAttribute {
        MpReachNLRIAttribute::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::gobgp::Family>>(
                    "family",
                    |m: &MpReachNLRIAttribute| { &m.family },
                    |m: &mut MpReachNLRIAttribute| { &mut m.family },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "next_hops",
                    |m: &MpReachNLRIAttribute| { &m.next_hops },
                    |m: &mut MpReachNLRIAttribute| { &mut m.next_hops },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                    "nlris",
                    |m: &MpReachNLRIAttribute| { &m.nlris },
                    |m: &mut MpReachNLRIAttribute| { &mut m.nlris },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MpReachNLRIAttribute>(
                    "MpReachNLRIAttribute",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MpReachNLRIAttribute {
        static mut instance: ::protobuf::lazy::Lazy<MpReachNLRIAttribute> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MpReachNLRIAttribute,
        };
        unsafe {
            instance.get(MpReachNLRIAttribute::new)
        }
    }
}

impl ::protobuf::Clear for MpReachNLRIAttribute {
    fn clear(&mut self) {
        self.family.clear();
        self.next_hops.clear();
        self.nlris.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MpReachNLRIAttribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MpReachNLRIAttribute {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MpUnreachNLRIAttribute {
    // message fields
    pub family: ::protobuf::SingularPtrField<super::gobgp::Family>,
    pub nlris: ::protobuf::RepeatedField<::protobuf::well_known_types::Any>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MpUnreachNLRIAttribute {
    fn default() -> &'a MpUnreachNLRIAttribute {
        <MpUnreachNLRIAttribute as ::protobuf::Message>::default_instance()
    }
}

impl MpUnreachNLRIAttribute {
    pub fn new() -> MpUnreachNLRIAttribute {
        ::std::default::Default::default()
    }

    // .gobgpapi.Family family = 1;


    pub fn get_family(&self) -> &super::gobgp::Family {
        self.family.as_ref().unwrap_or_else(|| super::gobgp::Family::default_instance())
    }
    pub fn clear_family(&mut self) {
        self.family.clear();
    }

    pub fn has_family(&self) -> bool {
        self.family.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family(&mut self, v: super::gobgp::Family) {
        self.family = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_family(&mut self) -> &mut super::gobgp::Family {
        if self.family.is_none() {
            self.family.set_default();
        }
        self.family.as_mut().unwrap()
    }

    // Take field
    pub fn take_family(&mut self) -> super::gobgp::Family {
        self.family.take().unwrap_or_else(|| super::gobgp::Family::new())
    }

    // repeated .google.protobuf.Any nlris = 3;


    pub fn get_nlris(&self) -> &[::protobuf::well_known_types::Any] {
        &self.nlris
    }
    pub fn clear_nlris(&mut self) {
        self.nlris.clear();
    }

    // Param is passed by value, moved
    pub fn set_nlris(&mut self, v: ::protobuf::RepeatedField<::protobuf::well_known_types::Any>) {
        self.nlris = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nlris(&mut self) -> &mut ::protobuf::RepeatedField<::protobuf::well_known_types::Any> {
        &mut self.nlris
    }

    // Take field
    pub fn take_nlris(&mut self) -> ::protobuf::RepeatedField<::protobuf::well_known_types::Any> {
        ::std::mem::replace(&mut self.nlris, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MpUnreachNLRIAttribute {
    fn is_initialized(&self) -> bool {
        for v in &self.family {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.nlris {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.family)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.nlris)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.family.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.nlris {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.family.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.nlris {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MpUnreachNLRIAttribute {
        MpUnreachNLRIAttribute::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::gobgp::Family>>(
                    "family",
                    |m: &MpUnreachNLRIAttribute| { &m.family },
                    |m: &mut MpUnreachNLRIAttribute| { &mut m.family },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                    "nlris",
                    |m: &MpUnreachNLRIAttribute| { &m.nlris },
                    |m: &mut MpUnreachNLRIAttribute| { &mut m.nlris },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MpUnreachNLRIAttribute>(
                    "MpUnreachNLRIAttribute",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MpUnreachNLRIAttribute {
        static mut instance: ::protobuf::lazy::Lazy<MpUnreachNLRIAttribute> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MpUnreachNLRIAttribute,
        };
        unsafe {
            instance.get(MpUnreachNLRIAttribute::new)
        }
    }
}

impl ::protobuf::Clear for MpUnreachNLRIAttribute {
    fn clear(&mut self) {
        self.family.clear();
        self.nlris.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MpUnreachNLRIAttribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MpUnreachNLRIAttribute {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TwoOctetAsSpecificExtended {
    // message fields
    pub is_transitive: bool,
    pub sub_type: u32,
    pub field_as: u32,
    pub local_admin: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TwoOctetAsSpecificExtended {
    fn default() -> &'a TwoOctetAsSpecificExtended {
        <TwoOctetAsSpecificExtended as ::protobuf::Message>::default_instance()
    }
}

impl TwoOctetAsSpecificExtended {
    pub fn new() -> TwoOctetAsSpecificExtended {
        ::std::default::Default::default()
    }

    // bool is_transitive = 1;


    pub fn get_is_transitive(&self) -> bool {
        self.is_transitive
    }
    pub fn clear_is_transitive(&mut self) {
        self.is_transitive = false;
    }

    // Param is passed by value, moved
    pub fn set_is_transitive(&mut self, v: bool) {
        self.is_transitive = v;
    }

    // uint32 sub_type = 2;


    pub fn get_sub_type(&self) -> u32 {
        self.sub_type
    }
    pub fn clear_sub_type(&mut self) {
        self.sub_type = 0;
    }

    // Param is passed by value, moved
    pub fn set_sub_type(&mut self, v: u32) {
        self.sub_type = v;
    }

    // uint32 as = 3;


    pub fn get_field_as(&self) -> u32 {
        self.field_as
    }
    pub fn clear_field_as(&mut self) {
        self.field_as = 0;
    }

    // Param is passed by value, moved
    pub fn set_field_as(&mut self, v: u32) {
        self.field_as = v;
    }

    // uint32 local_admin = 4;


    pub fn get_local_admin(&self) -> u32 {
        self.local_admin
    }
    pub fn clear_local_admin(&mut self) {
        self.local_admin = 0;
    }

    // Param is passed by value, moved
    pub fn set_local_admin(&mut self, v: u32) {
        self.local_admin = v;
    }
}

impl ::protobuf::Message for TwoOctetAsSpecificExtended {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_transitive = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.sub_type = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.field_as = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.local_admin = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.is_transitive != false {
            my_size += 2;
        }
        if self.sub_type != 0 {
            my_size += ::protobuf::rt::value_size(2, self.sub_type, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.field_as != 0 {
            my_size += ::protobuf::rt::value_size(3, self.field_as, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.local_admin != 0 {
            my_size += ::protobuf::rt::value_size(4, self.local_admin, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.is_transitive != false {
            os.write_bool(1, self.is_transitive)?;
        }
        if self.sub_type != 0 {
            os.write_uint32(2, self.sub_type)?;
        }
        if self.field_as != 0 {
            os.write_uint32(3, self.field_as)?;
        }
        if self.local_admin != 0 {
            os.write_uint32(4, self.local_admin)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TwoOctetAsSpecificExtended {
        TwoOctetAsSpecificExtended::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_transitive",
                    |m: &TwoOctetAsSpecificExtended| { &m.is_transitive },
                    |m: &mut TwoOctetAsSpecificExtended| { &mut m.is_transitive },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "sub_type",
                    |m: &TwoOctetAsSpecificExtended| { &m.sub_type },
                    |m: &mut TwoOctetAsSpecificExtended| { &mut m.sub_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "as",
                    |m: &TwoOctetAsSpecificExtended| { &m.field_as },
                    |m: &mut TwoOctetAsSpecificExtended| { &mut m.field_as },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "local_admin",
                    |m: &TwoOctetAsSpecificExtended| { &m.local_admin },
                    |m: &mut TwoOctetAsSpecificExtended| { &mut m.local_admin },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TwoOctetAsSpecificExtended>(
                    "TwoOctetAsSpecificExtended",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TwoOctetAsSpecificExtended {
        static mut instance: ::protobuf::lazy::Lazy<TwoOctetAsSpecificExtended> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TwoOctetAsSpecificExtended,
        };
        unsafe {
            instance.get(TwoOctetAsSpecificExtended::new)
        }
    }
}

impl ::protobuf::Clear for TwoOctetAsSpecificExtended {
    fn clear(&mut self) {
        self.is_transitive = false;
        self.sub_type = 0;
        self.field_as = 0;
        self.local_admin = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TwoOctetAsSpecificExtended {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TwoOctetAsSpecificExtended {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IPv4AddressSpecificExtended {
    // message fields
    pub is_transitive: bool,
    pub sub_type: u32,
    pub address: ::std::string::String,
    pub local_admin: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IPv4AddressSpecificExtended {
    fn default() -> &'a IPv4AddressSpecificExtended {
        <IPv4AddressSpecificExtended as ::protobuf::Message>::default_instance()
    }
}

impl IPv4AddressSpecificExtended {
    pub fn new() -> IPv4AddressSpecificExtended {
        ::std::default::Default::default()
    }

    // bool is_transitive = 1;


    pub fn get_is_transitive(&self) -> bool {
        self.is_transitive
    }
    pub fn clear_is_transitive(&mut self) {
        self.is_transitive = false;
    }

    // Param is passed by value, moved
    pub fn set_is_transitive(&mut self, v: bool) {
        self.is_transitive = v;
    }

    // uint32 sub_type = 2;


    pub fn get_sub_type(&self) -> u32 {
        self.sub_type
    }
    pub fn clear_sub_type(&mut self) {
        self.sub_type = 0;
    }

    // Param is passed by value, moved
    pub fn set_sub_type(&mut self, v: u32) {
        self.sub_type = v;
    }

    // string address = 3;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // uint32 local_admin = 4;


    pub fn get_local_admin(&self) -> u32 {
        self.local_admin
    }
    pub fn clear_local_admin(&mut self) {
        self.local_admin = 0;
    }

    // Param is passed by value, moved
    pub fn set_local_admin(&mut self, v: u32) {
        self.local_admin = v;
    }
}

impl ::protobuf::Message for IPv4AddressSpecificExtended {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_transitive = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.sub_type = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.local_admin = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.is_transitive != false {
            my_size += 2;
        }
        if self.sub_type != 0 {
            my_size += ::protobuf::rt::value_size(2, self.sub_type, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.address);
        }
        if self.local_admin != 0 {
            my_size += ::protobuf::rt::value_size(4, self.local_admin, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.is_transitive != false {
            os.write_bool(1, self.is_transitive)?;
        }
        if self.sub_type != 0 {
            os.write_uint32(2, self.sub_type)?;
        }
        if !self.address.is_empty() {
            os.write_string(3, &self.address)?;
        }
        if self.local_admin != 0 {
            os.write_uint32(4, self.local_admin)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IPv4AddressSpecificExtended {
        IPv4AddressSpecificExtended::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_transitive",
                    |m: &IPv4AddressSpecificExtended| { &m.is_transitive },
                    |m: &mut IPv4AddressSpecificExtended| { &mut m.is_transitive },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "sub_type",
                    |m: &IPv4AddressSpecificExtended| { &m.sub_type },
                    |m: &mut IPv4AddressSpecificExtended| { &mut m.sub_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "address",
                    |m: &IPv4AddressSpecificExtended| { &m.address },
                    |m: &mut IPv4AddressSpecificExtended| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "local_admin",
                    |m: &IPv4AddressSpecificExtended| { &m.local_admin },
                    |m: &mut IPv4AddressSpecificExtended| { &mut m.local_admin },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<IPv4AddressSpecificExtended>(
                    "IPv4AddressSpecificExtended",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static IPv4AddressSpecificExtended {
        static mut instance: ::protobuf::lazy::Lazy<IPv4AddressSpecificExtended> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IPv4AddressSpecificExtended,
        };
        unsafe {
            instance.get(IPv4AddressSpecificExtended::new)
        }
    }
}

impl ::protobuf::Clear for IPv4AddressSpecificExtended {
    fn clear(&mut self) {
        self.is_transitive = false;
        self.sub_type = 0;
        self.address.clear();
        self.local_admin = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IPv4AddressSpecificExtended {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IPv4AddressSpecificExtended {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FourOctetAsSpecificExtended {
    // message fields
    pub is_transitive: bool,
    pub sub_type: u32,
    pub field_as: u32,
    pub local_admin: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FourOctetAsSpecificExtended {
    fn default() -> &'a FourOctetAsSpecificExtended {
        <FourOctetAsSpecificExtended as ::protobuf::Message>::default_instance()
    }
}

impl FourOctetAsSpecificExtended {
    pub fn new() -> FourOctetAsSpecificExtended {
        ::std::default::Default::default()
    }

    // bool is_transitive = 1;


    pub fn get_is_transitive(&self) -> bool {
        self.is_transitive
    }
    pub fn clear_is_transitive(&mut self) {
        self.is_transitive = false;
    }

    // Param is passed by value, moved
    pub fn set_is_transitive(&mut self, v: bool) {
        self.is_transitive = v;
    }

    // uint32 sub_type = 2;


    pub fn get_sub_type(&self) -> u32 {
        self.sub_type
    }
    pub fn clear_sub_type(&mut self) {
        self.sub_type = 0;
    }

    // Param is passed by value, moved
    pub fn set_sub_type(&mut self, v: u32) {
        self.sub_type = v;
    }

    // uint32 as = 3;


    pub fn get_field_as(&self) -> u32 {
        self.field_as
    }
    pub fn clear_field_as(&mut self) {
        self.field_as = 0;
    }

    // Param is passed by value, moved
    pub fn set_field_as(&mut self, v: u32) {
        self.field_as = v;
    }

    // uint32 local_admin = 4;


    pub fn get_local_admin(&self) -> u32 {
        self.local_admin
    }
    pub fn clear_local_admin(&mut self) {
        self.local_admin = 0;
    }

    // Param is passed by value, moved
    pub fn set_local_admin(&mut self, v: u32) {
        self.local_admin = v;
    }
}

impl ::protobuf::Message for FourOctetAsSpecificExtended {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_transitive = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.sub_type = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.field_as = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.local_admin = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.is_transitive != false {
            my_size += 2;
        }
        if self.sub_type != 0 {
            my_size += ::protobuf::rt::value_size(2, self.sub_type, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.field_as != 0 {
            my_size += ::protobuf::rt::value_size(3, self.field_as, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.local_admin != 0 {
            my_size += ::protobuf::rt::value_size(4, self.local_admin, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.is_transitive != false {
            os.write_bool(1, self.is_transitive)?;
        }
        if self.sub_type != 0 {
            os.write_uint32(2, self.sub_type)?;
        }
        if self.field_as != 0 {
            os.write_uint32(3, self.field_as)?;
        }
        if self.local_admin != 0 {
            os.write_uint32(4, self.local_admin)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FourOctetAsSpecificExtended {
        FourOctetAsSpecificExtended::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_transitive",
                    |m: &FourOctetAsSpecificExtended| { &m.is_transitive },
                    |m: &mut FourOctetAsSpecificExtended| { &mut m.is_transitive },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "sub_type",
                    |m: &FourOctetAsSpecificExtended| { &m.sub_type },
                    |m: &mut FourOctetAsSpecificExtended| { &mut m.sub_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "as",
                    |m: &FourOctetAsSpecificExtended| { &m.field_as },
                    |m: &mut FourOctetAsSpecificExtended| { &mut m.field_as },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "local_admin",
                    |m: &FourOctetAsSpecificExtended| { &m.local_admin },
                    |m: &mut FourOctetAsSpecificExtended| { &mut m.local_admin },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FourOctetAsSpecificExtended>(
                    "FourOctetAsSpecificExtended",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FourOctetAsSpecificExtended {
        static mut instance: ::protobuf::lazy::Lazy<FourOctetAsSpecificExtended> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FourOctetAsSpecificExtended,
        };
        unsafe {
            instance.get(FourOctetAsSpecificExtended::new)
        }
    }
}

impl ::protobuf::Clear for FourOctetAsSpecificExtended {
    fn clear(&mut self) {
        self.is_transitive = false;
        self.sub_type = 0;
        self.field_as = 0;
        self.local_admin = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FourOctetAsSpecificExtended {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FourOctetAsSpecificExtended {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ValidationExtended {
    // message fields
    pub state: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ValidationExtended {
    fn default() -> &'a ValidationExtended {
        <ValidationExtended as ::protobuf::Message>::default_instance()
    }
}

impl ValidationExtended {
    pub fn new() -> ValidationExtended {
        ::std::default::Default::default()
    }

    // uint32 state = 1;


    pub fn get_state(&self) -> u32 {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = 0;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: u32) {
        self.state = v;
    }
}

impl ::protobuf::Message for ValidationExtended {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.state = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.state != 0 {
            my_size += ::protobuf::rt::value_size(1, self.state, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.state != 0 {
            os.write_uint32(1, self.state)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ValidationExtended {
        ValidationExtended::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "state",
                    |m: &ValidationExtended| { &m.state },
                    |m: &mut ValidationExtended| { &mut m.state },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ValidationExtended>(
                    "ValidationExtended",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ValidationExtended {
        static mut instance: ::protobuf::lazy::Lazy<ValidationExtended> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ValidationExtended,
        };
        unsafe {
            instance.get(ValidationExtended::new)
        }
    }
}

impl ::protobuf::Clear for ValidationExtended {
    fn clear(&mut self) {
        self.state = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ValidationExtended {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidationExtended {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ColorExtended {
    // message fields
    pub color: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ColorExtended {
    fn default() -> &'a ColorExtended {
        <ColorExtended as ::protobuf::Message>::default_instance()
    }
}

impl ColorExtended {
    pub fn new() -> ColorExtended {
        ::std::default::Default::default()
    }

    // uint32 color = 1;


    pub fn get_color(&self) -> u32 {
        self.color
    }
    pub fn clear_color(&mut self) {
        self.color = 0;
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: u32) {
        self.color = v;
    }
}

impl ::protobuf::Message for ColorExtended {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.color = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.color != 0 {
            my_size += ::protobuf::rt::value_size(1, self.color, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.color != 0 {
            os.write_uint32(1, self.color)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ColorExtended {
        ColorExtended::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "color",
                    |m: &ColorExtended| { &m.color },
                    |m: &mut ColorExtended| { &mut m.color },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ColorExtended>(
                    "ColorExtended",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ColorExtended {
        static mut instance: ::protobuf::lazy::Lazy<ColorExtended> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ColorExtended,
        };
        unsafe {
            instance.get(ColorExtended::new)
        }
    }
}

impl ::protobuf::Clear for ColorExtended {
    fn clear(&mut self) {
        self.color = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ColorExtended {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ColorExtended {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EncapExtended {
    // message fields
    pub tunnel_type: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EncapExtended {
    fn default() -> &'a EncapExtended {
        <EncapExtended as ::protobuf::Message>::default_instance()
    }
}

impl EncapExtended {
    pub fn new() -> EncapExtended {
        ::std::default::Default::default()
    }

    // uint32 tunnel_type = 1;


    pub fn get_tunnel_type(&self) -> u32 {
        self.tunnel_type
    }
    pub fn clear_tunnel_type(&mut self) {
        self.tunnel_type = 0;
    }

    // Param is passed by value, moved
    pub fn set_tunnel_type(&mut self, v: u32) {
        self.tunnel_type = v;
    }
}

impl ::protobuf::Message for EncapExtended {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tunnel_type = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.tunnel_type != 0 {
            my_size += ::protobuf::rt::value_size(1, self.tunnel_type, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.tunnel_type != 0 {
            os.write_uint32(1, self.tunnel_type)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EncapExtended {
        EncapExtended::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tunnel_type",
                    |m: &EncapExtended| { &m.tunnel_type },
                    |m: &mut EncapExtended| { &mut m.tunnel_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EncapExtended>(
                    "EncapExtended",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EncapExtended {
        static mut instance: ::protobuf::lazy::Lazy<EncapExtended> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EncapExtended,
        };
        unsafe {
            instance.get(EncapExtended::new)
        }
    }
}

impl ::protobuf::Clear for EncapExtended {
    fn clear(&mut self) {
        self.tunnel_type = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EncapExtended {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EncapExtended {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DefaultGatewayExtended {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DefaultGatewayExtended {
    fn default() -> &'a DefaultGatewayExtended {
        <DefaultGatewayExtended as ::protobuf::Message>::default_instance()
    }
}

impl DefaultGatewayExtended {
    pub fn new() -> DefaultGatewayExtended {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DefaultGatewayExtended {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DefaultGatewayExtended {
        DefaultGatewayExtended::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<DefaultGatewayExtended>(
                    "DefaultGatewayExtended",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DefaultGatewayExtended {
        static mut instance: ::protobuf::lazy::Lazy<DefaultGatewayExtended> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DefaultGatewayExtended,
        };
        unsafe {
            instance.get(DefaultGatewayExtended::new)
        }
    }
}

impl ::protobuf::Clear for DefaultGatewayExtended {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DefaultGatewayExtended {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DefaultGatewayExtended {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OpaqueExtended {
    // message fields
    pub is_transitive: bool,
    pub value: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OpaqueExtended {
    fn default() -> &'a OpaqueExtended {
        <OpaqueExtended as ::protobuf::Message>::default_instance()
    }
}

impl OpaqueExtended {
    pub fn new() -> OpaqueExtended {
        ::std::default::Default::default()
    }

    // bool is_transitive = 1;


    pub fn get_is_transitive(&self) -> bool {
        self.is_transitive
    }
    pub fn clear_is_transitive(&mut self) {
        self.is_transitive = false;
    }

    // Param is passed by value, moved
    pub fn set_is_transitive(&mut self, v: bool) {
        self.is_transitive = v;
    }

    // bytes value = 3;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for OpaqueExtended {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_transitive = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.is_transitive != false {
            my_size += 2;
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.is_transitive != false {
            os.write_bool(1, self.is_transitive)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(3, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OpaqueExtended {
        OpaqueExtended::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_transitive",
                    |m: &OpaqueExtended| { &m.is_transitive },
                    |m: &mut OpaqueExtended| { &mut m.is_transitive },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "value",
                    |m: &OpaqueExtended| { &m.value },
                    |m: &mut OpaqueExtended| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OpaqueExtended>(
                    "OpaqueExtended",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static OpaqueExtended {
        static mut instance: ::protobuf::lazy::Lazy<OpaqueExtended> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OpaqueExtended,
        };
        unsafe {
            instance.get(OpaqueExtended::new)
        }
    }
}

impl ::protobuf::Clear for OpaqueExtended {
    fn clear(&mut self) {
        self.is_transitive = false;
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OpaqueExtended {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpaqueExtended {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ESILabelExtended {
    // message fields
    pub is_single_active: bool,
    pub label: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ESILabelExtended {
    fn default() -> &'a ESILabelExtended {
        <ESILabelExtended as ::protobuf::Message>::default_instance()
    }
}

impl ESILabelExtended {
    pub fn new() -> ESILabelExtended {
        ::std::default::Default::default()
    }

    // bool is_single_active = 1;


    pub fn get_is_single_active(&self) -> bool {
        self.is_single_active
    }
    pub fn clear_is_single_active(&mut self) {
        self.is_single_active = false;
    }

    // Param is passed by value, moved
    pub fn set_is_single_active(&mut self, v: bool) {
        self.is_single_active = v;
    }

    // uint32 label = 2;


    pub fn get_label(&self) -> u32 {
        self.label
    }
    pub fn clear_label(&mut self) {
        self.label = 0;
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: u32) {
        self.label = v;
    }
}

impl ::protobuf::Message for ESILabelExtended {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_single_active = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.label = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.is_single_active != false {
            my_size += 2;
        }
        if self.label != 0 {
            my_size += ::protobuf::rt::value_size(2, self.label, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.is_single_active != false {
            os.write_bool(1, self.is_single_active)?;
        }
        if self.label != 0 {
            os.write_uint32(2, self.label)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ESILabelExtended {
        ESILabelExtended::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_single_active",
                    |m: &ESILabelExtended| { &m.is_single_active },
                    |m: &mut ESILabelExtended| { &mut m.is_single_active },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "label",
                    |m: &ESILabelExtended| { &m.label },
                    |m: &mut ESILabelExtended| { &mut m.label },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ESILabelExtended>(
                    "ESILabelExtended",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ESILabelExtended {
        static mut instance: ::protobuf::lazy::Lazy<ESILabelExtended> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ESILabelExtended,
        };
        unsafe {
            instance.get(ESILabelExtended::new)
        }
    }
}

impl ::protobuf::Clear for ESILabelExtended {
    fn clear(&mut self) {
        self.is_single_active = false;
        self.label = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ESILabelExtended {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ESILabelExtended {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ESImportRouteTarget {
    // message fields
    pub es_import: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ESImportRouteTarget {
    fn default() -> &'a ESImportRouteTarget {
        <ESImportRouteTarget as ::protobuf::Message>::default_instance()
    }
}

impl ESImportRouteTarget {
    pub fn new() -> ESImportRouteTarget {
        ::std::default::Default::default()
    }

    // string es_import = 1;


    pub fn get_es_import(&self) -> &str {
        &self.es_import
    }
    pub fn clear_es_import(&mut self) {
        self.es_import.clear();
    }

    // Param is passed by value, moved
    pub fn set_es_import(&mut self, v: ::std::string::String) {
        self.es_import = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_es_import(&mut self) -> &mut ::std::string::String {
        &mut self.es_import
    }

    // Take field
    pub fn take_es_import(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.es_import, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ESImportRouteTarget {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.es_import)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.es_import.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.es_import);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.es_import.is_empty() {
            os.write_string(1, &self.es_import)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ESImportRouteTarget {
        ESImportRouteTarget::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "es_import",
                    |m: &ESImportRouteTarget| { &m.es_import },
                    |m: &mut ESImportRouteTarget| { &mut m.es_import },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ESImportRouteTarget>(
                    "ESImportRouteTarget",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ESImportRouteTarget {
        static mut instance: ::protobuf::lazy::Lazy<ESImportRouteTarget> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ESImportRouteTarget,
        };
        unsafe {
            instance.get(ESImportRouteTarget::new)
        }
    }
}

impl ::protobuf::Clear for ESImportRouteTarget {
    fn clear(&mut self) {
        self.es_import.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ESImportRouteTarget {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ESImportRouteTarget {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MacMobilityExtended {
    // message fields
    pub is_sticky: bool,
    pub sequence_num: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MacMobilityExtended {
    fn default() -> &'a MacMobilityExtended {
        <MacMobilityExtended as ::protobuf::Message>::default_instance()
    }
}

impl MacMobilityExtended {
    pub fn new() -> MacMobilityExtended {
        ::std::default::Default::default()
    }

    // bool is_sticky = 1;


    pub fn get_is_sticky(&self) -> bool {
        self.is_sticky
    }
    pub fn clear_is_sticky(&mut self) {
        self.is_sticky = false;
    }

    // Param is passed by value, moved
    pub fn set_is_sticky(&mut self, v: bool) {
        self.is_sticky = v;
    }

    // uint32 sequence_num = 2;


    pub fn get_sequence_num(&self) -> u32 {
        self.sequence_num
    }
    pub fn clear_sequence_num(&mut self) {
        self.sequence_num = 0;
    }

    // Param is passed by value, moved
    pub fn set_sequence_num(&mut self, v: u32) {
        self.sequence_num = v;
    }
}

impl ::protobuf::Message for MacMobilityExtended {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_sticky = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.sequence_num = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.is_sticky != false {
            my_size += 2;
        }
        if self.sequence_num != 0 {
            my_size += ::protobuf::rt::value_size(2, self.sequence_num, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.is_sticky != false {
            os.write_bool(1, self.is_sticky)?;
        }
        if self.sequence_num != 0 {
            os.write_uint32(2, self.sequence_num)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MacMobilityExtended {
        MacMobilityExtended::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_sticky",
                    |m: &MacMobilityExtended| { &m.is_sticky },
                    |m: &mut MacMobilityExtended| { &mut m.is_sticky },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "sequence_num",
                    |m: &MacMobilityExtended| { &m.sequence_num },
                    |m: &mut MacMobilityExtended| { &mut m.sequence_num },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MacMobilityExtended>(
                    "MacMobilityExtended",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MacMobilityExtended {
        static mut instance: ::protobuf::lazy::Lazy<MacMobilityExtended> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MacMobilityExtended,
        };
        unsafe {
            instance.get(MacMobilityExtended::new)
        }
    }
}

impl ::protobuf::Clear for MacMobilityExtended {
    fn clear(&mut self) {
        self.is_sticky = false;
        self.sequence_num = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MacMobilityExtended {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MacMobilityExtended {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RouterMacExtended {
    // message fields
    pub mac: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RouterMacExtended {
    fn default() -> &'a RouterMacExtended {
        <RouterMacExtended as ::protobuf::Message>::default_instance()
    }
}

impl RouterMacExtended {
    pub fn new() -> RouterMacExtended {
        ::std::default::Default::default()
    }

    // string mac = 1;


    pub fn get_mac(&self) -> &str {
        &self.mac
    }
    pub fn clear_mac(&mut self) {
        self.mac.clear();
    }

    // Param is passed by value, moved
    pub fn set_mac(&mut self, v: ::std::string::String) {
        self.mac = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mac(&mut self) -> &mut ::std::string::String {
        &mut self.mac
    }

    // Take field
    pub fn take_mac(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mac, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RouterMacExtended {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.mac)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.mac.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.mac);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.mac.is_empty() {
            os.write_string(1, &self.mac)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouterMacExtended {
        RouterMacExtended::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "mac",
                    |m: &RouterMacExtended| { &m.mac },
                    |m: &mut RouterMacExtended| { &mut m.mac },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RouterMacExtended>(
                    "RouterMacExtended",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RouterMacExtended {
        static mut instance: ::protobuf::lazy::Lazy<RouterMacExtended> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RouterMacExtended,
        };
        unsafe {
            instance.get(RouterMacExtended::new)
        }
    }
}

impl ::protobuf::Clear for RouterMacExtended {
    fn clear(&mut self) {
        self.mac.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouterMacExtended {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouterMacExtended {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TrafficRateExtended {
    // message fields
    pub field_as: u32,
    pub rate: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TrafficRateExtended {
    fn default() -> &'a TrafficRateExtended {
        <TrafficRateExtended as ::protobuf::Message>::default_instance()
    }
}

impl TrafficRateExtended {
    pub fn new() -> TrafficRateExtended {
        ::std::default::Default::default()
    }

    // uint32 as = 1;


    pub fn get_field_as(&self) -> u32 {
        self.field_as
    }
    pub fn clear_field_as(&mut self) {
        self.field_as = 0;
    }

    // Param is passed by value, moved
    pub fn set_field_as(&mut self, v: u32) {
        self.field_as = v;
    }

    // float rate = 2;


    pub fn get_rate(&self) -> f32 {
        self.rate
    }
    pub fn clear_rate(&mut self) {
        self.rate = 0.;
    }

    // Param is passed by value, moved
    pub fn set_rate(&mut self, v: f32) {
        self.rate = v;
    }
}

impl ::protobuf::Message for TrafficRateExtended {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.field_as = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.rate = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_as != 0 {
            my_size += ::protobuf::rt::value_size(1, self.field_as, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.rate != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_as != 0 {
            os.write_uint32(1, self.field_as)?;
        }
        if self.rate != 0. {
            os.write_float(2, self.rate)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TrafficRateExtended {
        TrafficRateExtended::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "as",
                    |m: &TrafficRateExtended| { &m.field_as },
                    |m: &mut TrafficRateExtended| { &mut m.field_as },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "rate",
                    |m: &TrafficRateExtended| { &m.rate },
                    |m: &mut TrafficRateExtended| { &mut m.rate },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TrafficRateExtended>(
                    "TrafficRateExtended",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TrafficRateExtended {
        static mut instance: ::protobuf::lazy::Lazy<TrafficRateExtended> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TrafficRateExtended,
        };
        unsafe {
            instance.get(TrafficRateExtended::new)
        }
    }
}

impl ::protobuf::Clear for TrafficRateExtended {
    fn clear(&mut self) {
        self.field_as = 0;
        self.rate = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TrafficRateExtended {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrafficRateExtended {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TrafficActionExtended {
    // message fields
    pub terminal: bool,
    pub sample: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TrafficActionExtended {
    fn default() -> &'a TrafficActionExtended {
        <TrafficActionExtended as ::protobuf::Message>::default_instance()
    }
}

impl TrafficActionExtended {
    pub fn new() -> TrafficActionExtended {
        ::std::default::Default::default()
    }

    // bool terminal = 1;


    pub fn get_terminal(&self) -> bool {
        self.terminal
    }
    pub fn clear_terminal(&mut self) {
        self.terminal = false;
    }

    // Param is passed by value, moved
    pub fn set_terminal(&mut self, v: bool) {
        self.terminal = v;
    }

    // bool sample = 2;


    pub fn get_sample(&self) -> bool {
        self.sample
    }
    pub fn clear_sample(&mut self) {
        self.sample = false;
    }

    // Param is passed by value, moved
    pub fn set_sample(&mut self, v: bool) {
        self.sample = v;
    }
}

impl ::protobuf::Message for TrafficActionExtended {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.terminal = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.sample = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.terminal != false {
            my_size += 2;
        }
        if self.sample != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.terminal != false {
            os.write_bool(1, self.terminal)?;
        }
        if self.sample != false {
            os.write_bool(2, self.sample)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TrafficActionExtended {
        TrafficActionExtended::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "terminal",
                    |m: &TrafficActionExtended| { &m.terminal },
                    |m: &mut TrafficActionExtended| { &mut m.terminal },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "sample",
                    |m: &TrafficActionExtended| { &m.sample },
                    |m: &mut TrafficActionExtended| { &mut m.sample },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TrafficActionExtended>(
                    "TrafficActionExtended",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TrafficActionExtended {
        static mut instance: ::protobuf::lazy::Lazy<TrafficActionExtended> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TrafficActionExtended,
        };
        unsafe {
            instance.get(TrafficActionExtended::new)
        }
    }
}

impl ::protobuf::Clear for TrafficActionExtended {
    fn clear(&mut self) {
        self.terminal = false;
        self.sample = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TrafficActionExtended {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrafficActionExtended {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RedirectTwoOctetAsSpecificExtended {
    // message fields
    pub field_as: u32,
    pub local_admin: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RedirectTwoOctetAsSpecificExtended {
    fn default() -> &'a RedirectTwoOctetAsSpecificExtended {
        <RedirectTwoOctetAsSpecificExtended as ::protobuf::Message>::default_instance()
    }
}

impl RedirectTwoOctetAsSpecificExtended {
    pub fn new() -> RedirectTwoOctetAsSpecificExtended {
        ::std::default::Default::default()
    }

    // uint32 as = 1;


    pub fn get_field_as(&self) -> u32 {
        self.field_as
    }
    pub fn clear_field_as(&mut self) {
        self.field_as = 0;
    }

    // Param is passed by value, moved
    pub fn set_field_as(&mut self, v: u32) {
        self.field_as = v;
    }

    // uint32 local_admin = 2;


    pub fn get_local_admin(&self) -> u32 {
        self.local_admin
    }
    pub fn clear_local_admin(&mut self) {
        self.local_admin = 0;
    }

    // Param is passed by value, moved
    pub fn set_local_admin(&mut self, v: u32) {
        self.local_admin = v;
    }
}

impl ::protobuf::Message for RedirectTwoOctetAsSpecificExtended {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.field_as = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.local_admin = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_as != 0 {
            my_size += ::protobuf::rt::value_size(1, self.field_as, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.local_admin != 0 {
            my_size += ::protobuf::rt::value_size(2, self.local_admin, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_as != 0 {
            os.write_uint32(1, self.field_as)?;
        }
        if self.local_admin != 0 {
            os.write_uint32(2, self.local_admin)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RedirectTwoOctetAsSpecificExtended {
        RedirectTwoOctetAsSpecificExtended::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "as",
                    |m: &RedirectTwoOctetAsSpecificExtended| { &m.field_as },
                    |m: &mut RedirectTwoOctetAsSpecificExtended| { &mut m.field_as },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "local_admin",
                    |m: &RedirectTwoOctetAsSpecificExtended| { &m.local_admin },
                    |m: &mut RedirectTwoOctetAsSpecificExtended| { &mut m.local_admin },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RedirectTwoOctetAsSpecificExtended>(
                    "RedirectTwoOctetAsSpecificExtended",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RedirectTwoOctetAsSpecificExtended {
        static mut instance: ::protobuf::lazy::Lazy<RedirectTwoOctetAsSpecificExtended> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RedirectTwoOctetAsSpecificExtended,
        };
        unsafe {
            instance.get(RedirectTwoOctetAsSpecificExtended::new)
        }
    }
}

impl ::protobuf::Clear for RedirectTwoOctetAsSpecificExtended {
    fn clear(&mut self) {
        self.field_as = 0;
        self.local_admin = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RedirectTwoOctetAsSpecificExtended {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RedirectTwoOctetAsSpecificExtended {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RedirectIPv4AddressSpecificExtended {
    // message fields
    pub address: ::std::string::String,
    pub local_admin: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RedirectIPv4AddressSpecificExtended {
    fn default() -> &'a RedirectIPv4AddressSpecificExtended {
        <RedirectIPv4AddressSpecificExtended as ::protobuf::Message>::default_instance()
    }
}

impl RedirectIPv4AddressSpecificExtended {
    pub fn new() -> RedirectIPv4AddressSpecificExtended {
        ::std::default::Default::default()
    }

    // string address = 1;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // uint32 local_admin = 2;


    pub fn get_local_admin(&self) -> u32 {
        self.local_admin
    }
    pub fn clear_local_admin(&mut self) {
        self.local_admin = 0;
    }

    // Param is passed by value, moved
    pub fn set_local_admin(&mut self, v: u32) {
        self.local_admin = v;
    }
}

impl ::protobuf::Message for RedirectIPv4AddressSpecificExtended {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.local_admin = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if self.local_admin != 0 {
            my_size += ::protobuf::rt::value_size(2, self.local_admin, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if self.local_admin != 0 {
            os.write_uint32(2, self.local_admin)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RedirectIPv4AddressSpecificExtended {
        RedirectIPv4AddressSpecificExtended::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "address",
                    |m: &RedirectIPv4AddressSpecificExtended| { &m.address },
                    |m: &mut RedirectIPv4AddressSpecificExtended| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "local_admin",
                    |m: &RedirectIPv4AddressSpecificExtended| { &m.local_admin },
                    |m: &mut RedirectIPv4AddressSpecificExtended| { &mut m.local_admin },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RedirectIPv4AddressSpecificExtended>(
                    "RedirectIPv4AddressSpecificExtended",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RedirectIPv4AddressSpecificExtended {
        static mut instance: ::protobuf::lazy::Lazy<RedirectIPv4AddressSpecificExtended> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RedirectIPv4AddressSpecificExtended,
        };
        unsafe {
            instance.get(RedirectIPv4AddressSpecificExtended::new)
        }
    }
}

impl ::protobuf::Clear for RedirectIPv4AddressSpecificExtended {
    fn clear(&mut self) {
        self.address.clear();
        self.local_admin = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RedirectIPv4AddressSpecificExtended {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RedirectIPv4AddressSpecificExtended {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RedirectFourOctetAsSpecificExtended {
    // message fields
    pub field_as: u32,
    pub local_admin: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RedirectFourOctetAsSpecificExtended {
    fn default() -> &'a RedirectFourOctetAsSpecificExtended {
        <RedirectFourOctetAsSpecificExtended as ::protobuf::Message>::default_instance()
    }
}

impl RedirectFourOctetAsSpecificExtended {
    pub fn new() -> RedirectFourOctetAsSpecificExtended {
        ::std::default::Default::default()
    }

    // uint32 as = 1;


    pub fn get_field_as(&self) -> u32 {
        self.field_as
    }
    pub fn clear_field_as(&mut self) {
        self.field_as = 0;
    }

    // Param is passed by value, moved
    pub fn set_field_as(&mut self, v: u32) {
        self.field_as = v;
    }

    // uint32 local_admin = 2;


    pub fn get_local_admin(&self) -> u32 {
        self.local_admin
    }
    pub fn clear_local_admin(&mut self) {
        self.local_admin = 0;
    }

    // Param is passed by value, moved
    pub fn set_local_admin(&mut self, v: u32) {
        self.local_admin = v;
    }
}

impl ::protobuf::Message for RedirectFourOctetAsSpecificExtended {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.field_as = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.local_admin = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_as != 0 {
            my_size += ::protobuf::rt::value_size(1, self.field_as, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.local_admin != 0 {
            my_size += ::protobuf::rt::value_size(2, self.local_admin, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_as != 0 {
            os.write_uint32(1, self.field_as)?;
        }
        if self.local_admin != 0 {
            os.write_uint32(2, self.local_admin)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RedirectFourOctetAsSpecificExtended {
        RedirectFourOctetAsSpecificExtended::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "as",
                    |m: &RedirectFourOctetAsSpecificExtended| { &m.field_as },
                    |m: &mut RedirectFourOctetAsSpecificExtended| { &mut m.field_as },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "local_admin",
                    |m: &RedirectFourOctetAsSpecificExtended| { &m.local_admin },
                    |m: &mut RedirectFourOctetAsSpecificExtended| { &mut m.local_admin },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RedirectFourOctetAsSpecificExtended>(
                    "RedirectFourOctetAsSpecificExtended",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RedirectFourOctetAsSpecificExtended {
        static mut instance: ::protobuf::lazy::Lazy<RedirectFourOctetAsSpecificExtended> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RedirectFourOctetAsSpecificExtended,
        };
        unsafe {
            instance.get(RedirectFourOctetAsSpecificExtended::new)
        }
    }
}

impl ::protobuf::Clear for RedirectFourOctetAsSpecificExtended {
    fn clear(&mut self) {
        self.field_as = 0;
        self.local_admin = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RedirectFourOctetAsSpecificExtended {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RedirectFourOctetAsSpecificExtended {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TrafficRemarkExtended {
    // message fields
    pub dscp: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TrafficRemarkExtended {
    fn default() -> &'a TrafficRemarkExtended {
        <TrafficRemarkExtended as ::protobuf::Message>::default_instance()
    }
}

impl TrafficRemarkExtended {
    pub fn new() -> TrafficRemarkExtended {
        ::std::default::Default::default()
    }

    // uint32 dscp = 1;


    pub fn get_dscp(&self) -> u32 {
        self.dscp
    }
    pub fn clear_dscp(&mut self) {
        self.dscp = 0;
    }

    // Param is passed by value, moved
    pub fn set_dscp(&mut self, v: u32) {
        self.dscp = v;
    }
}

impl ::protobuf::Message for TrafficRemarkExtended {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dscp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.dscp != 0 {
            my_size += ::protobuf::rt::value_size(1, self.dscp, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.dscp != 0 {
            os.write_uint32(1, self.dscp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TrafficRemarkExtended {
        TrafficRemarkExtended::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "dscp",
                    |m: &TrafficRemarkExtended| { &m.dscp },
                    |m: &mut TrafficRemarkExtended| { &mut m.dscp },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TrafficRemarkExtended>(
                    "TrafficRemarkExtended",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TrafficRemarkExtended {
        static mut instance: ::protobuf::lazy::Lazy<TrafficRemarkExtended> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TrafficRemarkExtended,
        };
        unsafe {
            instance.get(TrafficRemarkExtended::new)
        }
    }
}

impl ::protobuf::Clear for TrafficRemarkExtended {
    fn clear(&mut self) {
        self.dscp = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TrafficRemarkExtended {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrafficRemarkExtended {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UnknownExtended {
    // message fields
    pub field_type: u32,
    pub value: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UnknownExtended {
    fn default() -> &'a UnknownExtended {
        <UnknownExtended as ::protobuf::Message>::default_instance()
    }
}

impl UnknownExtended {
    pub fn new() -> UnknownExtended {
        ::std::default::Default::default()
    }

    // uint32 type = 1;


    pub fn get_field_type(&self) -> u32 {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = 0;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: u32) {
        self.field_type = v;
    }

    // bytes value = 2;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for UnknownExtended {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.field_type = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != 0 {
            my_size += ::protobuf::rt::value_size(1, self.field_type, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != 0 {
            os.write_uint32(1, self.field_type)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(2, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnknownExtended {
        UnknownExtended::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "type",
                    |m: &UnknownExtended| { &m.field_type },
                    |m: &mut UnknownExtended| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "value",
                    |m: &UnknownExtended| { &m.value },
                    |m: &mut UnknownExtended| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UnknownExtended>(
                    "UnknownExtended",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UnknownExtended {
        static mut instance: ::protobuf::lazy::Lazy<UnknownExtended> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UnknownExtended,
        };
        unsafe {
            instance.get(UnknownExtended::new)
        }
    }
}

impl ::protobuf::Clear for UnknownExtended {
    fn clear(&mut self) {
        self.field_type = 0;
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnknownExtended {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnknownExtended {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExtendedCommunitiesAttribute {
    // message fields
    pub communities: ::protobuf::RepeatedField<::protobuf::well_known_types::Any>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExtendedCommunitiesAttribute {
    fn default() -> &'a ExtendedCommunitiesAttribute {
        <ExtendedCommunitiesAttribute as ::protobuf::Message>::default_instance()
    }
}

impl ExtendedCommunitiesAttribute {
    pub fn new() -> ExtendedCommunitiesAttribute {
        ::std::default::Default::default()
    }

    // repeated .google.protobuf.Any communities = 1;


    pub fn get_communities(&self) -> &[::protobuf::well_known_types::Any] {
        &self.communities
    }
    pub fn clear_communities(&mut self) {
        self.communities.clear();
    }

    // Param is passed by value, moved
    pub fn set_communities(&mut self, v: ::protobuf::RepeatedField<::protobuf::well_known_types::Any>) {
        self.communities = v;
    }

    // Mutable pointer to the field.
    pub fn mut_communities(&mut self) -> &mut ::protobuf::RepeatedField<::protobuf::well_known_types::Any> {
        &mut self.communities
    }

    // Take field
    pub fn take_communities(&mut self) -> ::protobuf::RepeatedField<::protobuf::well_known_types::Any> {
        ::std::mem::replace(&mut self.communities, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ExtendedCommunitiesAttribute {
    fn is_initialized(&self) -> bool {
        for v in &self.communities {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.communities)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.communities {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.communities {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExtendedCommunitiesAttribute {
        ExtendedCommunitiesAttribute::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                    "communities",
                    |m: &ExtendedCommunitiesAttribute| { &m.communities },
                    |m: &mut ExtendedCommunitiesAttribute| { &mut m.communities },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ExtendedCommunitiesAttribute>(
                    "ExtendedCommunitiesAttribute",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ExtendedCommunitiesAttribute {
        static mut instance: ::protobuf::lazy::Lazy<ExtendedCommunitiesAttribute> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ExtendedCommunitiesAttribute,
        };
        unsafe {
            instance.get(ExtendedCommunitiesAttribute::new)
        }
    }
}

impl ::protobuf::Clear for ExtendedCommunitiesAttribute {
    fn clear(&mut self) {
        self.communities.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExtendedCommunitiesAttribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExtendedCommunitiesAttribute {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct As4PathAttribute {
    // message fields
    pub segments: ::protobuf::RepeatedField<AsSegment>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a As4PathAttribute {
    fn default() -> &'a As4PathAttribute {
        <As4PathAttribute as ::protobuf::Message>::default_instance()
    }
}

impl As4PathAttribute {
    pub fn new() -> As4PathAttribute {
        ::std::default::Default::default()
    }

    // repeated .gobgpapi.AsSegment segments = 1;


    pub fn get_segments(&self) -> &[AsSegment] {
        &self.segments
    }
    pub fn clear_segments(&mut self) {
        self.segments.clear();
    }

    // Param is passed by value, moved
    pub fn set_segments(&mut self, v: ::protobuf::RepeatedField<AsSegment>) {
        self.segments = v;
    }

    // Mutable pointer to the field.
    pub fn mut_segments(&mut self) -> &mut ::protobuf::RepeatedField<AsSegment> {
        &mut self.segments
    }

    // Take field
    pub fn take_segments(&mut self) -> ::protobuf::RepeatedField<AsSegment> {
        ::std::mem::replace(&mut self.segments, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for As4PathAttribute {
    fn is_initialized(&self) -> bool {
        for v in &self.segments {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.segments)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.segments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.segments {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> As4PathAttribute {
        As4PathAttribute::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AsSegment>>(
                    "segments",
                    |m: &As4PathAttribute| { &m.segments },
                    |m: &mut As4PathAttribute| { &mut m.segments },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<As4PathAttribute>(
                    "As4PathAttribute",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static As4PathAttribute {
        static mut instance: ::protobuf::lazy::Lazy<As4PathAttribute> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const As4PathAttribute,
        };
        unsafe {
            instance.get(As4PathAttribute::new)
        }
    }
}

impl ::protobuf::Clear for As4PathAttribute {
    fn clear(&mut self) {
        self.segments.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for As4PathAttribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for As4PathAttribute {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct As4AggregatorAttribute {
    // message fields
    pub field_as: u32,
    pub address: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a As4AggregatorAttribute {
    fn default() -> &'a As4AggregatorAttribute {
        <As4AggregatorAttribute as ::protobuf::Message>::default_instance()
    }
}

impl As4AggregatorAttribute {
    pub fn new() -> As4AggregatorAttribute {
        ::std::default::Default::default()
    }

    // uint32 as = 2;


    pub fn get_field_as(&self) -> u32 {
        self.field_as
    }
    pub fn clear_field_as(&mut self) {
        self.field_as = 0;
    }

    // Param is passed by value, moved
    pub fn set_field_as(&mut self, v: u32) {
        self.field_as = v;
    }

    // string address = 3;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }
}

impl ::protobuf::Message for As4AggregatorAttribute {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.field_as = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_as != 0 {
            my_size += ::protobuf::rt::value_size(2, self.field_as, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_as != 0 {
            os.write_uint32(2, self.field_as)?;
        }
        if !self.address.is_empty() {
            os.write_string(3, &self.address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> As4AggregatorAttribute {
        As4AggregatorAttribute::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "as",
                    |m: &As4AggregatorAttribute| { &m.field_as },
                    |m: &mut As4AggregatorAttribute| { &mut m.field_as },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "address",
                    |m: &As4AggregatorAttribute| { &m.address },
                    |m: &mut As4AggregatorAttribute| { &mut m.address },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<As4AggregatorAttribute>(
                    "As4AggregatorAttribute",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static As4AggregatorAttribute {
        static mut instance: ::protobuf::lazy::Lazy<As4AggregatorAttribute> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const As4AggregatorAttribute,
        };
        unsafe {
            instance.get(As4AggregatorAttribute::new)
        }
    }
}

impl ::protobuf::Clear for As4AggregatorAttribute {
    fn clear(&mut self) {
        self.field_as = 0;
        self.address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for As4AggregatorAttribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for As4AggregatorAttribute {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PmsiTunnelAttribute {
    // message fields
    pub flags: u32,
    pub field_type: u32,
    pub label: u32,
    pub id: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PmsiTunnelAttribute {
    fn default() -> &'a PmsiTunnelAttribute {
        <PmsiTunnelAttribute as ::protobuf::Message>::default_instance()
    }
}

impl PmsiTunnelAttribute {
    pub fn new() -> PmsiTunnelAttribute {
        ::std::default::Default::default()
    }

    // uint32 flags = 1;


    pub fn get_flags(&self) -> u32 {
        self.flags
    }
    pub fn clear_flags(&mut self) {
        self.flags = 0;
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = v;
    }

    // uint32 type = 2;


    pub fn get_field_type(&self) -> u32 {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = 0;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: u32) {
        self.field_type = v;
    }

    // uint32 label = 3;


    pub fn get_label(&self) -> u32 {
        self.label
    }
    pub fn clear_label(&mut self) {
        self.label = 0;
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: u32) {
        self.label = v;
    }

    // bytes id = 4;


    pub fn get_id(&self) -> &[u8] {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.id, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for PmsiTunnelAttribute {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.field_type = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.label = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.flags != 0 {
            my_size += ::protobuf::rt::value_size(1, self.flags, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.field_type != 0 {
            my_size += ::protobuf::rt::value_size(2, self.field_type, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.label != 0 {
            my_size += ::protobuf::rt::value_size(3, self.label, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.flags != 0 {
            os.write_uint32(1, self.flags)?;
        }
        if self.field_type != 0 {
            os.write_uint32(2, self.field_type)?;
        }
        if self.label != 0 {
            os.write_uint32(3, self.label)?;
        }
        if !self.id.is_empty() {
            os.write_bytes(4, &self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PmsiTunnelAttribute {
        PmsiTunnelAttribute::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "flags",
                    |m: &PmsiTunnelAttribute| { &m.flags },
                    |m: &mut PmsiTunnelAttribute| { &mut m.flags },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "type",
                    |m: &PmsiTunnelAttribute| { &m.field_type },
                    |m: &mut PmsiTunnelAttribute| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "label",
                    |m: &PmsiTunnelAttribute| { &m.label },
                    |m: &mut PmsiTunnelAttribute| { &mut m.label },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "id",
                    |m: &PmsiTunnelAttribute| { &m.id },
                    |m: &mut PmsiTunnelAttribute| { &mut m.id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PmsiTunnelAttribute>(
                    "PmsiTunnelAttribute",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PmsiTunnelAttribute {
        static mut instance: ::protobuf::lazy::Lazy<PmsiTunnelAttribute> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PmsiTunnelAttribute,
        };
        unsafe {
            instance.get(PmsiTunnelAttribute::new)
        }
    }
}

impl ::protobuf::Clear for PmsiTunnelAttribute {
    fn clear(&mut self) {
        self.flags = 0;
        self.field_type = 0;
        self.label = 0;
        self.id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PmsiTunnelAttribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PmsiTunnelAttribute {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TunnelEncapSubTLVEncapsulation {
    // message fields
    pub key: u32,
    pub cookie: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TunnelEncapSubTLVEncapsulation {
    fn default() -> &'a TunnelEncapSubTLVEncapsulation {
        <TunnelEncapSubTLVEncapsulation as ::protobuf::Message>::default_instance()
    }
}

impl TunnelEncapSubTLVEncapsulation {
    pub fn new() -> TunnelEncapSubTLVEncapsulation {
        ::std::default::Default::default()
    }

    // uint32 key = 1;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // bytes cookie = 2;


    pub fn get_cookie(&self) -> &[u8] {
        &self.cookie
    }
    pub fn clear_cookie(&mut self) {
        self.cookie.clear();
    }

    // Param is passed by value, moved
    pub fn set_cookie(&mut self, v: ::std::vec::Vec<u8>) {
        self.cookie = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cookie(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.cookie
    }

    // Take field
    pub fn take_cookie(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.cookie, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for TunnelEncapSubTLVEncapsulation {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.key = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.cookie)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += ::protobuf::rt::value_size(1, self.key, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.cookie.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.cookie);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key != 0 {
            os.write_uint32(1, self.key)?;
        }
        if !self.cookie.is_empty() {
            os.write_bytes(2, &self.cookie)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TunnelEncapSubTLVEncapsulation {
        TunnelEncapSubTLVEncapsulation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "key",
                    |m: &TunnelEncapSubTLVEncapsulation| { &m.key },
                    |m: &mut TunnelEncapSubTLVEncapsulation| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "cookie",
                    |m: &TunnelEncapSubTLVEncapsulation| { &m.cookie },
                    |m: &mut TunnelEncapSubTLVEncapsulation| { &mut m.cookie },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TunnelEncapSubTLVEncapsulation>(
                    "TunnelEncapSubTLVEncapsulation",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TunnelEncapSubTLVEncapsulation {
        static mut instance: ::protobuf::lazy::Lazy<TunnelEncapSubTLVEncapsulation> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TunnelEncapSubTLVEncapsulation,
        };
        unsafe {
            instance.get(TunnelEncapSubTLVEncapsulation::new)
        }
    }
}

impl ::protobuf::Clear for TunnelEncapSubTLVEncapsulation {
    fn clear(&mut self) {
        self.key = 0;
        self.cookie.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TunnelEncapSubTLVEncapsulation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TunnelEncapSubTLVEncapsulation {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TunnelEncapSubTLVProtocol {
    // message fields
    pub protocol: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TunnelEncapSubTLVProtocol {
    fn default() -> &'a TunnelEncapSubTLVProtocol {
        <TunnelEncapSubTLVProtocol as ::protobuf::Message>::default_instance()
    }
}

impl TunnelEncapSubTLVProtocol {
    pub fn new() -> TunnelEncapSubTLVProtocol {
        ::std::default::Default::default()
    }

    // uint32 protocol = 1;


    pub fn get_protocol(&self) -> u32 {
        self.protocol
    }
    pub fn clear_protocol(&mut self) {
        self.protocol = 0;
    }

    // Param is passed by value, moved
    pub fn set_protocol(&mut self, v: u32) {
        self.protocol = v;
    }
}

impl ::protobuf::Message for TunnelEncapSubTLVProtocol {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.protocol = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.protocol != 0 {
            my_size += ::protobuf::rt::value_size(1, self.protocol, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.protocol != 0 {
            os.write_uint32(1, self.protocol)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TunnelEncapSubTLVProtocol {
        TunnelEncapSubTLVProtocol::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "protocol",
                    |m: &TunnelEncapSubTLVProtocol| { &m.protocol },
                    |m: &mut TunnelEncapSubTLVProtocol| { &mut m.protocol },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TunnelEncapSubTLVProtocol>(
                    "TunnelEncapSubTLVProtocol",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TunnelEncapSubTLVProtocol {
        static mut instance: ::protobuf::lazy::Lazy<TunnelEncapSubTLVProtocol> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TunnelEncapSubTLVProtocol,
        };
        unsafe {
            instance.get(TunnelEncapSubTLVProtocol::new)
        }
    }
}

impl ::protobuf::Clear for TunnelEncapSubTLVProtocol {
    fn clear(&mut self) {
        self.protocol = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TunnelEncapSubTLVProtocol {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TunnelEncapSubTLVProtocol {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TunnelEncapSubTLVColor {
    // message fields
    pub color: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TunnelEncapSubTLVColor {
    fn default() -> &'a TunnelEncapSubTLVColor {
        <TunnelEncapSubTLVColor as ::protobuf::Message>::default_instance()
    }
}

impl TunnelEncapSubTLVColor {
    pub fn new() -> TunnelEncapSubTLVColor {
        ::std::default::Default::default()
    }

    // uint32 color = 1;


    pub fn get_color(&self) -> u32 {
        self.color
    }
    pub fn clear_color(&mut self) {
        self.color = 0;
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: u32) {
        self.color = v;
    }
}

impl ::protobuf::Message for TunnelEncapSubTLVColor {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.color = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.color != 0 {
            my_size += ::protobuf::rt::value_size(1, self.color, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.color != 0 {
            os.write_uint32(1, self.color)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TunnelEncapSubTLVColor {
        TunnelEncapSubTLVColor::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "color",
                    |m: &TunnelEncapSubTLVColor| { &m.color },
                    |m: &mut TunnelEncapSubTLVColor| { &mut m.color },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TunnelEncapSubTLVColor>(
                    "TunnelEncapSubTLVColor",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TunnelEncapSubTLVColor {
        static mut instance: ::protobuf::lazy::Lazy<TunnelEncapSubTLVColor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TunnelEncapSubTLVColor,
        };
        unsafe {
            instance.get(TunnelEncapSubTLVColor::new)
        }
    }
}

impl ::protobuf::Clear for TunnelEncapSubTLVColor {
    fn clear(&mut self) {
        self.color = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TunnelEncapSubTLVColor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TunnelEncapSubTLVColor {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TunnelEncapSubTLVUnknown {
    // message fields
    pub field_type: u32,
    pub value: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TunnelEncapSubTLVUnknown {
    fn default() -> &'a TunnelEncapSubTLVUnknown {
        <TunnelEncapSubTLVUnknown as ::protobuf::Message>::default_instance()
    }
}

impl TunnelEncapSubTLVUnknown {
    pub fn new() -> TunnelEncapSubTLVUnknown {
        ::std::default::Default::default()
    }

    // uint32 type = 1;


    pub fn get_field_type(&self) -> u32 {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = 0;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: u32) {
        self.field_type = v;
    }

    // bytes value = 2;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for TunnelEncapSubTLVUnknown {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.field_type = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != 0 {
            my_size += ::protobuf::rt::value_size(1, self.field_type, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != 0 {
            os.write_uint32(1, self.field_type)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(2, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TunnelEncapSubTLVUnknown {
        TunnelEncapSubTLVUnknown::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "type",
                    |m: &TunnelEncapSubTLVUnknown| { &m.field_type },
                    |m: &mut TunnelEncapSubTLVUnknown| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "value",
                    |m: &TunnelEncapSubTLVUnknown| { &m.value },
                    |m: &mut TunnelEncapSubTLVUnknown| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TunnelEncapSubTLVUnknown>(
                    "TunnelEncapSubTLVUnknown",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TunnelEncapSubTLVUnknown {
        static mut instance: ::protobuf::lazy::Lazy<TunnelEncapSubTLVUnknown> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TunnelEncapSubTLVUnknown,
        };
        unsafe {
            instance.get(TunnelEncapSubTLVUnknown::new)
        }
    }
}

impl ::protobuf::Clear for TunnelEncapSubTLVUnknown {
    fn clear(&mut self) {
        self.field_type = 0;
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TunnelEncapSubTLVUnknown {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TunnelEncapSubTLVUnknown {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TunnelEncapTLV {
    // message fields
    pub field_type: u32,
    pub tlvs: ::protobuf::RepeatedField<::protobuf::well_known_types::Any>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TunnelEncapTLV {
    fn default() -> &'a TunnelEncapTLV {
        <TunnelEncapTLV as ::protobuf::Message>::default_instance()
    }
}

impl TunnelEncapTLV {
    pub fn new() -> TunnelEncapTLV {
        ::std::default::Default::default()
    }

    // uint32 type = 1;


    pub fn get_field_type(&self) -> u32 {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = 0;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: u32) {
        self.field_type = v;
    }

    // repeated .google.protobuf.Any tlvs = 2;


    pub fn get_tlvs(&self) -> &[::protobuf::well_known_types::Any] {
        &self.tlvs
    }
    pub fn clear_tlvs(&mut self) {
        self.tlvs.clear();
    }

    // Param is passed by value, moved
    pub fn set_tlvs(&mut self, v: ::protobuf::RepeatedField<::protobuf::well_known_types::Any>) {
        self.tlvs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tlvs(&mut self) -> &mut ::protobuf::RepeatedField<::protobuf::well_known_types::Any> {
        &mut self.tlvs
    }

    // Take field
    pub fn take_tlvs(&mut self) -> ::protobuf::RepeatedField<::protobuf::well_known_types::Any> {
        ::std::mem::replace(&mut self.tlvs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TunnelEncapTLV {
    fn is_initialized(&self) -> bool {
        for v in &self.tlvs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.field_type = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tlvs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != 0 {
            my_size += ::protobuf::rt::value_size(1, self.field_type, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.tlvs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != 0 {
            os.write_uint32(1, self.field_type)?;
        }
        for v in &self.tlvs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TunnelEncapTLV {
        TunnelEncapTLV::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "type",
                    |m: &TunnelEncapTLV| { &m.field_type },
                    |m: &mut TunnelEncapTLV| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                    "tlvs",
                    |m: &TunnelEncapTLV| { &m.tlvs },
                    |m: &mut TunnelEncapTLV| { &mut m.tlvs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TunnelEncapTLV>(
                    "TunnelEncapTLV",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TunnelEncapTLV {
        static mut instance: ::protobuf::lazy::Lazy<TunnelEncapTLV> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TunnelEncapTLV,
        };
        unsafe {
            instance.get(TunnelEncapTLV::new)
        }
    }
}

impl ::protobuf::Clear for TunnelEncapTLV {
    fn clear(&mut self) {
        self.field_type = 0;
        self.tlvs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TunnelEncapTLV {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TunnelEncapTLV {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TunnelEncapAttribute {
    // message fields
    pub tlvs: ::protobuf::RepeatedField<TunnelEncapTLV>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TunnelEncapAttribute {
    fn default() -> &'a TunnelEncapAttribute {
        <TunnelEncapAttribute as ::protobuf::Message>::default_instance()
    }
}

impl TunnelEncapAttribute {
    pub fn new() -> TunnelEncapAttribute {
        ::std::default::Default::default()
    }

    // repeated .gobgpapi.TunnelEncapTLV tlvs = 1;


    pub fn get_tlvs(&self) -> &[TunnelEncapTLV] {
        &self.tlvs
    }
    pub fn clear_tlvs(&mut self) {
        self.tlvs.clear();
    }

    // Param is passed by value, moved
    pub fn set_tlvs(&mut self, v: ::protobuf::RepeatedField<TunnelEncapTLV>) {
        self.tlvs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tlvs(&mut self) -> &mut ::protobuf::RepeatedField<TunnelEncapTLV> {
        &mut self.tlvs
    }

    // Take field
    pub fn take_tlvs(&mut self) -> ::protobuf::RepeatedField<TunnelEncapTLV> {
        ::std::mem::replace(&mut self.tlvs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TunnelEncapAttribute {
    fn is_initialized(&self) -> bool {
        for v in &self.tlvs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tlvs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.tlvs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.tlvs {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TunnelEncapAttribute {
        TunnelEncapAttribute::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TunnelEncapTLV>>(
                    "tlvs",
                    |m: &TunnelEncapAttribute| { &m.tlvs },
                    |m: &mut TunnelEncapAttribute| { &mut m.tlvs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TunnelEncapAttribute>(
                    "TunnelEncapAttribute",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TunnelEncapAttribute {
        static mut instance: ::protobuf::lazy::Lazy<TunnelEncapAttribute> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TunnelEncapAttribute,
        };
        unsafe {
            instance.get(TunnelEncapAttribute::new)
        }
    }
}

impl ::protobuf::Clear for TunnelEncapAttribute {
    fn clear(&mut self) {
        self.tlvs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TunnelEncapAttribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TunnelEncapAttribute {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IPv6AddressSpecificExtended {
    // message fields
    pub is_transitive: bool,
    pub sub_type: u32,
    pub address: ::std::string::String,
    pub local_admin: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IPv6AddressSpecificExtended {
    fn default() -> &'a IPv6AddressSpecificExtended {
        <IPv6AddressSpecificExtended as ::protobuf::Message>::default_instance()
    }
}

impl IPv6AddressSpecificExtended {
    pub fn new() -> IPv6AddressSpecificExtended {
        ::std::default::Default::default()
    }

    // bool is_transitive = 1;


    pub fn get_is_transitive(&self) -> bool {
        self.is_transitive
    }
    pub fn clear_is_transitive(&mut self) {
        self.is_transitive = false;
    }

    // Param is passed by value, moved
    pub fn set_is_transitive(&mut self, v: bool) {
        self.is_transitive = v;
    }

    // uint32 sub_type = 2;


    pub fn get_sub_type(&self) -> u32 {
        self.sub_type
    }
    pub fn clear_sub_type(&mut self) {
        self.sub_type = 0;
    }

    // Param is passed by value, moved
    pub fn set_sub_type(&mut self, v: u32) {
        self.sub_type = v;
    }

    // string address = 3;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // uint32 local_admin = 4;


    pub fn get_local_admin(&self) -> u32 {
        self.local_admin
    }
    pub fn clear_local_admin(&mut self) {
        self.local_admin = 0;
    }

    // Param is passed by value, moved
    pub fn set_local_admin(&mut self, v: u32) {
        self.local_admin = v;
    }
}

impl ::protobuf::Message for IPv6AddressSpecificExtended {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_transitive = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.sub_type = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.local_admin = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.is_transitive != false {
            my_size += 2;
        }
        if self.sub_type != 0 {
            my_size += ::protobuf::rt::value_size(2, self.sub_type, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.address);
        }
        if self.local_admin != 0 {
            my_size += ::protobuf::rt::value_size(4, self.local_admin, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.is_transitive != false {
            os.write_bool(1, self.is_transitive)?;
        }
        if self.sub_type != 0 {
            os.write_uint32(2, self.sub_type)?;
        }
        if !self.address.is_empty() {
            os.write_string(3, &self.address)?;
        }
        if self.local_admin != 0 {
            os.write_uint32(4, self.local_admin)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IPv6AddressSpecificExtended {
        IPv6AddressSpecificExtended::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_transitive",
                    |m: &IPv6AddressSpecificExtended| { &m.is_transitive },
                    |m: &mut IPv6AddressSpecificExtended| { &mut m.is_transitive },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "sub_type",
                    |m: &IPv6AddressSpecificExtended| { &m.sub_type },
                    |m: &mut IPv6AddressSpecificExtended| { &mut m.sub_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "address",
                    |m: &IPv6AddressSpecificExtended| { &m.address },
                    |m: &mut IPv6AddressSpecificExtended| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "local_admin",
                    |m: &IPv6AddressSpecificExtended| { &m.local_admin },
                    |m: &mut IPv6AddressSpecificExtended| { &mut m.local_admin },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<IPv6AddressSpecificExtended>(
                    "IPv6AddressSpecificExtended",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static IPv6AddressSpecificExtended {
        static mut instance: ::protobuf::lazy::Lazy<IPv6AddressSpecificExtended> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IPv6AddressSpecificExtended,
        };
        unsafe {
            instance.get(IPv6AddressSpecificExtended::new)
        }
    }
}

impl ::protobuf::Clear for IPv6AddressSpecificExtended {
    fn clear(&mut self) {
        self.is_transitive = false;
        self.sub_type = 0;
        self.address.clear();
        self.local_admin = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IPv6AddressSpecificExtended {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IPv6AddressSpecificExtended {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RedirectIPv6AddressSpecificExtended {
    // message fields
    pub address: ::std::string::String,
    pub local_admin: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RedirectIPv6AddressSpecificExtended {
    fn default() -> &'a RedirectIPv6AddressSpecificExtended {
        <RedirectIPv6AddressSpecificExtended as ::protobuf::Message>::default_instance()
    }
}

impl RedirectIPv6AddressSpecificExtended {
    pub fn new() -> RedirectIPv6AddressSpecificExtended {
        ::std::default::Default::default()
    }

    // string address = 1;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // uint32 local_admin = 2;


    pub fn get_local_admin(&self) -> u32 {
        self.local_admin
    }
    pub fn clear_local_admin(&mut self) {
        self.local_admin = 0;
    }

    // Param is passed by value, moved
    pub fn set_local_admin(&mut self, v: u32) {
        self.local_admin = v;
    }
}

impl ::protobuf::Message for RedirectIPv6AddressSpecificExtended {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.local_admin = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if self.local_admin != 0 {
            my_size += ::protobuf::rt::value_size(2, self.local_admin, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if self.local_admin != 0 {
            os.write_uint32(2, self.local_admin)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RedirectIPv6AddressSpecificExtended {
        RedirectIPv6AddressSpecificExtended::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "address",
                    |m: &RedirectIPv6AddressSpecificExtended| { &m.address },
                    |m: &mut RedirectIPv6AddressSpecificExtended| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "local_admin",
                    |m: &RedirectIPv6AddressSpecificExtended| { &m.local_admin },
                    |m: &mut RedirectIPv6AddressSpecificExtended| { &mut m.local_admin },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RedirectIPv6AddressSpecificExtended>(
                    "RedirectIPv6AddressSpecificExtended",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RedirectIPv6AddressSpecificExtended {
        static mut instance: ::protobuf::lazy::Lazy<RedirectIPv6AddressSpecificExtended> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RedirectIPv6AddressSpecificExtended,
        };
        unsafe {
            instance.get(RedirectIPv6AddressSpecificExtended::new)
        }
    }
}

impl ::protobuf::Clear for RedirectIPv6AddressSpecificExtended {
    fn clear(&mut self) {
        self.address.clear();
        self.local_admin = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RedirectIPv6AddressSpecificExtended {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RedirectIPv6AddressSpecificExtended {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IP6ExtendedCommunitiesAttribute {
    // message fields
    pub communities: ::protobuf::RepeatedField<::protobuf::well_known_types::Any>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IP6ExtendedCommunitiesAttribute {
    fn default() -> &'a IP6ExtendedCommunitiesAttribute {
        <IP6ExtendedCommunitiesAttribute as ::protobuf::Message>::default_instance()
    }
}

impl IP6ExtendedCommunitiesAttribute {
    pub fn new() -> IP6ExtendedCommunitiesAttribute {
        ::std::default::Default::default()
    }

    // repeated .google.protobuf.Any communities = 1;


    pub fn get_communities(&self) -> &[::protobuf::well_known_types::Any] {
        &self.communities
    }
    pub fn clear_communities(&mut self) {
        self.communities.clear();
    }

    // Param is passed by value, moved
    pub fn set_communities(&mut self, v: ::protobuf::RepeatedField<::protobuf::well_known_types::Any>) {
        self.communities = v;
    }

    // Mutable pointer to the field.
    pub fn mut_communities(&mut self) -> &mut ::protobuf::RepeatedField<::protobuf::well_known_types::Any> {
        &mut self.communities
    }

    // Take field
    pub fn take_communities(&mut self) -> ::protobuf::RepeatedField<::protobuf::well_known_types::Any> {
        ::std::mem::replace(&mut self.communities, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for IP6ExtendedCommunitiesAttribute {
    fn is_initialized(&self) -> bool {
        for v in &self.communities {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.communities)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.communities {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.communities {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IP6ExtendedCommunitiesAttribute {
        IP6ExtendedCommunitiesAttribute::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                    "communities",
                    |m: &IP6ExtendedCommunitiesAttribute| { &m.communities },
                    |m: &mut IP6ExtendedCommunitiesAttribute| { &mut m.communities },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<IP6ExtendedCommunitiesAttribute>(
                    "IP6ExtendedCommunitiesAttribute",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static IP6ExtendedCommunitiesAttribute {
        static mut instance: ::protobuf::lazy::Lazy<IP6ExtendedCommunitiesAttribute> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IP6ExtendedCommunitiesAttribute,
        };
        unsafe {
            instance.get(IP6ExtendedCommunitiesAttribute::new)
        }
    }
}

impl ::protobuf::Clear for IP6ExtendedCommunitiesAttribute {
    fn clear(&mut self) {
        self.communities.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IP6ExtendedCommunitiesAttribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IP6ExtendedCommunitiesAttribute {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AigpTLVIGPMetric {
    // message fields
    pub metric: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AigpTLVIGPMetric {
    fn default() -> &'a AigpTLVIGPMetric {
        <AigpTLVIGPMetric as ::protobuf::Message>::default_instance()
    }
}

impl AigpTLVIGPMetric {
    pub fn new() -> AigpTLVIGPMetric {
        ::std::default::Default::default()
    }

    // uint64 metric = 1;


    pub fn get_metric(&self) -> u64 {
        self.metric
    }
    pub fn clear_metric(&mut self) {
        self.metric = 0;
    }

    // Param is passed by value, moved
    pub fn set_metric(&mut self, v: u64) {
        self.metric = v;
    }
}

impl ::protobuf::Message for AigpTLVIGPMetric {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.metric = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.metric != 0 {
            my_size += ::protobuf::rt::value_size(1, self.metric, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.metric != 0 {
            os.write_uint64(1, self.metric)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AigpTLVIGPMetric {
        AigpTLVIGPMetric::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "metric",
                    |m: &AigpTLVIGPMetric| { &m.metric },
                    |m: &mut AigpTLVIGPMetric| { &mut m.metric },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AigpTLVIGPMetric>(
                    "AigpTLVIGPMetric",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AigpTLVIGPMetric {
        static mut instance: ::protobuf::lazy::Lazy<AigpTLVIGPMetric> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AigpTLVIGPMetric,
        };
        unsafe {
            instance.get(AigpTLVIGPMetric::new)
        }
    }
}

impl ::protobuf::Clear for AigpTLVIGPMetric {
    fn clear(&mut self) {
        self.metric = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AigpTLVIGPMetric {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AigpTLVIGPMetric {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AigpTLVUnknown {
    // message fields
    pub field_type: u32,
    pub value: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AigpTLVUnknown {
    fn default() -> &'a AigpTLVUnknown {
        <AigpTLVUnknown as ::protobuf::Message>::default_instance()
    }
}

impl AigpTLVUnknown {
    pub fn new() -> AigpTLVUnknown {
        ::std::default::Default::default()
    }

    // uint32 type = 1;


    pub fn get_field_type(&self) -> u32 {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = 0;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: u32) {
        self.field_type = v;
    }

    // bytes value = 2;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for AigpTLVUnknown {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.field_type = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != 0 {
            my_size += ::protobuf::rt::value_size(1, self.field_type, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != 0 {
            os.write_uint32(1, self.field_type)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(2, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AigpTLVUnknown {
        AigpTLVUnknown::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "type",
                    |m: &AigpTLVUnknown| { &m.field_type },
                    |m: &mut AigpTLVUnknown| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "value",
                    |m: &AigpTLVUnknown| { &m.value },
                    |m: &mut AigpTLVUnknown| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AigpTLVUnknown>(
                    "AigpTLVUnknown",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AigpTLVUnknown {
        static mut instance: ::protobuf::lazy::Lazy<AigpTLVUnknown> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AigpTLVUnknown,
        };
        unsafe {
            instance.get(AigpTLVUnknown::new)
        }
    }
}

impl ::protobuf::Clear for AigpTLVUnknown {
    fn clear(&mut self) {
        self.field_type = 0;
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AigpTLVUnknown {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AigpTLVUnknown {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AigpAttribute {
    // message fields
    pub tlvs: ::protobuf::RepeatedField<::protobuf::well_known_types::Any>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AigpAttribute {
    fn default() -> &'a AigpAttribute {
        <AigpAttribute as ::protobuf::Message>::default_instance()
    }
}

impl AigpAttribute {
    pub fn new() -> AigpAttribute {
        ::std::default::Default::default()
    }

    // repeated .google.protobuf.Any tlvs = 1;


    pub fn get_tlvs(&self) -> &[::protobuf::well_known_types::Any] {
        &self.tlvs
    }
    pub fn clear_tlvs(&mut self) {
        self.tlvs.clear();
    }

    // Param is passed by value, moved
    pub fn set_tlvs(&mut self, v: ::protobuf::RepeatedField<::protobuf::well_known_types::Any>) {
        self.tlvs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tlvs(&mut self) -> &mut ::protobuf::RepeatedField<::protobuf::well_known_types::Any> {
        &mut self.tlvs
    }

    // Take field
    pub fn take_tlvs(&mut self) -> ::protobuf::RepeatedField<::protobuf::well_known_types::Any> {
        ::std::mem::replace(&mut self.tlvs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AigpAttribute {
    fn is_initialized(&self) -> bool {
        for v in &self.tlvs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tlvs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.tlvs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.tlvs {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AigpAttribute {
        AigpAttribute::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                    "tlvs",
                    |m: &AigpAttribute| { &m.tlvs },
                    |m: &mut AigpAttribute| { &mut m.tlvs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AigpAttribute>(
                    "AigpAttribute",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AigpAttribute {
        static mut instance: ::protobuf::lazy::Lazy<AigpAttribute> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AigpAttribute,
        };
        unsafe {
            instance.get(AigpAttribute::new)
        }
    }
}

impl ::protobuf::Clear for AigpAttribute {
    fn clear(&mut self) {
        self.tlvs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AigpAttribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AigpAttribute {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LargeCommunity {
    // message fields
    pub global_admin: u32,
    pub local_data1: u32,
    pub local_data2: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LargeCommunity {
    fn default() -> &'a LargeCommunity {
        <LargeCommunity as ::protobuf::Message>::default_instance()
    }
}

impl LargeCommunity {
    pub fn new() -> LargeCommunity {
        ::std::default::Default::default()
    }

    // uint32 global_admin = 1;


    pub fn get_global_admin(&self) -> u32 {
        self.global_admin
    }
    pub fn clear_global_admin(&mut self) {
        self.global_admin = 0;
    }

    // Param is passed by value, moved
    pub fn set_global_admin(&mut self, v: u32) {
        self.global_admin = v;
    }

    // uint32 local_data1 = 2;


    pub fn get_local_data1(&self) -> u32 {
        self.local_data1
    }
    pub fn clear_local_data1(&mut self) {
        self.local_data1 = 0;
    }

    // Param is passed by value, moved
    pub fn set_local_data1(&mut self, v: u32) {
        self.local_data1 = v;
    }

    // uint32 local_data2 = 3;


    pub fn get_local_data2(&self) -> u32 {
        self.local_data2
    }
    pub fn clear_local_data2(&mut self) {
        self.local_data2 = 0;
    }

    // Param is passed by value, moved
    pub fn set_local_data2(&mut self, v: u32) {
        self.local_data2 = v;
    }
}

impl ::protobuf::Message for LargeCommunity {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.global_admin = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.local_data1 = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.local_data2 = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.global_admin != 0 {
            my_size += ::protobuf::rt::value_size(1, self.global_admin, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.local_data1 != 0 {
            my_size += ::protobuf::rt::value_size(2, self.local_data1, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.local_data2 != 0 {
            my_size += ::protobuf::rt::value_size(3, self.local_data2, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.global_admin != 0 {
            os.write_uint32(1, self.global_admin)?;
        }
        if self.local_data1 != 0 {
            os.write_uint32(2, self.local_data1)?;
        }
        if self.local_data2 != 0 {
            os.write_uint32(3, self.local_data2)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LargeCommunity {
        LargeCommunity::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "global_admin",
                    |m: &LargeCommunity| { &m.global_admin },
                    |m: &mut LargeCommunity| { &mut m.global_admin },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "local_data1",
                    |m: &LargeCommunity| { &m.local_data1 },
                    |m: &mut LargeCommunity| { &mut m.local_data1 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "local_data2",
                    |m: &LargeCommunity| { &m.local_data2 },
                    |m: &mut LargeCommunity| { &mut m.local_data2 },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LargeCommunity>(
                    "LargeCommunity",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LargeCommunity {
        static mut instance: ::protobuf::lazy::Lazy<LargeCommunity> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LargeCommunity,
        };
        unsafe {
            instance.get(LargeCommunity::new)
        }
    }
}

impl ::protobuf::Clear for LargeCommunity {
    fn clear(&mut self) {
        self.global_admin = 0;
        self.local_data1 = 0;
        self.local_data2 = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LargeCommunity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LargeCommunity {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LargeCommunitiesAttribute {
    // message fields
    pub communities: ::protobuf::RepeatedField<LargeCommunity>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LargeCommunitiesAttribute {
    fn default() -> &'a LargeCommunitiesAttribute {
        <LargeCommunitiesAttribute as ::protobuf::Message>::default_instance()
    }
}

impl LargeCommunitiesAttribute {
    pub fn new() -> LargeCommunitiesAttribute {
        ::std::default::Default::default()
    }

    // repeated .gobgpapi.LargeCommunity communities = 1;


    pub fn get_communities(&self) -> &[LargeCommunity] {
        &self.communities
    }
    pub fn clear_communities(&mut self) {
        self.communities.clear();
    }

    // Param is passed by value, moved
    pub fn set_communities(&mut self, v: ::protobuf::RepeatedField<LargeCommunity>) {
        self.communities = v;
    }

    // Mutable pointer to the field.
    pub fn mut_communities(&mut self) -> &mut ::protobuf::RepeatedField<LargeCommunity> {
        &mut self.communities
    }

    // Take field
    pub fn take_communities(&mut self) -> ::protobuf::RepeatedField<LargeCommunity> {
        ::std::mem::replace(&mut self.communities, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for LargeCommunitiesAttribute {
    fn is_initialized(&self) -> bool {
        for v in &self.communities {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.communities)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.communities {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.communities {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LargeCommunitiesAttribute {
        LargeCommunitiesAttribute::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LargeCommunity>>(
                    "communities",
                    |m: &LargeCommunitiesAttribute| { &m.communities },
                    |m: &mut LargeCommunitiesAttribute| { &mut m.communities },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LargeCommunitiesAttribute>(
                    "LargeCommunitiesAttribute",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LargeCommunitiesAttribute {
        static mut instance: ::protobuf::lazy::Lazy<LargeCommunitiesAttribute> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LargeCommunitiesAttribute,
        };
        unsafe {
            instance.get(LargeCommunitiesAttribute::new)
        }
    }
}

impl ::protobuf::Clear for LargeCommunitiesAttribute {
    fn clear(&mut self) {
        self.communities.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LargeCommunitiesAttribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LargeCommunitiesAttribute {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LsNodeFlags {
    // message fields
    pub overload: bool,
    pub attached: bool,
    pub external: bool,
    pub abr: bool,
    pub router: bool,
    pub v6: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LsNodeFlags {
    fn default() -> &'a LsNodeFlags {
        <LsNodeFlags as ::protobuf::Message>::default_instance()
    }
}

impl LsNodeFlags {
    pub fn new() -> LsNodeFlags {
        ::std::default::Default::default()
    }

    // bool overload = 1;


    pub fn get_overload(&self) -> bool {
        self.overload
    }
    pub fn clear_overload(&mut self) {
        self.overload = false;
    }

    // Param is passed by value, moved
    pub fn set_overload(&mut self, v: bool) {
        self.overload = v;
    }

    // bool attached = 2;


    pub fn get_attached(&self) -> bool {
        self.attached
    }
    pub fn clear_attached(&mut self) {
        self.attached = false;
    }

    // Param is passed by value, moved
    pub fn set_attached(&mut self, v: bool) {
        self.attached = v;
    }

    // bool external = 3;


    pub fn get_external(&self) -> bool {
        self.external
    }
    pub fn clear_external(&mut self) {
        self.external = false;
    }

    // Param is passed by value, moved
    pub fn set_external(&mut self, v: bool) {
        self.external = v;
    }

    // bool abr = 4;


    pub fn get_abr(&self) -> bool {
        self.abr
    }
    pub fn clear_abr(&mut self) {
        self.abr = false;
    }

    // Param is passed by value, moved
    pub fn set_abr(&mut self, v: bool) {
        self.abr = v;
    }

    // bool router = 5;


    pub fn get_router(&self) -> bool {
        self.router
    }
    pub fn clear_router(&mut self) {
        self.router = false;
    }

    // Param is passed by value, moved
    pub fn set_router(&mut self, v: bool) {
        self.router = v;
    }

    // bool v6 = 6;


    pub fn get_v6(&self) -> bool {
        self.v6
    }
    pub fn clear_v6(&mut self) {
        self.v6 = false;
    }

    // Param is passed by value, moved
    pub fn set_v6(&mut self, v: bool) {
        self.v6 = v;
    }
}

impl ::protobuf::Message for LsNodeFlags {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.overload = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.attached = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.external = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.abr = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.router = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.v6 = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.overload != false {
            my_size += 2;
        }
        if self.attached != false {
            my_size += 2;
        }
        if self.external != false {
            my_size += 2;
        }
        if self.abr != false {
            my_size += 2;
        }
        if self.router != false {
            my_size += 2;
        }
        if self.v6 != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.overload != false {
            os.write_bool(1, self.overload)?;
        }
        if self.attached != false {
            os.write_bool(2, self.attached)?;
        }
        if self.external != false {
            os.write_bool(3, self.external)?;
        }
        if self.abr != false {
            os.write_bool(4, self.abr)?;
        }
        if self.router != false {
            os.write_bool(5, self.router)?;
        }
        if self.v6 != false {
            os.write_bool(6, self.v6)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LsNodeFlags {
        LsNodeFlags::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "overload",
                    |m: &LsNodeFlags| { &m.overload },
                    |m: &mut LsNodeFlags| { &mut m.overload },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "attached",
                    |m: &LsNodeFlags| { &m.attached },
                    |m: &mut LsNodeFlags| { &mut m.attached },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "external",
                    |m: &LsNodeFlags| { &m.external },
                    |m: &mut LsNodeFlags| { &mut m.external },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "abr",
                    |m: &LsNodeFlags| { &m.abr },
                    |m: &mut LsNodeFlags| { &mut m.abr },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "router",
                    |m: &LsNodeFlags| { &m.router },
                    |m: &mut LsNodeFlags| { &mut m.router },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "v6",
                    |m: &LsNodeFlags| { &m.v6 },
                    |m: &mut LsNodeFlags| { &mut m.v6 },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LsNodeFlags>(
                    "LsNodeFlags",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LsNodeFlags {
        static mut instance: ::protobuf::lazy::Lazy<LsNodeFlags> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LsNodeFlags,
        };
        unsafe {
            instance.get(LsNodeFlags::new)
        }
    }
}

impl ::protobuf::Clear for LsNodeFlags {
    fn clear(&mut self) {
        self.overload = false;
        self.attached = false;
        self.external = false;
        self.abr = false;
        self.router = false;
        self.v6 = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LsNodeFlags {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LsNodeFlags {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LsIGPFlags {
    // message fields
    pub down: bool,
    pub no_unicast: bool,
    pub local_address: bool,
    pub propagate_nssa: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LsIGPFlags {
    fn default() -> &'a LsIGPFlags {
        <LsIGPFlags as ::protobuf::Message>::default_instance()
    }
}

impl LsIGPFlags {
    pub fn new() -> LsIGPFlags {
        ::std::default::Default::default()
    }

    // bool down = 1;


    pub fn get_down(&self) -> bool {
        self.down
    }
    pub fn clear_down(&mut self) {
        self.down = false;
    }

    // Param is passed by value, moved
    pub fn set_down(&mut self, v: bool) {
        self.down = v;
    }

    // bool no_unicast = 2;


    pub fn get_no_unicast(&self) -> bool {
        self.no_unicast
    }
    pub fn clear_no_unicast(&mut self) {
        self.no_unicast = false;
    }

    // Param is passed by value, moved
    pub fn set_no_unicast(&mut self, v: bool) {
        self.no_unicast = v;
    }

    // bool local_address = 3;


    pub fn get_local_address(&self) -> bool {
        self.local_address
    }
    pub fn clear_local_address(&mut self) {
        self.local_address = false;
    }

    // Param is passed by value, moved
    pub fn set_local_address(&mut self, v: bool) {
        self.local_address = v;
    }

    // bool propagate_nssa = 4;


    pub fn get_propagate_nssa(&self) -> bool {
        self.propagate_nssa
    }
    pub fn clear_propagate_nssa(&mut self) {
        self.propagate_nssa = false;
    }

    // Param is passed by value, moved
    pub fn set_propagate_nssa(&mut self, v: bool) {
        self.propagate_nssa = v;
    }
}

impl ::protobuf::Message for LsIGPFlags {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.down = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.no_unicast = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.local_address = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.propagate_nssa = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.down != false {
            my_size += 2;
        }
        if self.no_unicast != false {
            my_size += 2;
        }
        if self.local_address != false {
            my_size += 2;
        }
        if self.propagate_nssa != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.down != false {
            os.write_bool(1, self.down)?;
        }
        if self.no_unicast != false {
            os.write_bool(2, self.no_unicast)?;
        }
        if self.local_address != false {
            os.write_bool(3, self.local_address)?;
        }
        if self.propagate_nssa != false {
            os.write_bool(4, self.propagate_nssa)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LsIGPFlags {
        LsIGPFlags::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "down",
                    |m: &LsIGPFlags| { &m.down },
                    |m: &mut LsIGPFlags| { &mut m.down },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "no_unicast",
                    |m: &LsIGPFlags| { &m.no_unicast },
                    |m: &mut LsIGPFlags| { &mut m.no_unicast },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "local_address",
                    |m: &LsIGPFlags| { &m.local_address },
                    |m: &mut LsIGPFlags| { &mut m.local_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "propagate_nssa",
                    |m: &LsIGPFlags| { &m.propagate_nssa },
                    |m: &mut LsIGPFlags| { &mut m.propagate_nssa },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LsIGPFlags>(
                    "LsIGPFlags",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LsIGPFlags {
        static mut instance: ::protobuf::lazy::Lazy<LsIGPFlags> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LsIGPFlags,
        };
        unsafe {
            instance.get(LsIGPFlags::new)
        }
    }
}

impl ::protobuf::Clear for LsIGPFlags {
    fn clear(&mut self) {
        self.down = false;
        self.no_unicast = false;
        self.local_address = false;
        self.propagate_nssa = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LsIGPFlags {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LsIGPFlags {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LsSrRange {
    // message fields
    pub begin: u32,
    pub end: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LsSrRange {
    fn default() -> &'a LsSrRange {
        <LsSrRange as ::protobuf::Message>::default_instance()
    }
}

impl LsSrRange {
    pub fn new() -> LsSrRange {
        ::std::default::Default::default()
    }

    // uint32 begin = 1;


    pub fn get_begin(&self) -> u32 {
        self.begin
    }
    pub fn clear_begin(&mut self) {
        self.begin = 0;
    }

    // Param is passed by value, moved
    pub fn set_begin(&mut self, v: u32) {
        self.begin = v;
    }

    // uint32 end = 2;


    pub fn get_end(&self) -> u32 {
        self.end
    }
    pub fn clear_end(&mut self) {
        self.end = 0;
    }

    // Param is passed by value, moved
    pub fn set_end(&mut self, v: u32) {
        self.end = v;
    }
}

impl ::protobuf::Message for LsSrRange {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.begin = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.end = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.begin != 0 {
            my_size += ::protobuf::rt::value_size(1, self.begin, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.end != 0 {
            my_size += ::protobuf::rt::value_size(2, self.end, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.begin != 0 {
            os.write_uint32(1, self.begin)?;
        }
        if self.end != 0 {
            os.write_uint32(2, self.end)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LsSrRange {
        LsSrRange::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "begin",
                    |m: &LsSrRange| { &m.begin },
                    |m: &mut LsSrRange| { &mut m.begin },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "end",
                    |m: &LsSrRange| { &m.end },
                    |m: &mut LsSrRange| { &mut m.end },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LsSrRange>(
                    "LsSrRange",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LsSrRange {
        static mut instance: ::protobuf::lazy::Lazy<LsSrRange> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LsSrRange,
        };
        unsafe {
            instance.get(LsSrRange::new)
        }
    }
}

impl ::protobuf::Clear for LsSrRange {
    fn clear(&mut self) {
        self.begin = 0;
        self.end = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LsSrRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LsSrRange {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LsSrCapabilities {
    // message fields
    pub ipv4_supported: bool,
    pub ipv6_supported: bool,
    pub ranges: ::protobuf::RepeatedField<LsSrRange>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LsSrCapabilities {
    fn default() -> &'a LsSrCapabilities {
        <LsSrCapabilities as ::protobuf::Message>::default_instance()
    }
}

impl LsSrCapabilities {
    pub fn new() -> LsSrCapabilities {
        ::std::default::Default::default()
    }

    // bool ipv4_supported = 1;


    pub fn get_ipv4_supported(&self) -> bool {
        self.ipv4_supported
    }
    pub fn clear_ipv4_supported(&mut self) {
        self.ipv4_supported = false;
    }

    // Param is passed by value, moved
    pub fn set_ipv4_supported(&mut self, v: bool) {
        self.ipv4_supported = v;
    }

    // bool ipv6_supported = 2;


    pub fn get_ipv6_supported(&self) -> bool {
        self.ipv6_supported
    }
    pub fn clear_ipv6_supported(&mut self) {
        self.ipv6_supported = false;
    }

    // Param is passed by value, moved
    pub fn set_ipv6_supported(&mut self, v: bool) {
        self.ipv6_supported = v;
    }

    // repeated .gobgpapi.LsSrRange ranges = 3;


    pub fn get_ranges(&self) -> &[LsSrRange] {
        &self.ranges
    }
    pub fn clear_ranges(&mut self) {
        self.ranges.clear();
    }

    // Param is passed by value, moved
    pub fn set_ranges(&mut self, v: ::protobuf::RepeatedField<LsSrRange>) {
        self.ranges = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ranges(&mut self) -> &mut ::protobuf::RepeatedField<LsSrRange> {
        &mut self.ranges
    }

    // Take field
    pub fn take_ranges(&mut self) -> ::protobuf::RepeatedField<LsSrRange> {
        ::std::mem::replace(&mut self.ranges, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for LsSrCapabilities {
    fn is_initialized(&self) -> bool {
        for v in &self.ranges {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ipv4_supported = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ipv6_supported = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ranges)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.ipv4_supported != false {
            my_size += 2;
        }
        if self.ipv6_supported != false {
            my_size += 2;
        }
        for value in &self.ranges {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.ipv4_supported != false {
            os.write_bool(1, self.ipv4_supported)?;
        }
        if self.ipv6_supported != false {
            os.write_bool(2, self.ipv6_supported)?;
        }
        for v in &self.ranges {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LsSrCapabilities {
        LsSrCapabilities::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "ipv4_supported",
                    |m: &LsSrCapabilities| { &m.ipv4_supported },
                    |m: &mut LsSrCapabilities| { &mut m.ipv4_supported },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "ipv6_supported",
                    |m: &LsSrCapabilities| { &m.ipv6_supported },
                    |m: &mut LsSrCapabilities| { &mut m.ipv6_supported },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LsSrRange>>(
                    "ranges",
                    |m: &LsSrCapabilities| { &m.ranges },
                    |m: &mut LsSrCapabilities| { &mut m.ranges },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LsSrCapabilities>(
                    "LsSrCapabilities",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LsSrCapabilities {
        static mut instance: ::protobuf::lazy::Lazy<LsSrCapabilities> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LsSrCapabilities,
        };
        unsafe {
            instance.get(LsSrCapabilities::new)
        }
    }
}

impl ::protobuf::Clear for LsSrCapabilities {
    fn clear(&mut self) {
        self.ipv4_supported = false;
        self.ipv6_supported = false;
        self.ranges.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LsSrCapabilities {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LsSrCapabilities {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LsSrLocalBlock {
    // message fields
    pub ranges: ::protobuf::RepeatedField<LsSrRange>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LsSrLocalBlock {
    fn default() -> &'a LsSrLocalBlock {
        <LsSrLocalBlock as ::protobuf::Message>::default_instance()
    }
}

impl LsSrLocalBlock {
    pub fn new() -> LsSrLocalBlock {
        ::std::default::Default::default()
    }

    // repeated .gobgpapi.LsSrRange ranges = 1;


    pub fn get_ranges(&self) -> &[LsSrRange] {
        &self.ranges
    }
    pub fn clear_ranges(&mut self) {
        self.ranges.clear();
    }

    // Param is passed by value, moved
    pub fn set_ranges(&mut self, v: ::protobuf::RepeatedField<LsSrRange>) {
        self.ranges = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ranges(&mut self) -> &mut ::protobuf::RepeatedField<LsSrRange> {
        &mut self.ranges
    }

    // Take field
    pub fn take_ranges(&mut self) -> ::protobuf::RepeatedField<LsSrRange> {
        ::std::mem::replace(&mut self.ranges, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for LsSrLocalBlock {
    fn is_initialized(&self) -> bool {
        for v in &self.ranges {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ranges)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.ranges {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.ranges {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LsSrLocalBlock {
        LsSrLocalBlock::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LsSrRange>>(
                    "ranges",
                    |m: &LsSrLocalBlock| { &m.ranges },
                    |m: &mut LsSrLocalBlock| { &mut m.ranges },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LsSrLocalBlock>(
                    "LsSrLocalBlock",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LsSrLocalBlock {
        static mut instance: ::protobuf::lazy::Lazy<LsSrLocalBlock> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LsSrLocalBlock,
        };
        unsafe {
            instance.get(LsSrLocalBlock::new)
        }
    }
}

impl ::protobuf::Clear for LsSrLocalBlock {
    fn clear(&mut self) {
        self.ranges.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LsSrLocalBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LsSrLocalBlock {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LsAttributeNode {
    // message fields
    pub name: ::std::string::String,
    pub flags: ::protobuf::SingularPtrField<LsNodeFlags>,
    pub local_router_id: ::std::string::String,
    pub local_router_id_v6: ::std::string::String,
    pub isis_area: ::std::vec::Vec<u8>,
    pub opaque: ::std::vec::Vec<u8>,
    pub sr_capabilities: ::protobuf::SingularPtrField<LsSrCapabilities>,
    pub sr_algorithms: ::std::vec::Vec<u8>,
    pub sr_local_block: ::protobuf::SingularPtrField<LsSrLocalBlock>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LsAttributeNode {
    fn default() -> &'a LsAttributeNode {
        <LsAttributeNode as ::protobuf::Message>::default_instance()
    }
}

impl LsAttributeNode {
    pub fn new() -> LsAttributeNode {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .gobgpapi.LsNodeFlags flags = 2;


    pub fn get_flags(&self) -> &LsNodeFlags {
        self.flags.as_ref().unwrap_or_else(|| LsNodeFlags::default_instance())
    }
    pub fn clear_flags(&mut self) {
        self.flags.clear();
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: LsNodeFlags) {
        self.flags = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_flags(&mut self) -> &mut LsNodeFlags {
        if self.flags.is_none() {
            self.flags.set_default();
        }
        self.flags.as_mut().unwrap()
    }

    // Take field
    pub fn take_flags(&mut self) -> LsNodeFlags {
        self.flags.take().unwrap_or_else(|| LsNodeFlags::new())
    }

    // string local_router_id = 3;


    pub fn get_local_router_id(&self) -> &str {
        &self.local_router_id
    }
    pub fn clear_local_router_id(&mut self) {
        self.local_router_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_local_router_id(&mut self, v: ::std::string::String) {
        self.local_router_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_local_router_id(&mut self) -> &mut ::std::string::String {
        &mut self.local_router_id
    }

    // Take field
    pub fn take_local_router_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.local_router_id, ::std::string::String::new())
    }

    // string local_router_id_v6 = 4;


    pub fn get_local_router_id_v6(&self) -> &str {
        &self.local_router_id_v6
    }
    pub fn clear_local_router_id_v6(&mut self) {
        self.local_router_id_v6.clear();
    }

    // Param is passed by value, moved
    pub fn set_local_router_id_v6(&mut self, v: ::std::string::String) {
        self.local_router_id_v6 = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_local_router_id_v6(&mut self) -> &mut ::std::string::String {
        &mut self.local_router_id_v6
    }

    // Take field
    pub fn take_local_router_id_v6(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.local_router_id_v6, ::std::string::String::new())
    }

    // bytes isis_area = 5;


    pub fn get_isis_area(&self) -> &[u8] {
        &self.isis_area
    }
    pub fn clear_isis_area(&mut self) {
        self.isis_area.clear();
    }

    // Param is passed by value, moved
    pub fn set_isis_area(&mut self, v: ::std::vec::Vec<u8>) {
        self.isis_area = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_isis_area(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.isis_area
    }

    // Take field
    pub fn take_isis_area(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.isis_area, ::std::vec::Vec::new())
    }

    // bytes opaque = 6;


    pub fn get_opaque(&self) -> &[u8] {
        &self.opaque
    }
    pub fn clear_opaque(&mut self) {
        self.opaque.clear();
    }

    // Param is passed by value, moved
    pub fn set_opaque(&mut self, v: ::std::vec::Vec<u8>) {
        self.opaque = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_opaque(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.opaque
    }

    // Take field
    pub fn take_opaque(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.opaque, ::std::vec::Vec::new())
    }

    // .gobgpapi.LsSrCapabilities sr_capabilities = 7;


    pub fn get_sr_capabilities(&self) -> &LsSrCapabilities {
        self.sr_capabilities.as_ref().unwrap_or_else(|| LsSrCapabilities::default_instance())
    }
    pub fn clear_sr_capabilities(&mut self) {
        self.sr_capabilities.clear();
    }

    pub fn has_sr_capabilities(&self) -> bool {
        self.sr_capabilities.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sr_capabilities(&mut self, v: LsSrCapabilities) {
        self.sr_capabilities = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sr_capabilities(&mut self) -> &mut LsSrCapabilities {
        if self.sr_capabilities.is_none() {
            self.sr_capabilities.set_default();
        }
        self.sr_capabilities.as_mut().unwrap()
    }

    // Take field
    pub fn take_sr_capabilities(&mut self) -> LsSrCapabilities {
        self.sr_capabilities.take().unwrap_or_else(|| LsSrCapabilities::new())
    }

    // bytes sr_algorithms = 8;


    pub fn get_sr_algorithms(&self) -> &[u8] {
        &self.sr_algorithms
    }
    pub fn clear_sr_algorithms(&mut self) {
        self.sr_algorithms.clear();
    }

    // Param is passed by value, moved
    pub fn set_sr_algorithms(&mut self, v: ::std::vec::Vec<u8>) {
        self.sr_algorithms = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sr_algorithms(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.sr_algorithms
    }

    // Take field
    pub fn take_sr_algorithms(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.sr_algorithms, ::std::vec::Vec::new())
    }

    // .gobgpapi.LsSrLocalBlock sr_local_block = 9;


    pub fn get_sr_local_block(&self) -> &LsSrLocalBlock {
        self.sr_local_block.as_ref().unwrap_or_else(|| LsSrLocalBlock::default_instance())
    }
    pub fn clear_sr_local_block(&mut self) {
        self.sr_local_block.clear();
    }

    pub fn has_sr_local_block(&self) -> bool {
        self.sr_local_block.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sr_local_block(&mut self, v: LsSrLocalBlock) {
        self.sr_local_block = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sr_local_block(&mut self) -> &mut LsSrLocalBlock {
        if self.sr_local_block.is_none() {
            self.sr_local_block.set_default();
        }
        self.sr_local_block.as_mut().unwrap()
    }

    // Take field
    pub fn take_sr_local_block(&mut self) -> LsSrLocalBlock {
        self.sr_local_block.take().unwrap_or_else(|| LsSrLocalBlock::new())
    }
}

impl ::protobuf::Message for LsAttributeNode {
    fn is_initialized(&self) -> bool {
        for v in &self.flags {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sr_capabilities {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sr_local_block {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.flags)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.local_router_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.local_router_id_v6)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.isis_area)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.opaque)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sr_capabilities)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.sr_algorithms)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sr_local_block)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let Some(ref v) = self.flags.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.local_router_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.local_router_id);
        }
        if !self.local_router_id_v6.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.local_router_id_v6);
        }
        if !self.isis_area.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.isis_area);
        }
        if !self.opaque.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.opaque);
        }
        if let Some(ref v) = self.sr_capabilities.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.sr_algorithms.is_empty() {
            my_size += ::protobuf::rt::bytes_size(8, &self.sr_algorithms);
        }
        if let Some(ref v) = self.sr_local_block.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let Some(ref v) = self.flags.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.local_router_id.is_empty() {
            os.write_string(3, &self.local_router_id)?;
        }
        if !self.local_router_id_v6.is_empty() {
            os.write_string(4, &self.local_router_id_v6)?;
        }
        if !self.isis_area.is_empty() {
            os.write_bytes(5, &self.isis_area)?;
        }
        if !self.opaque.is_empty() {
            os.write_bytes(6, &self.opaque)?;
        }
        if let Some(ref v) = self.sr_capabilities.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.sr_algorithms.is_empty() {
            os.write_bytes(8, &self.sr_algorithms)?;
        }
        if let Some(ref v) = self.sr_local_block.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LsAttributeNode {
        LsAttributeNode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &LsAttributeNode| { &m.name },
                    |m: &mut LsAttributeNode| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LsNodeFlags>>(
                    "flags",
                    |m: &LsAttributeNode| { &m.flags },
                    |m: &mut LsAttributeNode| { &mut m.flags },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "local_router_id",
                    |m: &LsAttributeNode| { &m.local_router_id },
                    |m: &mut LsAttributeNode| { &mut m.local_router_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "local_router_id_v6",
                    |m: &LsAttributeNode| { &m.local_router_id_v6 },
                    |m: &mut LsAttributeNode| { &mut m.local_router_id_v6 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "isis_area",
                    |m: &LsAttributeNode| { &m.isis_area },
                    |m: &mut LsAttributeNode| { &mut m.isis_area },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "opaque",
                    |m: &LsAttributeNode| { &m.opaque },
                    |m: &mut LsAttributeNode| { &mut m.opaque },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LsSrCapabilities>>(
                    "sr_capabilities",
                    |m: &LsAttributeNode| { &m.sr_capabilities },
                    |m: &mut LsAttributeNode| { &mut m.sr_capabilities },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "sr_algorithms",
                    |m: &LsAttributeNode| { &m.sr_algorithms },
                    |m: &mut LsAttributeNode| { &mut m.sr_algorithms },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LsSrLocalBlock>>(
                    "sr_local_block",
                    |m: &LsAttributeNode| { &m.sr_local_block },
                    |m: &mut LsAttributeNode| { &mut m.sr_local_block },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LsAttributeNode>(
                    "LsAttributeNode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LsAttributeNode {
        static mut instance: ::protobuf::lazy::Lazy<LsAttributeNode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LsAttributeNode,
        };
        unsafe {
            instance.get(LsAttributeNode::new)
        }
    }
}

impl ::protobuf::Clear for LsAttributeNode {
    fn clear(&mut self) {
        self.name.clear();
        self.flags.clear();
        self.local_router_id.clear();
        self.local_router_id_v6.clear();
        self.isis_area.clear();
        self.opaque.clear();
        self.sr_capabilities.clear();
        self.sr_algorithms.clear();
        self.sr_local_block.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LsAttributeNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LsAttributeNode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LsAttributeLink {
    // message fields
    pub name: ::std::string::String,
    pub local_router_id: ::std::string::String,
    pub local_router_id_v6: ::std::string::String,
    pub remote_router_id: ::std::string::String,
    pub remote_router_id_v6: ::std::string::String,
    pub admin_group: u32,
    pub default_te_metric: u32,
    pub igp_metric: u32,
    pub opaque: ::std::vec::Vec<u8>,
    pub bandwidth: f32,
    pub reservable_bandwidth: f32,
    pub unreserved_bandwidth: ::std::vec::Vec<f32>,
    pub sr_adjacency_sid: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LsAttributeLink {
    fn default() -> &'a LsAttributeLink {
        <LsAttributeLink as ::protobuf::Message>::default_instance()
    }
}

impl LsAttributeLink {
    pub fn new() -> LsAttributeLink {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string local_router_id = 2;


    pub fn get_local_router_id(&self) -> &str {
        &self.local_router_id
    }
    pub fn clear_local_router_id(&mut self) {
        self.local_router_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_local_router_id(&mut self, v: ::std::string::String) {
        self.local_router_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_local_router_id(&mut self) -> &mut ::std::string::String {
        &mut self.local_router_id
    }

    // Take field
    pub fn take_local_router_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.local_router_id, ::std::string::String::new())
    }

    // string local_router_id_v6 = 3;


    pub fn get_local_router_id_v6(&self) -> &str {
        &self.local_router_id_v6
    }
    pub fn clear_local_router_id_v6(&mut self) {
        self.local_router_id_v6.clear();
    }

    // Param is passed by value, moved
    pub fn set_local_router_id_v6(&mut self, v: ::std::string::String) {
        self.local_router_id_v6 = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_local_router_id_v6(&mut self) -> &mut ::std::string::String {
        &mut self.local_router_id_v6
    }

    // Take field
    pub fn take_local_router_id_v6(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.local_router_id_v6, ::std::string::String::new())
    }

    // string remote_router_id = 4;


    pub fn get_remote_router_id(&self) -> &str {
        &self.remote_router_id
    }
    pub fn clear_remote_router_id(&mut self) {
        self.remote_router_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_remote_router_id(&mut self, v: ::std::string::String) {
        self.remote_router_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remote_router_id(&mut self) -> &mut ::std::string::String {
        &mut self.remote_router_id
    }

    // Take field
    pub fn take_remote_router_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.remote_router_id, ::std::string::String::new())
    }

    // string remote_router_id_v6 = 5;


    pub fn get_remote_router_id_v6(&self) -> &str {
        &self.remote_router_id_v6
    }
    pub fn clear_remote_router_id_v6(&mut self) {
        self.remote_router_id_v6.clear();
    }

    // Param is passed by value, moved
    pub fn set_remote_router_id_v6(&mut self, v: ::std::string::String) {
        self.remote_router_id_v6 = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remote_router_id_v6(&mut self) -> &mut ::std::string::String {
        &mut self.remote_router_id_v6
    }

    // Take field
    pub fn take_remote_router_id_v6(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.remote_router_id_v6, ::std::string::String::new())
    }

    // uint32 admin_group = 6;


    pub fn get_admin_group(&self) -> u32 {
        self.admin_group
    }
    pub fn clear_admin_group(&mut self) {
        self.admin_group = 0;
    }

    // Param is passed by value, moved
    pub fn set_admin_group(&mut self, v: u32) {
        self.admin_group = v;
    }

    // uint32 default_te_metric = 7;


    pub fn get_default_te_metric(&self) -> u32 {
        self.default_te_metric
    }
    pub fn clear_default_te_metric(&mut self) {
        self.default_te_metric = 0;
    }

    // Param is passed by value, moved
    pub fn set_default_te_metric(&mut self, v: u32) {
        self.default_te_metric = v;
    }

    // uint32 igp_metric = 8;


    pub fn get_igp_metric(&self) -> u32 {
        self.igp_metric
    }
    pub fn clear_igp_metric(&mut self) {
        self.igp_metric = 0;
    }

    // Param is passed by value, moved
    pub fn set_igp_metric(&mut self, v: u32) {
        self.igp_metric = v;
    }

    // bytes opaque = 9;


    pub fn get_opaque(&self) -> &[u8] {
        &self.opaque
    }
    pub fn clear_opaque(&mut self) {
        self.opaque.clear();
    }

    // Param is passed by value, moved
    pub fn set_opaque(&mut self, v: ::std::vec::Vec<u8>) {
        self.opaque = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_opaque(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.opaque
    }

    // Take field
    pub fn take_opaque(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.opaque, ::std::vec::Vec::new())
    }

    // float bandwidth = 10;


    pub fn get_bandwidth(&self) -> f32 {
        self.bandwidth
    }
    pub fn clear_bandwidth(&mut self) {
        self.bandwidth = 0.;
    }

    // Param is passed by value, moved
    pub fn set_bandwidth(&mut self, v: f32) {
        self.bandwidth = v;
    }

    // float reservable_bandwidth = 11;


    pub fn get_reservable_bandwidth(&self) -> f32 {
        self.reservable_bandwidth
    }
    pub fn clear_reservable_bandwidth(&mut self) {
        self.reservable_bandwidth = 0.;
    }

    // Param is passed by value, moved
    pub fn set_reservable_bandwidth(&mut self, v: f32) {
        self.reservable_bandwidth = v;
    }

    // repeated float unreserved_bandwidth = 12;


    pub fn get_unreserved_bandwidth(&self) -> &[f32] {
        &self.unreserved_bandwidth
    }
    pub fn clear_unreserved_bandwidth(&mut self) {
        self.unreserved_bandwidth.clear();
    }

    // Param is passed by value, moved
    pub fn set_unreserved_bandwidth(&mut self, v: ::std::vec::Vec<f32>) {
        self.unreserved_bandwidth = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unreserved_bandwidth(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.unreserved_bandwidth
    }

    // Take field
    pub fn take_unreserved_bandwidth(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.unreserved_bandwidth, ::std::vec::Vec::new())
    }

    // uint32 sr_adjacency_sid = 13;


    pub fn get_sr_adjacency_sid(&self) -> u32 {
        self.sr_adjacency_sid
    }
    pub fn clear_sr_adjacency_sid(&mut self) {
        self.sr_adjacency_sid = 0;
    }

    // Param is passed by value, moved
    pub fn set_sr_adjacency_sid(&mut self, v: u32) {
        self.sr_adjacency_sid = v;
    }
}

impl ::protobuf::Message for LsAttributeLink {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.local_router_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.local_router_id_v6)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.remote_router_id)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.remote_router_id_v6)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.admin_group = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.default_te_metric = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.igp_metric = tmp;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.opaque)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.bandwidth = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.reservable_bandwidth = tmp;
                },
                12 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.unreserved_bandwidth)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.sr_adjacency_sid = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.local_router_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.local_router_id);
        }
        if !self.local_router_id_v6.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.local_router_id_v6);
        }
        if !self.remote_router_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.remote_router_id);
        }
        if !self.remote_router_id_v6.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.remote_router_id_v6);
        }
        if self.admin_group != 0 {
            my_size += ::protobuf::rt::value_size(6, self.admin_group, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.default_te_metric != 0 {
            my_size += ::protobuf::rt::value_size(7, self.default_te_metric, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.igp_metric != 0 {
            my_size += ::protobuf::rt::value_size(8, self.igp_metric, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.opaque.is_empty() {
            my_size += ::protobuf::rt::bytes_size(9, &self.opaque);
        }
        if self.bandwidth != 0. {
            my_size += 5;
        }
        if self.reservable_bandwidth != 0. {
            my_size += 5;
        }
        my_size += 5 * self.unreserved_bandwidth.len() as u32;
        if self.sr_adjacency_sid != 0 {
            my_size += ::protobuf::rt::value_size(13, self.sr_adjacency_sid, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.local_router_id.is_empty() {
            os.write_string(2, &self.local_router_id)?;
        }
        if !self.local_router_id_v6.is_empty() {
            os.write_string(3, &self.local_router_id_v6)?;
        }
        if !self.remote_router_id.is_empty() {
            os.write_string(4, &self.remote_router_id)?;
        }
        if !self.remote_router_id_v6.is_empty() {
            os.write_string(5, &self.remote_router_id_v6)?;
        }
        if self.admin_group != 0 {
            os.write_uint32(6, self.admin_group)?;
        }
        if self.default_te_metric != 0 {
            os.write_uint32(7, self.default_te_metric)?;
        }
        if self.igp_metric != 0 {
            os.write_uint32(8, self.igp_metric)?;
        }
        if !self.opaque.is_empty() {
            os.write_bytes(9, &self.opaque)?;
        }
        if self.bandwidth != 0. {
            os.write_float(10, self.bandwidth)?;
        }
        if self.reservable_bandwidth != 0. {
            os.write_float(11, self.reservable_bandwidth)?;
        }
        for v in &self.unreserved_bandwidth {
            os.write_float(12, *v)?;
        };
        if self.sr_adjacency_sid != 0 {
            os.write_uint32(13, self.sr_adjacency_sid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LsAttributeLink {
        LsAttributeLink::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &LsAttributeLink| { &m.name },
                    |m: &mut LsAttributeLink| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "local_router_id",
                    |m: &LsAttributeLink| { &m.local_router_id },
                    |m: &mut LsAttributeLink| { &mut m.local_router_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "local_router_id_v6",
                    |m: &LsAttributeLink| { &m.local_router_id_v6 },
                    |m: &mut LsAttributeLink| { &mut m.local_router_id_v6 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "remote_router_id",
                    |m: &LsAttributeLink| { &m.remote_router_id },
                    |m: &mut LsAttributeLink| { &mut m.remote_router_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "remote_router_id_v6",
                    |m: &LsAttributeLink| { &m.remote_router_id_v6 },
                    |m: &mut LsAttributeLink| { &mut m.remote_router_id_v6 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "admin_group",
                    |m: &LsAttributeLink| { &m.admin_group },
                    |m: &mut LsAttributeLink| { &mut m.admin_group },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "default_te_metric",
                    |m: &LsAttributeLink| { &m.default_te_metric },
                    |m: &mut LsAttributeLink| { &mut m.default_te_metric },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "igp_metric",
                    |m: &LsAttributeLink| { &m.igp_metric },
                    |m: &mut LsAttributeLink| { &mut m.igp_metric },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "opaque",
                    |m: &LsAttributeLink| { &m.opaque },
                    |m: &mut LsAttributeLink| { &mut m.opaque },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "bandwidth",
                    |m: &LsAttributeLink| { &m.bandwidth },
                    |m: &mut LsAttributeLink| { &mut m.bandwidth },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "reservable_bandwidth",
                    |m: &LsAttributeLink| { &m.reservable_bandwidth },
                    |m: &mut LsAttributeLink| { &mut m.reservable_bandwidth },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "unreserved_bandwidth",
                    |m: &LsAttributeLink| { &m.unreserved_bandwidth },
                    |m: &mut LsAttributeLink| { &mut m.unreserved_bandwidth },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "sr_adjacency_sid",
                    |m: &LsAttributeLink| { &m.sr_adjacency_sid },
                    |m: &mut LsAttributeLink| { &mut m.sr_adjacency_sid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LsAttributeLink>(
                    "LsAttributeLink",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LsAttributeLink {
        static mut instance: ::protobuf::lazy::Lazy<LsAttributeLink> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LsAttributeLink,
        };
        unsafe {
            instance.get(LsAttributeLink::new)
        }
    }
}

impl ::protobuf::Clear for LsAttributeLink {
    fn clear(&mut self) {
        self.name.clear();
        self.local_router_id.clear();
        self.local_router_id_v6.clear();
        self.remote_router_id.clear();
        self.remote_router_id_v6.clear();
        self.admin_group = 0;
        self.default_te_metric = 0;
        self.igp_metric = 0;
        self.opaque.clear();
        self.bandwidth = 0.;
        self.reservable_bandwidth = 0.;
        self.unreserved_bandwidth.clear();
        self.sr_adjacency_sid = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LsAttributeLink {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LsAttributeLink {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LsAttributePrefix {
    // message fields
    pub igp_flags: ::protobuf::SingularPtrField<LsIGPFlags>,
    pub opaque: ::std::vec::Vec<u8>,
    pub sr_prefix_sid: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LsAttributePrefix {
    fn default() -> &'a LsAttributePrefix {
        <LsAttributePrefix as ::protobuf::Message>::default_instance()
    }
}

impl LsAttributePrefix {
    pub fn new() -> LsAttributePrefix {
        ::std::default::Default::default()
    }

    // .gobgpapi.LsIGPFlags igp_flags = 1;


    pub fn get_igp_flags(&self) -> &LsIGPFlags {
        self.igp_flags.as_ref().unwrap_or_else(|| LsIGPFlags::default_instance())
    }
    pub fn clear_igp_flags(&mut self) {
        self.igp_flags.clear();
    }

    pub fn has_igp_flags(&self) -> bool {
        self.igp_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_igp_flags(&mut self, v: LsIGPFlags) {
        self.igp_flags = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_igp_flags(&mut self) -> &mut LsIGPFlags {
        if self.igp_flags.is_none() {
            self.igp_flags.set_default();
        }
        self.igp_flags.as_mut().unwrap()
    }

    // Take field
    pub fn take_igp_flags(&mut self) -> LsIGPFlags {
        self.igp_flags.take().unwrap_or_else(|| LsIGPFlags::new())
    }

    // bytes opaque = 2;


    pub fn get_opaque(&self) -> &[u8] {
        &self.opaque
    }
    pub fn clear_opaque(&mut self) {
        self.opaque.clear();
    }

    // Param is passed by value, moved
    pub fn set_opaque(&mut self, v: ::std::vec::Vec<u8>) {
        self.opaque = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_opaque(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.opaque
    }

    // Take field
    pub fn take_opaque(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.opaque, ::std::vec::Vec::new())
    }

    // uint32 sr_prefix_sid = 3;


    pub fn get_sr_prefix_sid(&self) -> u32 {
        self.sr_prefix_sid
    }
    pub fn clear_sr_prefix_sid(&mut self) {
        self.sr_prefix_sid = 0;
    }

    // Param is passed by value, moved
    pub fn set_sr_prefix_sid(&mut self, v: u32) {
        self.sr_prefix_sid = v;
    }
}

impl ::protobuf::Message for LsAttributePrefix {
    fn is_initialized(&self) -> bool {
        for v in &self.igp_flags {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.igp_flags)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.opaque)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.sr_prefix_sid = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.igp_flags.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.opaque.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.opaque);
        }
        if self.sr_prefix_sid != 0 {
            my_size += ::protobuf::rt::value_size(3, self.sr_prefix_sid, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.igp_flags.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.opaque.is_empty() {
            os.write_bytes(2, &self.opaque)?;
        }
        if self.sr_prefix_sid != 0 {
            os.write_uint32(3, self.sr_prefix_sid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LsAttributePrefix {
        LsAttributePrefix::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LsIGPFlags>>(
                    "igp_flags",
                    |m: &LsAttributePrefix| { &m.igp_flags },
                    |m: &mut LsAttributePrefix| { &mut m.igp_flags },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "opaque",
                    |m: &LsAttributePrefix| { &m.opaque },
                    |m: &mut LsAttributePrefix| { &mut m.opaque },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "sr_prefix_sid",
                    |m: &LsAttributePrefix| { &m.sr_prefix_sid },
                    |m: &mut LsAttributePrefix| { &mut m.sr_prefix_sid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LsAttributePrefix>(
                    "LsAttributePrefix",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LsAttributePrefix {
        static mut instance: ::protobuf::lazy::Lazy<LsAttributePrefix> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LsAttributePrefix,
        };
        unsafe {
            instance.get(LsAttributePrefix::new)
        }
    }
}

impl ::protobuf::Clear for LsAttributePrefix {
    fn clear(&mut self) {
        self.igp_flags.clear();
        self.opaque.clear();
        self.sr_prefix_sid = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LsAttributePrefix {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LsAttributePrefix {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LsAttribute {
    // message fields
    pub node: ::protobuf::SingularPtrField<LsAttributeNode>,
    pub link: ::protobuf::SingularPtrField<LsAttributeLink>,
    pub prefix: ::protobuf::SingularPtrField<LsAttributePrefix>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LsAttribute {
    fn default() -> &'a LsAttribute {
        <LsAttribute as ::protobuf::Message>::default_instance()
    }
}

impl LsAttribute {
    pub fn new() -> LsAttribute {
        ::std::default::Default::default()
    }

    // .gobgpapi.LsAttributeNode node = 1;


    pub fn get_node(&self) -> &LsAttributeNode {
        self.node.as_ref().unwrap_or_else(|| LsAttributeNode::default_instance())
    }
    pub fn clear_node(&mut self) {
        self.node.clear();
    }

    pub fn has_node(&self) -> bool {
        self.node.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node(&mut self, v: LsAttributeNode) {
        self.node = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node(&mut self) -> &mut LsAttributeNode {
        if self.node.is_none() {
            self.node.set_default();
        }
        self.node.as_mut().unwrap()
    }

    // Take field
    pub fn take_node(&mut self) -> LsAttributeNode {
        self.node.take().unwrap_or_else(|| LsAttributeNode::new())
    }

    // .gobgpapi.LsAttributeLink link = 2;


    pub fn get_link(&self) -> &LsAttributeLink {
        self.link.as_ref().unwrap_or_else(|| LsAttributeLink::default_instance())
    }
    pub fn clear_link(&mut self) {
        self.link.clear();
    }

    pub fn has_link(&self) -> bool {
        self.link.is_some()
    }

    // Param is passed by value, moved
    pub fn set_link(&mut self, v: LsAttributeLink) {
        self.link = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_link(&mut self) -> &mut LsAttributeLink {
        if self.link.is_none() {
            self.link.set_default();
        }
        self.link.as_mut().unwrap()
    }

    // Take field
    pub fn take_link(&mut self) -> LsAttributeLink {
        self.link.take().unwrap_or_else(|| LsAttributeLink::new())
    }

    // .gobgpapi.LsAttributePrefix prefix = 3;


    pub fn get_prefix(&self) -> &LsAttributePrefix {
        self.prefix.as_ref().unwrap_or_else(|| LsAttributePrefix::default_instance())
    }
    pub fn clear_prefix(&mut self) {
        self.prefix.clear();
    }

    pub fn has_prefix(&self) -> bool {
        self.prefix.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prefix(&mut self, v: LsAttributePrefix) {
        self.prefix = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prefix(&mut self) -> &mut LsAttributePrefix {
        if self.prefix.is_none() {
            self.prefix.set_default();
        }
        self.prefix.as_mut().unwrap()
    }

    // Take field
    pub fn take_prefix(&mut self) -> LsAttributePrefix {
        self.prefix.take().unwrap_or_else(|| LsAttributePrefix::new())
    }
}

impl ::protobuf::Message for LsAttribute {
    fn is_initialized(&self) -> bool {
        for v in &self.node {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.link {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.prefix {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.node)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.link)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.prefix)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.node.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.link.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.prefix.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.node.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.link.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.prefix.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LsAttribute {
        LsAttribute::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LsAttributeNode>>(
                    "node",
                    |m: &LsAttribute| { &m.node },
                    |m: &mut LsAttribute| { &mut m.node },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LsAttributeLink>>(
                    "link",
                    |m: &LsAttribute| { &m.link },
                    |m: &mut LsAttribute| { &mut m.link },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LsAttributePrefix>>(
                    "prefix",
                    |m: &LsAttribute| { &m.prefix },
                    |m: &mut LsAttribute| { &mut m.prefix },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LsAttribute>(
                    "LsAttribute",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LsAttribute {
        static mut instance: ::protobuf::lazy::Lazy<LsAttribute> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LsAttribute,
        };
        unsafe {
            instance.get(LsAttribute::new)
        }
    }
}

impl ::protobuf::Clear for LsAttribute {
    fn clear(&mut self) {
        self.node.clear();
        self.link.clear();
        self.prefix.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LsAttribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LsAttribute {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UnknownAttribute {
    // message fields
    pub flags: u32,
    pub field_type: u32,
    pub value: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UnknownAttribute {
    fn default() -> &'a UnknownAttribute {
        <UnknownAttribute as ::protobuf::Message>::default_instance()
    }
}

impl UnknownAttribute {
    pub fn new() -> UnknownAttribute {
        ::std::default::Default::default()
    }

    // uint32 flags = 1;


    pub fn get_flags(&self) -> u32 {
        self.flags
    }
    pub fn clear_flags(&mut self) {
        self.flags = 0;
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = v;
    }

    // uint32 type = 2;


    pub fn get_field_type(&self) -> u32 {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = 0;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: u32) {
        self.field_type = v;
    }

    // bytes value = 3;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for UnknownAttribute {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.field_type = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.flags != 0 {
            my_size += ::protobuf::rt::value_size(1, self.flags, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.field_type != 0 {
            my_size += ::protobuf::rt::value_size(2, self.field_type, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.flags != 0 {
            os.write_uint32(1, self.flags)?;
        }
        if self.field_type != 0 {
            os.write_uint32(2, self.field_type)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(3, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnknownAttribute {
        UnknownAttribute::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "flags",
                    |m: &UnknownAttribute| { &m.flags },
                    |m: &mut UnknownAttribute| { &mut m.flags },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "type",
                    |m: &UnknownAttribute| { &m.field_type },
                    |m: &mut UnknownAttribute| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "value",
                    |m: &UnknownAttribute| { &m.value },
                    |m: &mut UnknownAttribute| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UnknownAttribute>(
                    "UnknownAttribute",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UnknownAttribute {
        static mut instance: ::protobuf::lazy::Lazy<UnknownAttribute> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UnknownAttribute,
        };
        unsafe {
            instance.get(UnknownAttribute::new)
        }
    }
}

impl ::protobuf::Clear for UnknownAttribute {
    fn clear(&mut self) {
        self.flags = 0;
        self.field_type = 0;
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnknownAttribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnknownAttribute {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum LsNLRIType {
    LS_NLRI_UNKNOWN = 0,
    LS_NLRI_NODE = 1,
    LS_NLRI_LINK = 2,
    LS_NLRI_PREFIX_V4 = 3,
    LS_NLRI_PREFIX_V6 = 4,
}

impl ::protobuf::ProtobufEnum for LsNLRIType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LsNLRIType> {
        match value {
            0 => ::std::option::Option::Some(LsNLRIType::LS_NLRI_UNKNOWN),
            1 => ::std::option::Option::Some(LsNLRIType::LS_NLRI_NODE),
            2 => ::std::option::Option::Some(LsNLRIType::LS_NLRI_LINK),
            3 => ::std::option::Option::Some(LsNLRIType::LS_NLRI_PREFIX_V4),
            4 => ::std::option::Option::Some(LsNLRIType::LS_NLRI_PREFIX_V6),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [LsNLRIType] = &[
            LsNLRIType::LS_NLRI_UNKNOWN,
            LsNLRIType::LS_NLRI_NODE,
            LsNLRIType::LS_NLRI_LINK,
            LsNLRIType::LS_NLRI_PREFIX_V4,
            LsNLRIType::LS_NLRI_PREFIX_V6,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("LsNLRIType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for LsNLRIType {
}

impl ::std::default::Default for LsNLRIType {
    fn default() -> Self {
        LsNLRIType::LS_NLRI_UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for LsNLRIType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0fattribute.proto\x12\x08gobgpapi\x1a\x19google/protobuf/any.proto\
    \x1a\x0bgobgp.proto\")\n\x0fOriginAttribute\x12\x16\n\x06origin\x18\x01\
    \x20\x01(\rR\x06origin\"9\n\tAsSegment\x12\x12\n\x04type\x18\x01\x20\x01\
    (\rR\x04type\x12\x18\n\x07numbers\x18\x02\x20\x03(\rR\x07numbers\"B\n\
    \x0fAsPathAttribute\x12/\n\x08segments\x18\x01\x20\x03(\x0b2\x13.gobgpap\
    i.AsSegmentR\x08segments\"-\n\x10NextHopAttribute\x12\x19\n\x08next_hop\
    \x18\x01\x20\x01(\tR\x07nextHop\"*\n\x16MultiExitDiscAttribute\x12\x10\n\
    \x03med\x18\x01\x20\x01(\rR\x03med\"3\n\x12LocalPrefAttribute\x12\x1d\n\
    \nlocal_pref\x18\x01\x20\x01(\rR\tlocalPref\"\x1a\n\x18AtomicAggregateAt\
    tribute\"?\n\x13AggregatorAttribute\x12\x0e\n\x02as\x18\x02\x20\x01(\rR\
    \x02as\x12\x18\n\x07address\x18\x03\x20\x01(\tR\x07address\"8\n\x14Commu\
    nitiesAttribute\x12\x20\n\x0bcommunities\x18\x01\x20\x03(\rR\x0bcommunit\
    ies\"'\n\x15OriginatorIdAttribute\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\
    \x02id\"(\n\x14ClusterListAttribute\x12\x10\n\x03ids\x18\x01\x20\x03(\tR\
    \x03ids\"H\n\x0fIPAddressPrefix\x12\x1d\n\nprefix_len\x18\x01\x20\x01(\r\
    R\tprefixLen\x12\x16\n\x06prefix\x18\x02\x20\x01(\tR\x06prefix\"g\n\x16L\
    abeledIPAddressPrefix\x12\x16\n\x06labels\x18\x01\x20\x03(\rR\x06labels\
    \x12\x1d\n\nprefix_len\x18\x02\x20\x01(\rR\tprefixLen\x12\x16\n\x06prefi\
    x\x18\x03\x20\x01(\tR\x06prefix\"-\n\x11EncapsulationNLRI\x12\x18\n\x07a\
    ddress\x18\x01\x20\x01(\tR\x07address\"P\n\x1cRouteDistinguisherTwoOctet\
    AS\x12\x14\n\x05admin\x18\x01\x20\x01(\rR\x05admin\x12\x1a\n\x08assigned\
    \x18\x02\x20\x01(\rR\x08assigned\"O\n\x1bRouteDistinguisherIPAddress\x12\
    \x14\n\x05admin\x18\x01\x20\x01(\tR\x05admin\x12\x1a\n\x08assigned\x18\
    \x02\x20\x01(\rR\x08assigned\"Q\n\x1dRouteDistinguisherFourOctetAS\x12\
    \x14\n\x05admin\x18\x01\x20\x01(\rR\x05admin\x12\x1a\n\x08assigned\x18\
    \x02\x20\x01(\rR\x08assigned\"E\n\x19EthernetSegmentIdentifier\x12\x12\n\
    \x04type\x18\x01\x20\x01(\rR\x04type\x12\x14\n\x05value\x18\x02\x20\x01(\
    \x0cR\x05value\"\xb6\x01\n\x1eEVPNEthernetAutoDiscoveryRoute\x12$\n\x02r\
    d\x18\x01\x20\x01(\x0b2\x14.google.protobuf.AnyR\x02rd\x125\n\x03esi\x18\
    \x02\x20\x01(\x0b2#.gobgpapi.EthernetSegmentIdentifierR\x03esi\x12!\n\
    \x0cethernet_tag\x18\x03\x20\x01(\rR\x0bethernetTag\x12\x14\n\x05label\
    \x18\x04\x20\x01(\rR\x05label\"\xf5\x01\n\x1bEVPNMACIPAdvertisementRoute\
    \x12$\n\x02rd\x18\x01\x20\x01(\x0b2\x14.google.protobuf.AnyR\x02rd\x125\
    \n\x03esi\x18\x02\x20\x01(\x0b2#.gobgpapi.EthernetSegmentIdentifierR\x03\
    esi\x12!\n\x0cethernet_tag\x18\x03\x20\x01(\rR\x0bethernetTag\x12\x1f\n\
    \x0bmac_address\x18\x04\x20\x01(\tR\nmacAddress\x12\x1d\n\nip_address\
    \x18\x05\x20\x01(\tR\tipAddress\x12\x16\n\x06labels\x18\x06\x20\x03(\rR\
    \x06labels\"\x90\x01\n&EVPNInclusiveMulticastEthernetTagRoute\x12$\n\x02\
    rd\x18\x01\x20\x01(\x0b2\x14.google.protobuf.AnyR\x02rd\x12!\n\x0cethern\
    et_tag\x18\x02\x20\x01(\rR\x0bethernetTag\x12\x1d\n\nip_address\x18\x03\
    \x20\x01(\tR\tipAddress\"\x96\x01\n\x18EVPNEthernetSegmentRoute\x12$\n\
    \x02rd\x18\x01\x20\x01(\x0b2\x14.google.protobuf.AnyR\x02rd\x125\n\x03es\
    i\x18\x02\x20\x01(\x0b2#.gobgpapi.EthernetSegmentIdentifierR\x03esi\x12\
    \x1d\n\nip_address\x18\x03\x20\x01(\tR\tipAddress\"\x89\x02\n\x11EVPNIPP\
    refixRoute\x12$\n\x02rd\x18\x01\x20\x01(\x0b2\x14.google.protobuf.AnyR\
    \x02rd\x125\n\x03esi\x18\x02\x20\x01(\x0b2#.gobgpapi.EthernetSegmentIden\
    tifierR\x03esi\x12!\n\x0cethernet_tag\x18\x03\x20\x01(\rR\x0bethernetTag\
    \x12\x1b\n\tip_prefix\x18\x04\x20\x01(\tR\x08ipPrefix\x12\"\n\rip_prefix\
    _len\x18\x05\x20\x01(\rR\x0bipPrefixLen\x12\x1d\n\ngw_address\x18\x06\
    \x20\x01(\tR\tgwAddress\x12\x14\n\x05label\x18\x07\x20\x01(\rR\x05label\
    \"\x7f\n\x0eEVPNIPMSIRoute\x12$\n\x02rd\x18\x01\x20\x01(\x0b2\x14.google\
    .protobuf.AnyR\x02rd\x12!\n\x0cethernet_tag\x18\x02\x20\x01(\rR\x0bether\
    netTag\x12$\n\x02rt\x18\x03\x20\x01(\x0b2\x14.google.protobuf.AnyR\x02rt\
    \"\x90\x01\n\x19LabeledVPNIPAddressPrefix\x12\x16\n\x06labels\x18\x01\
    \x20\x03(\rR\x06labels\x12$\n\x02rd\x18\x02\x20\x01(\x0b2\x14.google.pro\
    tobuf.AnyR\x02rd\x12\x1d\n\nprefix_len\x18\x03\x20\x01(\rR\tprefixLen\
    \x12\x16\n\x06prefix\x18\x04\x20\x01(\tR\x06prefix\"Q\n\x19RouteTargetMe\
    mbershipNLRI\x12\x0e\n\x02as\x18\x01\x20\x01(\rR\x02as\x12$\n\x02rt\x18\
    \x02\x20\x01(\x0b2\x14.google.protobuf.AnyR\x02rt\"u\n\x10FlowSpecIPPref\
    ix\x12\x12\n\x04type\x18\x01\x20\x01(\rR\x04type\x12\x1d\n\nprefix_len\
    \x18\x02\x20\x01(\rR\tprefixLen\x12\x16\n\x06prefix\x18\x03\x20\x01(\tR\
    \x06prefix\x12\x16\n\x06offset\x18\x04\x20\x01(\rR\x06offset\";\n\x0bFlo\
    wSpecMAC\x12\x12\n\x04type\x18\x01\x20\x01(\rR\x04type\x12\x18\n\x07addr\
    ess\x18\x02\x20\x01(\tR\x07address\"=\n\x15FlowSpecComponentItem\x12\x0e\
    \n\x02op\x18\x01\x20\x01(\rR\x02op\x12\x14\n\x05value\x18\x02\x20\x01(\
    \x04R\x05value\"^\n\x11FlowSpecComponent\x12\x12\n\x04type\x18\x01\x20\
    \x01(\rR\x04type\x125\n\x05items\x18\x02\x20\x03(\x0b2\x1f.gobgpapi.Flow\
    SpecComponentItemR\x05items\":\n\x0cFlowSpecNLRI\x12*\n\x05rules\x18\x01\
    \x20\x03(\x0b2\x14.google.protobuf.AnyR\x05rules\"c\n\x0fVPNFlowSpecNLRI\
    \x12$\n\x02rd\x18\x01\x20\x01(\x0b2\x14.google.protobuf.AnyR\x02rd\x12*\
    \n\x05rules\x18\x02\x20\x03(\x0b2\x14.google.protobuf.AnyR\x05rules\"4\n\
    \nOpaqueNLRI\x12\x10\n\x03key\x18\x01\x20\x01(\x0cR\x03key\x12\x14\n\x05\
    value\x18\x02\x20\x01(\x0cR\x05value\"\xa6\x01\n\x10LsNodeDescriptor\x12\
    \x10\n\x03asn\x18\x01\x20\x01(\rR\x03asn\x12\x1a\n\tbgp_ls_id\x18\x02\
    \x20\x01(\rR\x07bgpLsId\x12\x20\n\x0cospf_area_id\x18\x03\x20\x01(\rR\no\
    spfAreaId\x12\x1e\n\npseudonode\x18\x04\x20\x01(\x08R\npseudonode\x12\"\
    \n\rigp_router_id\x18\x05\x20\x01(\tR\x0bigpRouterId\"\x98\x02\n\x10LsLi\
    nkDescriptor\x12\"\n\rlink_local_id\x18\x01\x20\x01(\rR\x0blinkLocalId\
    \x12$\n\x0elink_remote_id\x18\x02\x20\x01(\rR\x0clinkRemoteId\x12.\n\x13\
    interface_addr_ipv4\x18\x03\x20\x01(\tR\x11interfaceAddrIpv4\x12,\n\x12n\
    eighbor_addr_ipv4\x18\x04\x20\x01(\tR\x10neighborAddrIpv4\x12.\n\x13inte\
    rface_addr_ipv6\x18\x05\x20\x01(\tR\x11interfaceAddrIpv6\x12,\n\x12neigh\
    bor_addr_ipv6\x18\x06\x20\x01(\tR\x10neighborAddrIpv6\"e\n\x12LsPrefixDe\
    scriptor\x12'\n\x0fip_reachability\x18\x01\x20\x03(\tR\x0eipReachability\
    \x12&\n\x0fospf_route_type\x18\x02\x20\x01(\tR\rospfRouteType\"G\n\nLsNo\
    deNLRI\x129\n\nlocal_node\x18\x01\x20\x01(\x0b2\x1a.gobgpapi.LsNodeDescr\
    iptorR\tlocalNode\"\xc9\x01\n\nLsLinkNLRI\x129\n\nlocal_node\x18\x01\x20\
    \x01(\x0b2\x1a.gobgpapi.LsNodeDescriptorR\tlocalNode\x12;\n\x0bremote_no\
    de\x18\x02\x20\x01(\x0b2\x1a.gobgpapi.LsNodeDescriptorR\nremoteNode\x12C\
    \n\x0flink_descriptor\x18\x03\x20\x01(\x0b2\x1a.gobgpapi.LsLinkDescripto\
    rR\x0elinkDescriptor\"\x96\x01\n\x0eLsPrefixV4NLRI\x129\n\nlocal_node\
    \x18\x01\x20\x01(\x0b2\x1a.gobgpapi.LsNodeDescriptorR\tlocalNode\x12I\n\
    \x11prefix_descriptor\x18\x02\x20\x01(\x0b2\x1c.gobgpapi.LsPrefixDescrip\
    torR\x10prefixDescriptor\"\x96\x01\n\x0eLsPrefixV6NLRI\x129\n\nlocal_nod\
    e\x18\x01\x20\x01(\x0b2\x1a.gobgpapi.LsNodeDescriptorR\tlocalNode\x12I\n\
    \x11prefix_descriptor\x18\x02\x20\x01(\x0b2\x1c.gobgpapi.LsPrefixDescrip\
    torR\x10prefixDescriptor\"b\n\x0cLsAddrPrefix\x12(\n\x04type\x18\x01\x20\
    \x01(\x0e2\x14.gobgpapi.LsNLRITypeR\x04type\x12(\n\x04nlri\x18\x02\x20\
    \x01(\x0b2\x14.google.protobuf.AnyR\x04nlri\"\x89\x01\n\x14MpReachNLRIAt\
    tribute\x12(\n\x06family\x18\x01\x20\x01(\x0b2\x10.gobgpapi.FamilyR\x06f\
    amily\x12\x1b\n\tnext_hops\x18\x02\x20\x03(\tR\x08nextHops\x12*\n\x05nlr\
    is\x18\x03\x20\x03(\x0b2\x14.google.protobuf.AnyR\x05nlris\"n\n\x16MpUnr\
    eachNLRIAttribute\x12(\n\x06family\x18\x01\x20\x01(\x0b2\x10.gobgpapi.Fa\
    milyR\x06family\x12*\n\x05nlris\x18\x03\x20\x03(\x0b2\x14.google.protobu\
    f.AnyR\x05nlris\"\x8d\x01\n\x1aTwoOctetAsSpecificExtended\x12#\n\ris_tra\
    nsitive\x18\x01\x20\x01(\x08R\x0cisTransitive\x12\x19\n\x08sub_type\x18\
    \x02\x20\x01(\rR\x07subType\x12\x0e\n\x02as\x18\x03\x20\x01(\rR\x02as\
    \x12\x1f\n\x0blocal_admin\x18\x04\x20\x01(\rR\nlocalAdmin\"\x98\x01\n\
    \x1bIPv4AddressSpecificExtended\x12#\n\ris_transitive\x18\x01\x20\x01(\
    \x08R\x0cisTransitive\x12\x19\n\x08sub_type\x18\x02\x20\x01(\rR\x07subTy\
    pe\x12\x18\n\x07address\x18\x03\x20\x01(\tR\x07address\x12\x1f\n\x0bloca\
    l_admin\x18\x04\x20\x01(\rR\nlocalAdmin\"\x8e\x01\n\x1bFourOctetAsSpecif\
    icExtended\x12#\n\ris_transitive\x18\x01\x20\x01(\x08R\x0cisTransitive\
    \x12\x19\n\x08sub_type\x18\x02\x20\x01(\rR\x07subType\x12\x0e\n\x02as\
    \x18\x03\x20\x01(\rR\x02as\x12\x1f\n\x0blocal_admin\x18\x04\x20\x01(\rR\
    \nlocalAdmin\"*\n\x12ValidationExtended\x12\x14\n\x05state\x18\x01\x20\
    \x01(\rR\x05state\"%\n\rColorExtended\x12\x14\n\x05color\x18\x01\x20\x01\
    (\rR\x05color\"0\n\rEncapExtended\x12\x1f\n\x0btunnel_type\x18\x01\x20\
    \x01(\rR\ntunnelType\"\x18\n\x16DefaultGatewayExtended\"K\n\x0eOpaqueExt\
    ended\x12#\n\ris_transitive\x18\x01\x20\x01(\x08R\x0cisTransitive\x12\
    \x14\n\x05value\x18\x03\x20\x01(\x0cR\x05value\"R\n\x10ESILabelExtended\
    \x12(\n\x10is_single_active\x18\x01\x20\x01(\x08R\x0eisSingleActive\x12\
    \x14\n\x05label\x18\x02\x20\x01(\rR\x05label\"2\n\x13ESImportRouteTarget\
    \x12\x1b\n\tes_import\x18\x01\x20\x01(\tR\x08esImport\"U\n\x13MacMobilit\
    yExtended\x12\x1b\n\tis_sticky\x18\x01\x20\x01(\x08R\x08isSticky\x12!\n\
    \x0csequence_num\x18\x02\x20\x01(\rR\x0bsequenceNum\"%\n\x11RouterMacExt\
    ended\x12\x10\n\x03mac\x18\x01\x20\x01(\tR\x03mac\"9\n\x13TrafficRateExt\
    ended\x12\x0e\n\x02as\x18\x01\x20\x01(\rR\x02as\x12\x12\n\x04rate\x18\
    \x02\x20\x01(\x02R\x04rate\"K\n\x15TrafficActionExtended\x12\x1a\n\x08te\
    rminal\x18\x01\x20\x01(\x08R\x08terminal\x12\x16\n\x06sample\x18\x02\x20\
    \x01(\x08R\x06sample\"U\n\"RedirectTwoOctetAsSpecificExtended\x12\x0e\n\
    \x02as\x18\x01\x20\x01(\rR\x02as\x12\x1f\n\x0blocal_admin\x18\x02\x20\
    \x01(\rR\nlocalAdmin\"`\n#RedirectIPv4AddressSpecificExtended\x12\x18\n\
    \x07address\x18\x01\x20\x01(\tR\x07address\x12\x1f\n\x0blocal_admin\x18\
    \x02\x20\x01(\rR\nlocalAdmin\"V\n#RedirectFourOctetAsSpecificExtended\
    \x12\x0e\n\x02as\x18\x01\x20\x01(\rR\x02as\x12\x1f\n\x0blocal_admin\x18\
    \x02\x20\x01(\rR\nlocalAdmin\"+\n\x15TrafficRemarkExtended\x12\x12\n\x04\
    dscp\x18\x01\x20\x01(\rR\x04dscp\";\n\x0fUnknownExtended\x12\x12\n\x04ty\
    pe\x18\x01\x20\x01(\rR\x04type\x12\x14\n\x05value\x18\x02\x20\x01(\x0cR\
    \x05value\"V\n\x1cExtendedCommunitiesAttribute\x126\n\x0bcommunities\x18\
    \x01\x20\x03(\x0b2\x14.google.protobuf.AnyR\x0bcommunities\"C\n\x10As4Pa\
    thAttribute\x12/\n\x08segments\x18\x01\x20\x03(\x0b2\x13.gobgpapi.AsSegm\
    entR\x08segments\"B\n\x16As4AggregatorAttribute\x12\x0e\n\x02as\x18\x02\
    \x20\x01(\rR\x02as\x12\x18\n\x07address\x18\x03\x20\x01(\tR\x07address\"\
    e\n\x13PmsiTunnelAttribute\x12\x14\n\x05flags\x18\x01\x20\x01(\rR\x05fla\
    gs\x12\x12\n\x04type\x18\x02\x20\x01(\rR\x04type\x12\x14\n\x05label\x18\
    \x03\x20\x01(\rR\x05label\x12\x0e\n\x02id\x18\x04\x20\x01(\x0cR\x02id\"J\
    \n\x1eTunnelEncapSubTLVEncapsulation\x12\x10\n\x03key\x18\x01\x20\x01(\r\
    R\x03key\x12\x16\n\x06cookie\x18\x02\x20\x01(\x0cR\x06cookie\"7\n\x19Tun\
    nelEncapSubTLVProtocol\x12\x1a\n\x08protocol\x18\x01\x20\x01(\rR\x08prot\
    ocol\".\n\x16TunnelEncapSubTLVColor\x12\x14\n\x05color\x18\x01\x20\x01(\
    \rR\x05color\"D\n\x18TunnelEncapSubTLVUnknown\x12\x12\n\x04type\x18\x01\
    \x20\x01(\rR\x04type\x12\x14\n\x05value\x18\x02\x20\x01(\x0cR\x05value\"\
    N\n\x0eTunnelEncapTLV\x12\x12\n\x04type\x18\x01\x20\x01(\rR\x04type\x12(\
    \n\x04tlvs\x18\x02\x20\x03(\x0b2\x14.google.protobuf.AnyR\x04tlvs\"D\n\
    \x14TunnelEncapAttribute\x12,\n\x04tlvs\x18\x01\x20\x03(\x0b2\x18.gobgpa\
    pi.TunnelEncapTLVR\x04tlvs\"\x98\x01\n\x1bIPv6AddressSpecificExtended\
    \x12#\n\ris_transitive\x18\x01\x20\x01(\x08R\x0cisTransitive\x12\x19\n\
    \x08sub_type\x18\x02\x20\x01(\rR\x07subType\x12\x18\n\x07address\x18\x03\
    \x20\x01(\tR\x07address\x12\x1f\n\x0blocal_admin\x18\x04\x20\x01(\rR\nlo\
    calAdmin\"`\n#RedirectIPv6AddressSpecificExtended\x12\x18\n\x07address\
    \x18\x01\x20\x01(\tR\x07address\x12\x1f\n\x0blocal_admin\x18\x02\x20\x01\
    (\rR\nlocalAdmin\"Y\n\x1fIP6ExtendedCommunitiesAttribute\x126\n\x0bcommu\
    nities\x18\x01\x20\x03(\x0b2\x14.google.protobuf.AnyR\x0bcommunities\"*\
    \n\x10AigpTLVIGPMetric\x12\x16\n\x06metric\x18\x01\x20\x01(\x04R\x06metr\
    ic\":\n\x0eAigpTLVUnknown\x12\x12\n\x04type\x18\x01\x20\x01(\rR\x04type\
    \x12\x14\n\x05value\x18\x02\x20\x01(\x0cR\x05value\"9\n\rAigpAttribute\
    \x12(\n\x04tlvs\x18\x01\x20\x03(\x0b2\x14.google.protobuf.AnyR\x04tlvs\"\
    u\n\x0eLargeCommunity\x12!\n\x0cglobal_admin\x18\x01\x20\x01(\rR\x0bglob\
    alAdmin\x12\x1f\n\x0blocal_data1\x18\x02\x20\x01(\rR\nlocalData1\x12\x1f\
    \n\x0blocal_data2\x18\x03\x20\x01(\rR\nlocalData2\"W\n\x19LargeCommuniti\
    esAttribute\x12:\n\x0bcommunities\x18\x01\x20\x03(\x0b2\x18.gobgpapi.Lar\
    geCommunityR\x0bcommunities\"\x9b\x01\n\x0bLsNodeFlags\x12\x1a\n\x08over\
    load\x18\x01\x20\x01(\x08R\x08overload\x12\x1a\n\x08attached\x18\x02\x20\
    \x01(\x08R\x08attached\x12\x1a\n\x08external\x18\x03\x20\x01(\x08R\x08ex\
    ternal\x12\x10\n\x03abr\x18\x04\x20\x01(\x08R\x03abr\x12\x16\n\x06router\
    \x18\x05\x20\x01(\x08R\x06router\x12\x0e\n\x02v6\x18\x06\x20\x01(\x08R\
    \x02v6\"\x8b\x01\n\nLsIGPFlags\x12\x12\n\x04down\x18\x01\x20\x01(\x08R\
    \x04down\x12\x1d\n\nno_unicast\x18\x02\x20\x01(\x08R\tnoUnicast\x12#\n\r\
    local_address\x18\x03\x20\x01(\x08R\x0clocalAddress\x12%\n\x0epropagate_\
    nssa\x18\x04\x20\x01(\x08R\rpropagateNssa\"3\n\tLsSrRange\x12\x14\n\x05b\
    egin\x18\x01\x20\x01(\rR\x05begin\x12\x10\n\x03end\x18\x02\x20\x01(\rR\
    \x03end\"\x8d\x01\n\x10LsSrCapabilities\x12%\n\x0eipv4_supported\x18\x01\
    \x20\x01(\x08R\ripv4Supported\x12%\n\x0eipv6_supported\x18\x02\x20\x01(\
    \x08R\ripv6Supported\x12+\n\x06ranges\x18\x03\x20\x03(\x0b2\x13.gobgpapi\
    .LsSrRangeR\x06ranges\"=\n\x0eLsSrLocalBlock\x12+\n\x06ranges\x18\x01\
    \x20\x03(\x0b2\x13.gobgpapi.LsSrRangeR\x06ranges\"\x86\x03\n\x0fLsAttrib\
    uteNode\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12+\n\x05flags\
    \x18\x02\x20\x01(\x0b2\x15.gobgpapi.LsNodeFlagsR\x05flags\x12&\n\x0floca\
    l_router_id\x18\x03\x20\x01(\tR\rlocalRouterId\x12+\n\x12local_router_id\
    _v6\x18\x04\x20\x01(\tR\x0flocalRouterIdV6\x12\x1b\n\tisis_area\x18\x05\
    \x20\x01(\x0cR\x08isisArea\x12\x16\n\x06opaque\x18\x06\x20\x01(\x0cR\x06\
    opaque\x12C\n\x0fsr_capabilities\x18\x07\x20\x01(\x0b2\x1a.gobgpapi.LsSr\
    CapabilitiesR\x0esrCapabilities\x12#\n\rsr_algorithms\x18\x08\x20\x01(\
    \x0cR\x0csrAlgorithms\x12>\n\x0esr_local_block\x18\t\x20\x01(\x0b2\x18.g\
    obgpapi.LsSrLocalBlockR\x0csrLocalBlock\"\x85\x04\n\x0fLsAttributeLink\
    \x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12&\n\x0flocal_router_id\
    \x18\x02\x20\x01(\tR\rlocalRouterId\x12+\n\x12local_router_id_v6\x18\x03\
    \x20\x01(\tR\x0flocalRouterIdV6\x12(\n\x10remote_router_id\x18\x04\x20\
    \x01(\tR\x0eremoteRouterId\x12-\n\x13remote_router_id_v6\x18\x05\x20\x01\
    (\tR\x10remoteRouterIdV6\x12\x1f\n\x0badmin_group\x18\x06\x20\x01(\rR\na\
    dminGroup\x12*\n\x11default_te_metric\x18\x07\x20\x01(\rR\x0fdefaultTeMe\
    tric\x12\x1d\n\nigp_metric\x18\x08\x20\x01(\rR\tigpMetric\x12\x16\n\x06o\
    paque\x18\t\x20\x01(\x0cR\x06opaque\x12\x1c\n\tbandwidth\x18\n\x20\x01(\
    \x02R\tbandwidth\x121\n\x14reservable_bandwidth\x18\x0b\x20\x01(\x02R\
    \x13reservableBandwidth\x121\n\x14unreserved_bandwidth\x18\x0c\x20\x03(\
    \x02R\x13unreservedBandwidth\x12(\n\x10sr_adjacency_sid\x18\r\x20\x01(\r\
    R\x0esrAdjacencySid\"\x82\x01\n\x11LsAttributePrefix\x121\n\tigp_flags\
    \x18\x01\x20\x01(\x0b2\x14.gobgpapi.LsIGPFlagsR\x08igpFlags\x12\x16\n\
    \x06opaque\x18\x02\x20\x01(\x0cR\x06opaque\x12\"\n\rsr_prefix_sid\x18\
    \x03\x20\x01(\rR\x0bsrPrefixSid\"\xa0\x01\n\x0bLsAttribute\x12-\n\x04nod\
    e\x18\x01\x20\x01(\x0b2\x19.gobgpapi.LsAttributeNodeR\x04node\x12-\n\x04\
    link\x18\x02\x20\x01(\x0b2\x19.gobgpapi.LsAttributeLinkR\x04link\x123\n\
    \x06prefix\x18\x03\x20\x01(\x0b2\x1b.gobgpapi.LsAttributePrefixR\x06pref\
    ix\"R\n\x10UnknownAttribute\x12\x14\n\x05flags\x18\x01\x20\x01(\rR\x05fl\
    ags\x12\x12\n\x04type\x18\x02\x20\x01(\rR\x04type\x12\x14\n\x05value\x18\
    \x03\x20\x01(\x0cR\x05value*s\n\nLsNLRIType\x12\x13\n\x0fLS_NLRI_UNKNOWN\
    \x10\0\x12\x10\n\x0cLS_NLRI_NODE\x10\x01\x12\x10\n\x0cLS_NLRI_LINK\x10\
    \x02\x12\x15\n\x11LS_NLRI_PREFIX_V4\x10\x03\x12\x15\n\x11LS_NLRI_PREFIX_\
    V6\x10\x04b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
