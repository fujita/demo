// This file is generated by rust-protobuf 2.8.1. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `gobgp.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_1;

#[derive(PartialEq,Clone,Default)]
pub struct StartBgpRequest {
    // message fields
    pub global: ::protobuf::SingularPtrField<Global>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StartBgpRequest {
    fn default() -> &'a StartBgpRequest {
        <StartBgpRequest as ::protobuf::Message>::default_instance()
    }
}

impl StartBgpRequest {
    pub fn new() -> StartBgpRequest {
        ::std::default::Default::default()
    }

    // .gobgpapi.Global global = 1;


    pub fn get_global(&self) -> &Global {
        self.global.as_ref().unwrap_or_else(|| Global::default_instance())
    }
    pub fn clear_global(&mut self) {
        self.global.clear();
    }

    pub fn has_global(&self) -> bool {
        self.global.is_some()
    }

    // Param is passed by value, moved
    pub fn set_global(&mut self, v: Global) {
        self.global = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_global(&mut self) -> &mut Global {
        if self.global.is_none() {
            self.global.set_default();
        }
        self.global.as_mut().unwrap()
    }

    // Take field
    pub fn take_global(&mut self) -> Global {
        self.global.take().unwrap_or_else(|| Global::new())
    }
}

impl ::protobuf::Message for StartBgpRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.global {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.global)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.global.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.global.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StartBgpRequest {
        StartBgpRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Global>>(
                    "global",
                    |m: &StartBgpRequest| { &m.global },
                    |m: &mut StartBgpRequest| { &mut m.global },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StartBgpRequest>(
                    "StartBgpRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StartBgpRequest {
        static mut instance: ::protobuf::lazy::Lazy<StartBgpRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StartBgpRequest,
        };
        unsafe {
            instance.get(StartBgpRequest::new)
        }
    }
}

impl ::protobuf::Clear for StartBgpRequest {
    fn clear(&mut self) {
        self.global.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StartBgpRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StartBgpRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StopBgpRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StopBgpRequest {
    fn default() -> &'a StopBgpRequest {
        <StopBgpRequest as ::protobuf::Message>::default_instance()
    }
}

impl StopBgpRequest {
    pub fn new() -> StopBgpRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for StopBgpRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StopBgpRequest {
        StopBgpRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<StopBgpRequest>(
                    "StopBgpRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StopBgpRequest {
        static mut instance: ::protobuf::lazy::Lazy<StopBgpRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StopBgpRequest,
        };
        unsafe {
            instance.get(StopBgpRequest::new)
        }
    }
}

impl ::protobuf::Clear for StopBgpRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StopBgpRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StopBgpRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetBgpRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetBgpRequest {
    fn default() -> &'a GetBgpRequest {
        <GetBgpRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetBgpRequest {
    pub fn new() -> GetBgpRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetBgpRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetBgpRequest {
        GetBgpRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<GetBgpRequest>(
                    "GetBgpRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetBgpRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetBgpRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetBgpRequest,
        };
        unsafe {
            instance.get(GetBgpRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetBgpRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetBgpRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBgpRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetBgpResponse {
    // message fields
    pub global: ::protobuf::SingularPtrField<Global>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetBgpResponse {
    fn default() -> &'a GetBgpResponse {
        <GetBgpResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetBgpResponse {
    pub fn new() -> GetBgpResponse {
        ::std::default::Default::default()
    }

    // .gobgpapi.Global global = 1;


    pub fn get_global(&self) -> &Global {
        self.global.as_ref().unwrap_or_else(|| Global::default_instance())
    }
    pub fn clear_global(&mut self) {
        self.global.clear();
    }

    pub fn has_global(&self) -> bool {
        self.global.is_some()
    }

    // Param is passed by value, moved
    pub fn set_global(&mut self, v: Global) {
        self.global = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_global(&mut self) -> &mut Global {
        if self.global.is_none() {
            self.global.set_default();
        }
        self.global.as_mut().unwrap()
    }

    // Take field
    pub fn take_global(&mut self) -> Global {
        self.global.take().unwrap_or_else(|| Global::new())
    }
}

impl ::protobuf::Message for GetBgpResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.global {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.global)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.global.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.global.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetBgpResponse {
        GetBgpResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Global>>(
                    "global",
                    |m: &GetBgpResponse| { &m.global },
                    |m: &mut GetBgpResponse| { &mut m.global },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetBgpResponse>(
                    "GetBgpResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetBgpResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetBgpResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetBgpResponse,
        };
        unsafe {
            instance.get(GetBgpResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetBgpResponse {
    fn clear(&mut self) {
        self.global.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetBgpResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBgpResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddPeerRequest {
    // message fields
    pub peer: ::protobuf::SingularPtrField<Peer>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddPeerRequest {
    fn default() -> &'a AddPeerRequest {
        <AddPeerRequest as ::protobuf::Message>::default_instance()
    }
}

impl AddPeerRequest {
    pub fn new() -> AddPeerRequest {
        ::std::default::Default::default()
    }

    // .gobgpapi.Peer peer = 1;


    pub fn get_peer(&self) -> &Peer {
        self.peer.as_ref().unwrap_or_else(|| Peer::default_instance())
    }
    pub fn clear_peer(&mut self) {
        self.peer.clear();
    }

    pub fn has_peer(&self) -> bool {
        self.peer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_peer(&mut self, v: Peer) {
        self.peer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_peer(&mut self) -> &mut Peer {
        if self.peer.is_none() {
            self.peer.set_default();
        }
        self.peer.as_mut().unwrap()
    }

    // Take field
    pub fn take_peer(&mut self) -> Peer {
        self.peer.take().unwrap_or_else(|| Peer::new())
    }
}

impl ::protobuf::Message for AddPeerRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.peer {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.peer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.peer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.peer.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddPeerRequest {
        AddPeerRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Peer>>(
                    "peer",
                    |m: &AddPeerRequest| { &m.peer },
                    |m: &mut AddPeerRequest| { &mut m.peer },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddPeerRequest>(
                    "AddPeerRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AddPeerRequest {
        static mut instance: ::protobuf::lazy::Lazy<AddPeerRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddPeerRequest,
        };
        unsafe {
            instance.get(AddPeerRequest::new)
        }
    }
}

impl ::protobuf::Clear for AddPeerRequest {
    fn clear(&mut self) {
        self.peer.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddPeerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddPeerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeletePeerRequest {
    // message fields
    pub address: ::std::string::String,
    pub interface: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeletePeerRequest {
    fn default() -> &'a DeletePeerRequest {
        <DeletePeerRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeletePeerRequest {
    pub fn new() -> DeletePeerRequest {
        ::std::default::Default::default()
    }

    // string address = 1;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // string interface = 2;


    pub fn get_interface(&self) -> &str {
        &self.interface
    }
    pub fn clear_interface(&mut self) {
        self.interface.clear();
    }

    // Param is passed by value, moved
    pub fn set_interface(&mut self, v: ::std::string::String) {
        self.interface = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_interface(&mut self) -> &mut ::std::string::String {
        &mut self.interface
    }

    // Take field
    pub fn take_interface(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.interface, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeletePeerRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.interface)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if !self.interface.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.interface);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if !self.interface.is_empty() {
            os.write_string(2, &self.interface)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeletePeerRequest {
        DeletePeerRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "address",
                    |m: &DeletePeerRequest| { &m.address },
                    |m: &mut DeletePeerRequest| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "interface",
                    |m: &DeletePeerRequest| { &m.interface },
                    |m: &mut DeletePeerRequest| { &mut m.interface },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeletePeerRequest>(
                    "DeletePeerRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeletePeerRequest {
        static mut instance: ::protobuf::lazy::Lazy<DeletePeerRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeletePeerRequest,
        };
        unsafe {
            instance.get(DeletePeerRequest::new)
        }
    }
}

impl ::protobuf::Clear for DeletePeerRequest {
    fn clear(&mut self) {
        self.address.clear();
        self.interface.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeletePeerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeletePeerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListPeerRequest {
    // message fields
    pub address: ::std::string::String,
    pub enableAdvertised: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListPeerRequest {
    fn default() -> &'a ListPeerRequest {
        <ListPeerRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListPeerRequest {
    pub fn new() -> ListPeerRequest {
        ::std::default::Default::default()
    }

    // string address = 1;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // bool enableAdvertised = 2;


    pub fn get_enableAdvertised(&self) -> bool {
        self.enableAdvertised
    }
    pub fn clear_enableAdvertised(&mut self) {
        self.enableAdvertised = false;
    }

    // Param is passed by value, moved
    pub fn set_enableAdvertised(&mut self, v: bool) {
        self.enableAdvertised = v;
    }
}

impl ::protobuf::Message for ListPeerRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enableAdvertised = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if self.enableAdvertised != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if self.enableAdvertised != false {
            os.write_bool(2, self.enableAdvertised)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListPeerRequest {
        ListPeerRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "address",
                    |m: &ListPeerRequest| { &m.address },
                    |m: &mut ListPeerRequest| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "enableAdvertised",
                    |m: &ListPeerRequest| { &m.enableAdvertised },
                    |m: &mut ListPeerRequest| { &mut m.enableAdvertised },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListPeerRequest>(
                    "ListPeerRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListPeerRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListPeerRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListPeerRequest,
        };
        unsafe {
            instance.get(ListPeerRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListPeerRequest {
    fn clear(&mut self) {
        self.address.clear();
        self.enableAdvertised = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListPeerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListPeerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListPeerResponse {
    // message fields
    pub peer: ::protobuf::SingularPtrField<Peer>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListPeerResponse {
    fn default() -> &'a ListPeerResponse {
        <ListPeerResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListPeerResponse {
    pub fn new() -> ListPeerResponse {
        ::std::default::Default::default()
    }

    // .gobgpapi.Peer peer = 1;


    pub fn get_peer(&self) -> &Peer {
        self.peer.as_ref().unwrap_or_else(|| Peer::default_instance())
    }
    pub fn clear_peer(&mut self) {
        self.peer.clear();
    }

    pub fn has_peer(&self) -> bool {
        self.peer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_peer(&mut self, v: Peer) {
        self.peer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_peer(&mut self) -> &mut Peer {
        if self.peer.is_none() {
            self.peer.set_default();
        }
        self.peer.as_mut().unwrap()
    }

    // Take field
    pub fn take_peer(&mut self) -> Peer {
        self.peer.take().unwrap_or_else(|| Peer::new())
    }
}

impl ::protobuf::Message for ListPeerResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.peer {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.peer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.peer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.peer.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListPeerResponse {
        ListPeerResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Peer>>(
                    "peer",
                    |m: &ListPeerResponse| { &m.peer },
                    |m: &mut ListPeerResponse| { &mut m.peer },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListPeerResponse>(
                    "ListPeerResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListPeerResponse {
        static mut instance: ::protobuf::lazy::Lazy<ListPeerResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListPeerResponse,
        };
        unsafe {
            instance.get(ListPeerResponse::new)
        }
    }
}

impl ::protobuf::Clear for ListPeerResponse {
    fn clear(&mut self) {
        self.peer.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListPeerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListPeerResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdatePeerRequest {
    // message fields
    pub peer: ::protobuf::SingularPtrField<Peer>,
    pub do_soft_reset_in: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdatePeerRequest {
    fn default() -> &'a UpdatePeerRequest {
        <UpdatePeerRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdatePeerRequest {
    pub fn new() -> UpdatePeerRequest {
        ::std::default::Default::default()
    }

    // .gobgpapi.Peer peer = 1;


    pub fn get_peer(&self) -> &Peer {
        self.peer.as_ref().unwrap_or_else(|| Peer::default_instance())
    }
    pub fn clear_peer(&mut self) {
        self.peer.clear();
    }

    pub fn has_peer(&self) -> bool {
        self.peer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_peer(&mut self, v: Peer) {
        self.peer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_peer(&mut self) -> &mut Peer {
        if self.peer.is_none() {
            self.peer.set_default();
        }
        self.peer.as_mut().unwrap()
    }

    // Take field
    pub fn take_peer(&mut self) -> Peer {
        self.peer.take().unwrap_or_else(|| Peer::new())
    }

    // bool do_soft_reset_in = 2;


    pub fn get_do_soft_reset_in(&self) -> bool {
        self.do_soft_reset_in
    }
    pub fn clear_do_soft_reset_in(&mut self) {
        self.do_soft_reset_in = false;
    }

    // Param is passed by value, moved
    pub fn set_do_soft_reset_in(&mut self, v: bool) {
        self.do_soft_reset_in = v;
    }
}

impl ::protobuf::Message for UpdatePeerRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.peer {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.peer)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.do_soft_reset_in = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.peer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.do_soft_reset_in != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.peer.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.do_soft_reset_in != false {
            os.write_bool(2, self.do_soft_reset_in)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdatePeerRequest {
        UpdatePeerRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Peer>>(
                    "peer",
                    |m: &UpdatePeerRequest| { &m.peer },
                    |m: &mut UpdatePeerRequest| { &mut m.peer },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "do_soft_reset_in",
                    |m: &UpdatePeerRequest| { &m.do_soft_reset_in },
                    |m: &mut UpdatePeerRequest| { &mut m.do_soft_reset_in },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UpdatePeerRequest>(
                    "UpdatePeerRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UpdatePeerRequest {
        static mut instance: ::protobuf::lazy::Lazy<UpdatePeerRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UpdatePeerRequest,
        };
        unsafe {
            instance.get(UpdatePeerRequest::new)
        }
    }
}

impl ::protobuf::Clear for UpdatePeerRequest {
    fn clear(&mut self) {
        self.peer.clear();
        self.do_soft_reset_in = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdatePeerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdatePeerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdatePeerResponse {
    // message fields
    pub needs_soft_reset_in: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdatePeerResponse {
    fn default() -> &'a UpdatePeerResponse {
        <UpdatePeerResponse as ::protobuf::Message>::default_instance()
    }
}

impl UpdatePeerResponse {
    pub fn new() -> UpdatePeerResponse {
        ::std::default::Default::default()
    }

    // bool needs_soft_reset_in = 1;


    pub fn get_needs_soft_reset_in(&self) -> bool {
        self.needs_soft_reset_in
    }
    pub fn clear_needs_soft_reset_in(&mut self) {
        self.needs_soft_reset_in = false;
    }

    // Param is passed by value, moved
    pub fn set_needs_soft_reset_in(&mut self, v: bool) {
        self.needs_soft_reset_in = v;
    }
}

impl ::protobuf::Message for UpdatePeerResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.needs_soft_reset_in = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.needs_soft_reset_in != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.needs_soft_reset_in != false {
            os.write_bool(1, self.needs_soft_reset_in)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdatePeerResponse {
        UpdatePeerResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "needs_soft_reset_in",
                    |m: &UpdatePeerResponse| { &m.needs_soft_reset_in },
                    |m: &mut UpdatePeerResponse| { &mut m.needs_soft_reset_in },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UpdatePeerResponse>(
                    "UpdatePeerResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UpdatePeerResponse {
        static mut instance: ::protobuf::lazy::Lazy<UpdatePeerResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UpdatePeerResponse,
        };
        unsafe {
            instance.get(UpdatePeerResponse::new)
        }
    }
}

impl ::protobuf::Clear for UpdatePeerResponse {
    fn clear(&mut self) {
        self.needs_soft_reset_in = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdatePeerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdatePeerResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResetPeerRequest {
    // message fields
    pub address: ::std::string::String,
    pub communication: ::std::string::String,
    pub soft: bool,
    pub direction: ResetPeerRequest_SoftResetDirection,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResetPeerRequest {
    fn default() -> &'a ResetPeerRequest {
        <ResetPeerRequest as ::protobuf::Message>::default_instance()
    }
}

impl ResetPeerRequest {
    pub fn new() -> ResetPeerRequest {
        ::std::default::Default::default()
    }

    // string address = 1;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // string communication = 2;


    pub fn get_communication(&self) -> &str {
        &self.communication
    }
    pub fn clear_communication(&mut self) {
        self.communication.clear();
    }

    // Param is passed by value, moved
    pub fn set_communication(&mut self, v: ::std::string::String) {
        self.communication = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_communication(&mut self) -> &mut ::std::string::String {
        &mut self.communication
    }

    // Take field
    pub fn take_communication(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.communication, ::std::string::String::new())
    }

    // bool soft = 3;


    pub fn get_soft(&self) -> bool {
        self.soft
    }
    pub fn clear_soft(&mut self) {
        self.soft = false;
    }

    // Param is passed by value, moved
    pub fn set_soft(&mut self, v: bool) {
        self.soft = v;
    }

    // .gobgpapi.ResetPeerRequest.SoftResetDirection direction = 4;


    pub fn get_direction(&self) -> ResetPeerRequest_SoftResetDirection {
        self.direction
    }
    pub fn clear_direction(&mut self) {
        self.direction = ResetPeerRequest_SoftResetDirection::IN;
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: ResetPeerRequest_SoftResetDirection) {
        self.direction = v;
    }
}

impl ::protobuf::Message for ResetPeerRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.communication)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.soft = tmp;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.direction, 4, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if !self.communication.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.communication);
        }
        if self.soft != false {
            my_size += 2;
        }
        if self.direction != ResetPeerRequest_SoftResetDirection::IN {
            my_size += ::protobuf::rt::enum_size(4, self.direction);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if !self.communication.is_empty() {
            os.write_string(2, &self.communication)?;
        }
        if self.soft != false {
            os.write_bool(3, self.soft)?;
        }
        if self.direction != ResetPeerRequest_SoftResetDirection::IN {
            os.write_enum(4, self.direction.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResetPeerRequest {
        ResetPeerRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "address",
                    |m: &ResetPeerRequest| { &m.address },
                    |m: &mut ResetPeerRequest| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "communication",
                    |m: &ResetPeerRequest| { &m.communication },
                    |m: &mut ResetPeerRequest| { &mut m.communication },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "soft",
                    |m: &ResetPeerRequest| { &m.soft },
                    |m: &mut ResetPeerRequest| { &mut m.soft },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ResetPeerRequest_SoftResetDirection>>(
                    "direction",
                    |m: &ResetPeerRequest| { &m.direction },
                    |m: &mut ResetPeerRequest| { &mut m.direction },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ResetPeerRequest>(
                    "ResetPeerRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ResetPeerRequest {
        static mut instance: ::protobuf::lazy::Lazy<ResetPeerRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ResetPeerRequest,
        };
        unsafe {
            instance.get(ResetPeerRequest::new)
        }
    }
}

impl ::protobuf::Clear for ResetPeerRequest {
    fn clear(&mut self) {
        self.address.clear();
        self.communication.clear();
        self.soft = false;
        self.direction = ResetPeerRequest_SoftResetDirection::IN;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResetPeerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResetPeerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ResetPeerRequest_SoftResetDirection {
    IN = 0,
    OUT = 1,
    BOTH = 2,
}

impl ::protobuf::ProtobufEnum for ResetPeerRequest_SoftResetDirection {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ResetPeerRequest_SoftResetDirection> {
        match value {
            0 => ::std::option::Option::Some(ResetPeerRequest_SoftResetDirection::IN),
            1 => ::std::option::Option::Some(ResetPeerRequest_SoftResetDirection::OUT),
            2 => ::std::option::Option::Some(ResetPeerRequest_SoftResetDirection::BOTH),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ResetPeerRequest_SoftResetDirection] = &[
            ResetPeerRequest_SoftResetDirection::IN,
            ResetPeerRequest_SoftResetDirection::OUT,
            ResetPeerRequest_SoftResetDirection::BOTH,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ResetPeerRequest_SoftResetDirection", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ResetPeerRequest_SoftResetDirection {
}

impl ::std::default::Default for ResetPeerRequest_SoftResetDirection {
    fn default() -> Self {
        ResetPeerRequest_SoftResetDirection::IN
    }
}

impl ::protobuf::reflect::ProtobufValue for ResetPeerRequest_SoftResetDirection {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ShutdownPeerRequest {
    // message fields
    pub address: ::std::string::String,
    pub communication: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ShutdownPeerRequest {
    fn default() -> &'a ShutdownPeerRequest {
        <ShutdownPeerRequest as ::protobuf::Message>::default_instance()
    }
}

impl ShutdownPeerRequest {
    pub fn new() -> ShutdownPeerRequest {
        ::std::default::Default::default()
    }

    // string address = 1;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // string communication = 2;


    pub fn get_communication(&self) -> &str {
        &self.communication
    }
    pub fn clear_communication(&mut self) {
        self.communication.clear();
    }

    // Param is passed by value, moved
    pub fn set_communication(&mut self, v: ::std::string::String) {
        self.communication = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_communication(&mut self) -> &mut ::std::string::String {
        &mut self.communication
    }

    // Take field
    pub fn take_communication(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.communication, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ShutdownPeerRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.communication)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if !self.communication.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.communication);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if !self.communication.is_empty() {
            os.write_string(2, &self.communication)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ShutdownPeerRequest {
        ShutdownPeerRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "address",
                    |m: &ShutdownPeerRequest| { &m.address },
                    |m: &mut ShutdownPeerRequest| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "communication",
                    |m: &ShutdownPeerRequest| { &m.communication },
                    |m: &mut ShutdownPeerRequest| { &mut m.communication },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ShutdownPeerRequest>(
                    "ShutdownPeerRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ShutdownPeerRequest {
        static mut instance: ::protobuf::lazy::Lazy<ShutdownPeerRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ShutdownPeerRequest,
        };
        unsafe {
            instance.get(ShutdownPeerRequest::new)
        }
    }
}

impl ::protobuf::Clear for ShutdownPeerRequest {
    fn clear(&mut self) {
        self.address.clear();
        self.communication.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ShutdownPeerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ShutdownPeerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EnablePeerRequest {
    // message fields
    pub address: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EnablePeerRequest {
    fn default() -> &'a EnablePeerRequest {
        <EnablePeerRequest as ::protobuf::Message>::default_instance()
    }
}

impl EnablePeerRequest {
    pub fn new() -> EnablePeerRequest {
        ::std::default::Default::default()
    }

    // string address = 1;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }
}

impl ::protobuf::Message for EnablePeerRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EnablePeerRequest {
        EnablePeerRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "address",
                    |m: &EnablePeerRequest| { &m.address },
                    |m: &mut EnablePeerRequest| { &mut m.address },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EnablePeerRequest>(
                    "EnablePeerRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EnablePeerRequest {
        static mut instance: ::protobuf::lazy::Lazy<EnablePeerRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EnablePeerRequest,
        };
        unsafe {
            instance.get(EnablePeerRequest::new)
        }
    }
}

impl ::protobuf::Clear for EnablePeerRequest {
    fn clear(&mut self) {
        self.address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EnablePeerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EnablePeerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DisablePeerRequest {
    // message fields
    pub address: ::std::string::String,
    pub communication: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DisablePeerRequest {
    fn default() -> &'a DisablePeerRequest {
        <DisablePeerRequest as ::protobuf::Message>::default_instance()
    }
}

impl DisablePeerRequest {
    pub fn new() -> DisablePeerRequest {
        ::std::default::Default::default()
    }

    // string address = 1;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // string communication = 2;


    pub fn get_communication(&self) -> &str {
        &self.communication
    }
    pub fn clear_communication(&mut self) {
        self.communication.clear();
    }

    // Param is passed by value, moved
    pub fn set_communication(&mut self, v: ::std::string::String) {
        self.communication = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_communication(&mut self) -> &mut ::std::string::String {
        &mut self.communication
    }

    // Take field
    pub fn take_communication(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.communication, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DisablePeerRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.communication)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if !self.communication.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.communication);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if !self.communication.is_empty() {
            os.write_string(2, &self.communication)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DisablePeerRequest {
        DisablePeerRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "address",
                    |m: &DisablePeerRequest| { &m.address },
                    |m: &mut DisablePeerRequest| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "communication",
                    |m: &DisablePeerRequest| { &m.communication },
                    |m: &mut DisablePeerRequest| { &mut m.communication },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DisablePeerRequest>(
                    "DisablePeerRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DisablePeerRequest {
        static mut instance: ::protobuf::lazy::Lazy<DisablePeerRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DisablePeerRequest,
        };
        unsafe {
            instance.get(DisablePeerRequest::new)
        }
    }
}

impl ::protobuf::Clear for DisablePeerRequest {
    fn clear(&mut self) {
        self.address.clear();
        self.communication.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DisablePeerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DisablePeerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MonitorPeerRequest {
    // message fields
    pub address: ::std::string::String,
    pub current: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MonitorPeerRequest {
    fn default() -> &'a MonitorPeerRequest {
        <MonitorPeerRequest as ::protobuf::Message>::default_instance()
    }
}

impl MonitorPeerRequest {
    pub fn new() -> MonitorPeerRequest {
        ::std::default::Default::default()
    }

    // string address = 1;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // bool current = 2;


    pub fn get_current(&self) -> bool {
        self.current
    }
    pub fn clear_current(&mut self) {
        self.current = false;
    }

    // Param is passed by value, moved
    pub fn set_current(&mut self, v: bool) {
        self.current = v;
    }
}

impl ::protobuf::Message for MonitorPeerRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.current = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if self.current != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if self.current != false {
            os.write_bool(2, self.current)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MonitorPeerRequest {
        MonitorPeerRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "address",
                    |m: &MonitorPeerRequest| { &m.address },
                    |m: &mut MonitorPeerRequest| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "current",
                    |m: &MonitorPeerRequest| { &m.current },
                    |m: &mut MonitorPeerRequest| { &mut m.current },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MonitorPeerRequest>(
                    "MonitorPeerRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MonitorPeerRequest {
        static mut instance: ::protobuf::lazy::Lazy<MonitorPeerRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MonitorPeerRequest,
        };
        unsafe {
            instance.get(MonitorPeerRequest::new)
        }
    }
}

impl ::protobuf::Clear for MonitorPeerRequest {
    fn clear(&mut self) {
        self.address.clear();
        self.current = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MonitorPeerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MonitorPeerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MonitorPeerResponse {
    // message fields
    pub peer: ::protobuf::SingularPtrField<Peer>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MonitorPeerResponse {
    fn default() -> &'a MonitorPeerResponse {
        <MonitorPeerResponse as ::protobuf::Message>::default_instance()
    }
}

impl MonitorPeerResponse {
    pub fn new() -> MonitorPeerResponse {
        ::std::default::Default::default()
    }

    // .gobgpapi.Peer peer = 1;


    pub fn get_peer(&self) -> &Peer {
        self.peer.as_ref().unwrap_or_else(|| Peer::default_instance())
    }
    pub fn clear_peer(&mut self) {
        self.peer.clear();
    }

    pub fn has_peer(&self) -> bool {
        self.peer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_peer(&mut self, v: Peer) {
        self.peer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_peer(&mut self) -> &mut Peer {
        if self.peer.is_none() {
            self.peer.set_default();
        }
        self.peer.as_mut().unwrap()
    }

    // Take field
    pub fn take_peer(&mut self) -> Peer {
        self.peer.take().unwrap_or_else(|| Peer::new())
    }
}

impl ::protobuf::Message for MonitorPeerResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.peer {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.peer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.peer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.peer.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MonitorPeerResponse {
        MonitorPeerResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Peer>>(
                    "peer",
                    |m: &MonitorPeerResponse| { &m.peer },
                    |m: &mut MonitorPeerResponse| { &mut m.peer },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MonitorPeerResponse>(
                    "MonitorPeerResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MonitorPeerResponse {
        static mut instance: ::protobuf::lazy::Lazy<MonitorPeerResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MonitorPeerResponse,
        };
        unsafe {
            instance.get(MonitorPeerResponse::new)
        }
    }
}

impl ::protobuf::Clear for MonitorPeerResponse {
    fn clear(&mut self) {
        self.peer.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MonitorPeerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MonitorPeerResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddPeerGroupRequest {
    // message fields
    pub peer_group: ::protobuf::SingularPtrField<PeerGroup>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddPeerGroupRequest {
    fn default() -> &'a AddPeerGroupRequest {
        <AddPeerGroupRequest as ::protobuf::Message>::default_instance()
    }
}

impl AddPeerGroupRequest {
    pub fn new() -> AddPeerGroupRequest {
        ::std::default::Default::default()
    }

    // .gobgpapi.PeerGroup peer_group = 1;


    pub fn get_peer_group(&self) -> &PeerGroup {
        self.peer_group.as_ref().unwrap_or_else(|| PeerGroup::default_instance())
    }
    pub fn clear_peer_group(&mut self) {
        self.peer_group.clear();
    }

    pub fn has_peer_group(&self) -> bool {
        self.peer_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_peer_group(&mut self, v: PeerGroup) {
        self.peer_group = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_peer_group(&mut self) -> &mut PeerGroup {
        if self.peer_group.is_none() {
            self.peer_group.set_default();
        }
        self.peer_group.as_mut().unwrap()
    }

    // Take field
    pub fn take_peer_group(&mut self) -> PeerGroup {
        self.peer_group.take().unwrap_or_else(|| PeerGroup::new())
    }
}

impl ::protobuf::Message for AddPeerGroupRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.peer_group {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.peer_group)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.peer_group.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.peer_group.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddPeerGroupRequest {
        AddPeerGroupRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PeerGroup>>(
                    "peer_group",
                    |m: &AddPeerGroupRequest| { &m.peer_group },
                    |m: &mut AddPeerGroupRequest| { &mut m.peer_group },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddPeerGroupRequest>(
                    "AddPeerGroupRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AddPeerGroupRequest {
        static mut instance: ::protobuf::lazy::Lazy<AddPeerGroupRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddPeerGroupRequest,
        };
        unsafe {
            instance.get(AddPeerGroupRequest::new)
        }
    }
}

impl ::protobuf::Clear for AddPeerGroupRequest {
    fn clear(&mut self) {
        self.peer_group.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddPeerGroupRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddPeerGroupRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeletePeerGroupRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeletePeerGroupRequest {
    fn default() -> &'a DeletePeerGroupRequest {
        <DeletePeerGroupRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeletePeerGroupRequest {
    pub fn new() -> DeletePeerGroupRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeletePeerGroupRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeletePeerGroupRequest {
        DeletePeerGroupRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &DeletePeerGroupRequest| { &m.name },
                    |m: &mut DeletePeerGroupRequest| { &mut m.name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeletePeerGroupRequest>(
                    "DeletePeerGroupRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeletePeerGroupRequest {
        static mut instance: ::protobuf::lazy::Lazy<DeletePeerGroupRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeletePeerGroupRequest,
        };
        unsafe {
            instance.get(DeletePeerGroupRequest::new)
        }
    }
}

impl ::protobuf::Clear for DeletePeerGroupRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeletePeerGroupRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeletePeerGroupRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdatePeerGroupRequest {
    // message fields
    pub peer_group: ::protobuf::SingularPtrField<PeerGroup>,
    pub do_soft_reset_in: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdatePeerGroupRequest {
    fn default() -> &'a UpdatePeerGroupRequest {
        <UpdatePeerGroupRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdatePeerGroupRequest {
    pub fn new() -> UpdatePeerGroupRequest {
        ::std::default::Default::default()
    }

    // .gobgpapi.PeerGroup peer_group = 1;


    pub fn get_peer_group(&self) -> &PeerGroup {
        self.peer_group.as_ref().unwrap_or_else(|| PeerGroup::default_instance())
    }
    pub fn clear_peer_group(&mut self) {
        self.peer_group.clear();
    }

    pub fn has_peer_group(&self) -> bool {
        self.peer_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_peer_group(&mut self, v: PeerGroup) {
        self.peer_group = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_peer_group(&mut self) -> &mut PeerGroup {
        if self.peer_group.is_none() {
            self.peer_group.set_default();
        }
        self.peer_group.as_mut().unwrap()
    }

    // Take field
    pub fn take_peer_group(&mut self) -> PeerGroup {
        self.peer_group.take().unwrap_or_else(|| PeerGroup::new())
    }

    // bool do_soft_reset_in = 2;


    pub fn get_do_soft_reset_in(&self) -> bool {
        self.do_soft_reset_in
    }
    pub fn clear_do_soft_reset_in(&mut self) {
        self.do_soft_reset_in = false;
    }

    // Param is passed by value, moved
    pub fn set_do_soft_reset_in(&mut self, v: bool) {
        self.do_soft_reset_in = v;
    }
}

impl ::protobuf::Message for UpdatePeerGroupRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.peer_group {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.peer_group)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.do_soft_reset_in = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.peer_group.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.do_soft_reset_in != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.peer_group.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.do_soft_reset_in != false {
            os.write_bool(2, self.do_soft_reset_in)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdatePeerGroupRequest {
        UpdatePeerGroupRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PeerGroup>>(
                    "peer_group",
                    |m: &UpdatePeerGroupRequest| { &m.peer_group },
                    |m: &mut UpdatePeerGroupRequest| { &mut m.peer_group },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "do_soft_reset_in",
                    |m: &UpdatePeerGroupRequest| { &m.do_soft_reset_in },
                    |m: &mut UpdatePeerGroupRequest| { &mut m.do_soft_reset_in },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UpdatePeerGroupRequest>(
                    "UpdatePeerGroupRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UpdatePeerGroupRequest {
        static mut instance: ::protobuf::lazy::Lazy<UpdatePeerGroupRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UpdatePeerGroupRequest,
        };
        unsafe {
            instance.get(UpdatePeerGroupRequest::new)
        }
    }
}

impl ::protobuf::Clear for UpdatePeerGroupRequest {
    fn clear(&mut self) {
        self.peer_group.clear();
        self.do_soft_reset_in = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdatePeerGroupRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdatePeerGroupRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdatePeerGroupResponse {
    // message fields
    pub needs_soft_reset_in: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdatePeerGroupResponse {
    fn default() -> &'a UpdatePeerGroupResponse {
        <UpdatePeerGroupResponse as ::protobuf::Message>::default_instance()
    }
}

impl UpdatePeerGroupResponse {
    pub fn new() -> UpdatePeerGroupResponse {
        ::std::default::Default::default()
    }

    // bool needs_soft_reset_in = 1;


    pub fn get_needs_soft_reset_in(&self) -> bool {
        self.needs_soft_reset_in
    }
    pub fn clear_needs_soft_reset_in(&mut self) {
        self.needs_soft_reset_in = false;
    }

    // Param is passed by value, moved
    pub fn set_needs_soft_reset_in(&mut self, v: bool) {
        self.needs_soft_reset_in = v;
    }
}

impl ::protobuf::Message for UpdatePeerGroupResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.needs_soft_reset_in = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.needs_soft_reset_in != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.needs_soft_reset_in != false {
            os.write_bool(1, self.needs_soft_reset_in)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdatePeerGroupResponse {
        UpdatePeerGroupResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "needs_soft_reset_in",
                    |m: &UpdatePeerGroupResponse| { &m.needs_soft_reset_in },
                    |m: &mut UpdatePeerGroupResponse| { &mut m.needs_soft_reset_in },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UpdatePeerGroupResponse>(
                    "UpdatePeerGroupResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UpdatePeerGroupResponse {
        static mut instance: ::protobuf::lazy::Lazy<UpdatePeerGroupResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UpdatePeerGroupResponse,
        };
        unsafe {
            instance.get(UpdatePeerGroupResponse::new)
        }
    }
}

impl ::protobuf::Clear for UpdatePeerGroupResponse {
    fn clear(&mut self) {
        self.needs_soft_reset_in = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdatePeerGroupResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdatePeerGroupResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddDynamicNeighborRequest {
    // message fields
    pub dynamic_neighbor: ::protobuf::SingularPtrField<DynamicNeighbor>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddDynamicNeighborRequest {
    fn default() -> &'a AddDynamicNeighborRequest {
        <AddDynamicNeighborRequest as ::protobuf::Message>::default_instance()
    }
}

impl AddDynamicNeighborRequest {
    pub fn new() -> AddDynamicNeighborRequest {
        ::std::default::Default::default()
    }

    // .gobgpapi.DynamicNeighbor dynamic_neighbor = 1;


    pub fn get_dynamic_neighbor(&self) -> &DynamicNeighbor {
        self.dynamic_neighbor.as_ref().unwrap_or_else(|| DynamicNeighbor::default_instance())
    }
    pub fn clear_dynamic_neighbor(&mut self) {
        self.dynamic_neighbor.clear();
    }

    pub fn has_dynamic_neighbor(&self) -> bool {
        self.dynamic_neighbor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dynamic_neighbor(&mut self, v: DynamicNeighbor) {
        self.dynamic_neighbor = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dynamic_neighbor(&mut self) -> &mut DynamicNeighbor {
        if self.dynamic_neighbor.is_none() {
            self.dynamic_neighbor.set_default();
        }
        self.dynamic_neighbor.as_mut().unwrap()
    }

    // Take field
    pub fn take_dynamic_neighbor(&mut self) -> DynamicNeighbor {
        self.dynamic_neighbor.take().unwrap_or_else(|| DynamicNeighbor::new())
    }
}

impl ::protobuf::Message for AddDynamicNeighborRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.dynamic_neighbor {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dynamic_neighbor)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.dynamic_neighbor.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.dynamic_neighbor.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddDynamicNeighborRequest {
        AddDynamicNeighborRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DynamicNeighbor>>(
                    "dynamic_neighbor",
                    |m: &AddDynamicNeighborRequest| { &m.dynamic_neighbor },
                    |m: &mut AddDynamicNeighborRequest| { &mut m.dynamic_neighbor },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddDynamicNeighborRequest>(
                    "AddDynamicNeighborRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AddDynamicNeighborRequest {
        static mut instance: ::protobuf::lazy::Lazy<AddDynamicNeighborRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddDynamicNeighborRequest,
        };
        unsafe {
            instance.get(AddDynamicNeighborRequest::new)
        }
    }
}

impl ::protobuf::Clear for AddDynamicNeighborRequest {
    fn clear(&mut self) {
        self.dynamic_neighbor.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddDynamicNeighborRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddDynamicNeighborRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddPathRequest {
    // message fields
    pub table_type: TableType,
    pub vrf_id: ::std::string::String,
    pub path: ::protobuf::SingularPtrField<Path>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddPathRequest {
    fn default() -> &'a AddPathRequest {
        <AddPathRequest as ::protobuf::Message>::default_instance()
    }
}

impl AddPathRequest {
    pub fn new() -> AddPathRequest {
        ::std::default::Default::default()
    }

    // .gobgpapi.TableType table_type = 1;


    pub fn get_table_type(&self) -> TableType {
        self.table_type
    }
    pub fn clear_table_type(&mut self) {
        self.table_type = TableType::GLOBAL;
    }

    // Param is passed by value, moved
    pub fn set_table_type(&mut self, v: TableType) {
        self.table_type = v;
    }

    // string vrf_id = 2;


    pub fn get_vrf_id(&self) -> &str {
        &self.vrf_id
    }
    pub fn clear_vrf_id(&mut self) {
        self.vrf_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_vrf_id(&mut self, v: ::std::string::String) {
        self.vrf_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vrf_id(&mut self) -> &mut ::std::string::String {
        &mut self.vrf_id
    }

    // Take field
    pub fn take_vrf_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.vrf_id, ::std::string::String::new())
    }

    // .gobgpapi.Path path = 3;


    pub fn get_path(&self) -> &Path {
        self.path.as_ref().unwrap_or_else(|| Path::default_instance())
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: Path) {
        self.path = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut Path {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> Path {
        self.path.take().unwrap_or_else(|| Path::new())
    }
}

impl ::protobuf::Message for AddPathRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.path {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.table_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.vrf_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.table_type != TableType::GLOBAL {
            my_size += ::protobuf::rt::enum_size(1, self.table_type);
        }
        if !self.vrf_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.vrf_id);
        }
        if let Some(ref v) = self.path.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.table_type != TableType::GLOBAL {
            os.write_enum(1, self.table_type.value())?;
        }
        if !self.vrf_id.is_empty() {
            os.write_string(2, &self.vrf_id)?;
        }
        if let Some(ref v) = self.path.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddPathRequest {
        AddPathRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TableType>>(
                    "table_type",
                    |m: &AddPathRequest| { &m.table_type },
                    |m: &mut AddPathRequest| { &mut m.table_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "vrf_id",
                    |m: &AddPathRequest| { &m.vrf_id },
                    |m: &mut AddPathRequest| { &mut m.vrf_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Path>>(
                    "path",
                    |m: &AddPathRequest| { &m.path },
                    |m: &mut AddPathRequest| { &mut m.path },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddPathRequest>(
                    "AddPathRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AddPathRequest {
        static mut instance: ::protobuf::lazy::Lazy<AddPathRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddPathRequest,
        };
        unsafe {
            instance.get(AddPathRequest::new)
        }
    }
}

impl ::protobuf::Clear for AddPathRequest {
    fn clear(&mut self) {
        self.table_type = TableType::GLOBAL;
        self.vrf_id.clear();
        self.path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddPathRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddPathRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddPathResponse {
    // message fields
    pub uuid: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddPathResponse {
    fn default() -> &'a AddPathResponse {
        <AddPathResponse as ::protobuf::Message>::default_instance()
    }
}

impl AddPathResponse {
    pub fn new() -> AddPathResponse {
        ::std::default::Default::default()
    }

    // bytes uuid = 1;


    pub fn get_uuid(&self) -> &[u8] {
        &self.uuid
    }
    pub fn clear_uuid(&mut self) {
        self.uuid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uuid(&mut self, v: ::std::vec::Vec<u8>) {
        self.uuid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uuid(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.uuid
    }

    // Take field
    pub fn take_uuid(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.uuid, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for AddPathResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.uuid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.uuid.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.uuid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.uuid.is_empty() {
            os.write_bytes(1, &self.uuid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddPathResponse {
        AddPathResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "uuid",
                    |m: &AddPathResponse| { &m.uuid },
                    |m: &mut AddPathResponse| { &mut m.uuid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddPathResponse>(
                    "AddPathResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AddPathResponse {
        static mut instance: ::protobuf::lazy::Lazy<AddPathResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddPathResponse,
        };
        unsafe {
            instance.get(AddPathResponse::new)
        }
    }
}

impl ::protobuf::Clear for AddPathResponse {
    fn clear(&mut self) {
        self.uuid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddPathResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddPathResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeletePathRequest {
    // message fields
    pub table_type: TableType,
    pub vrf_id: ::std::string::String,
    pub family: ::protobuf::SingularPtrField<Family>,
    pub path: ::protobuf::SingularPtrField<Path>,
    pub uuid: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeletePathRequest {
    fn default() -> &'a DeletePathRequest {
        <DeletePathRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeletePathRequest {
    pub fn new() -> DeletePathRequest {
        ::std::default::Default::default()
    }

    // .gobgpapi.TableType table_type = 1;


    pub fn get_table_type(&self) -> TableType {
        self.table_type
    }
    pub fn clear_table_type(&mut self) {
        self.table_type = TableType::GLOBAL;
    }

    // Param is passed by value, moved
    pub fn set_table_type(&mut self, v: TableType) {
        self.table_type = v;
    }

    // string vrf_id = 2;


    pub fn get_vrf_id(&self) -> &str {
        &self.vrf_id
    }
    pub fn clear_vrf_id(&mut self) {
        self.vrf_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_vrf_id(&mut self, v: ::std::string::String) {
        self.vrf_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vrf_id(&mut self) -> &mut ::std::string::String {
        &mut self.vrf_id
    }

    // Take field
    pub fn take_vrf_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.vrf_id, ::std::string::String::new())
    }

    // .gobgpapi.Family family = 3;


    pub fn get_family(&self) -> &Family {
        self.family.as_ref().unwrap_or_else(|| Family::default_instance())
    }
    pub fn clear_family(&mut self) {
        self.family.clear();
    }

    pub fn has_family(&self) -> bool {
        self.family.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family(&mut self, v: Family) {
        self.family = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_family(&mut self) -> &mut Family {
        if self.family.is_none() {
            self.family.set_default();
        }
        self.family.as_mut().unwrap()
    }

    // Take field
    pub fn take_family(&mut self) -> Family {
        self.family.take().unwrap_or_else(|| Family::new())
    }

    // .gobgpapi.Path path = 4;


    pub fn get_path(&self) -> &Path {
        self.path.as_ref().unwrap_or_else(|| Path::default_instance())
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: Path) {
        self.path = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut Path {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> Path {
        self.path.take().unwrap_or_else(|| Path::new())
    }

    // bytes uuid = 5;


    pub fn get_uuid(&self) -> &[u8] {
        &self.uuid
    }
    pub fn clear_uuid(&mut self) {
        self.uuid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uuid(&mut self, v: ::std::vec::Vec<u8>) {
        self.uuid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uuid(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.uuid
    }

    // Take field
    pub fn take_uuid(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.uuid, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for DeletePathRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.family {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.path {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.table_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.vrf_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.family)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.path)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.uuid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.table_type != TableType::GLOBAL {
            my_size += ::protobuf::rt::enum_size(1, self.table_type);
        }
        if !self.vrf_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.vrf_id);
        }
        if let Some(ref v) = self.family.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.path.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.uuid.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.uuid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.table_type != TableType::GLOBAL {
            os.write_enum(1, self.table_type.value())?;
        }
        if !self.vrf_id.is_empty() {
            os.write_string(2, &self.vrf_id)?;
        }
        if let Some(ref v) = self.family.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.path.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.uuid.is_empty() {
            os.write_bytes(5, &self.uuid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeletePathRequest {
        DeletePathRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TableType>>(
                    "table_type",
                    |m: &DeletePathRequest| { &m.table_type },
                    |m: &mut DeletePathRequest| { &mut m.table_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "vrf_id",
                    |m: &DeletePathRequest| { &m.vrf_id },
                    |m: &mut DeletePathRequest| { &mut m.vrf_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Family>>(
                    "family",
                    |m: &DeletePathRequest| { &m.family },
                    |m: &mut DeletePathRequest| { &mut m.family },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Path>>(
                    "path",
                    |m: &DeletePathRequest| { &m.path },
                    |m: &mut DeletePathRequest| { &mut m.path },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "uuid",
                    |m: &DeletePathRequest| { &m.uuid },
                    |m: &mut DeletePathRequest| { &mut m.uuid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeletePathRequest>(
                    "DeletePathRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeletePathRequest {
        static mut instance: ::protobuf::lazy::Lazy<DeletePathRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeletePathRequest,
        };
        unsafe {
            instance.get(DeletePathRequest::new)
        }
    }
}

impl ::protobuf::Clear for DeletePathRequest {
    fn clear(&mut self) {
        self.table_type = TableType::GLOBAL;
        self.vrf_id.clear();
        self.family.clear();
        self.path.clear();
        self.uuid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeletePathRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeletePathRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListPathRequest {
    // message fields
    pub table_type: TableType,
    pub name: ::std::string::String,
    pub family: ::protobuf::SingularPtrField<Family>,
    pub prefixes: ::protobuf::RepeatedField<TableLookupPrefix>,
    pub sort_type: ListPathRequest_SortType,
    pub enable_filtered: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListPathRequest {
    fn default() -> &'a ListPathRequest {
        <ListPathRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListPathRequest {
    pub fn new() -> ListPathRequest {
        ::std::default::Default::default()
    }

    // .gobgpapi.TableType table_type = 1;


    pub fn get_table_type(&self) -> TableType {
        self.table_type
    }
    pub fn clear_table_type(&mut self) {
        self.table_type = TableType::GLOBAL;
    }

    // Param is passed by value, moved
    pub fn set_table_type(&mut self, v: TableType) {
        self.table_type = v;
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .gobgpapi.Family family = 3;


    pub fn get_family(&self) -> &Family {
        self.family.as_ref().unwrap_or_else(|| Family::default_instance())
    }
    pub fn clear_family(&mut self) {
        self.family.clear();
    }

    pub fn has_family(&self) -> bool {
        self.family.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family(&mut self, v: Family) {
        self.family = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_family(&mut self) -> &mut Family {
        if self.family.is_none() {
            self.family.set_default();
        }
        self.family.as_mut().unwrap()
    }

    // Take field
    pub fn take_family(&mut self) -> Family {
        self.family.take().unwrap_or_else(|| Family::new())
    }

    // repeated .gobgpapi.TableLookupPrefix prefixes = 4;


    pub fn get_prefixes(&self) -> &[TableLookupPrefix] {
        &self.prefixes
    }
    pub fn clear_prefixes(&mut self) {
        self.prefixes.clear();
    }

    // Param is passed by value, moved
    pub fn set_prefixes(&mut self, v: ::protobuf::RepeatedField<TableLookupPrefix>) {
        self.prefixes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_prefixes(&mut self) -> &mut ::protobuf::RepeatedField<TableLookupPrefix> {
        &mut self.prefixes
    }

    // Take field
    pub fn take_prefixes(&mut self) -> ::protobuf::RepeatedField<TableLookupPrefix> {
        ::std::mem::replace(&mut self.prefixes, ::protobuf::RepeatedField::new())
    }

    // .gobgpapi.ListPathRequest.SortType sort_type = 5;


    pub fn get_sort_type(&self) -> ListPathRequest_SortType {
        self.sort_type
    }
    pub fn clear_sort_type(&mut self) {
        self.sort_type = ListPathRequest_SortType::NONE;
    }

    // Param is passed by value, moved
    pub fn set_sort_type(&mut self, v: ListPathRequest_SortType) {
        self.sort_type = v;
    }

    // bool enable_filtered = 6;


    pub fn get_enable_filtered(&self) -> bool {
        self.enable_filtered
    }
    pub fn clear_enable_filtered(&mut self) {
        self.enable_filtered = false;
    }

    // Param is passed by value, moved
    pub fn set_enable_filtered(&mut self, v: bool) {
        self.enable_filtered = v;
    }
}

impl ::protobuf::Message for ListPathRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.family {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.prefixes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.table_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.family)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.prefixes)?;
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.sort_type, 5, &mut self.unknown_fields)?
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_filtered = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.table_type != TableType::GLOBAL {
            my_size += ::protobuf::rt::enum_size(1, self.table_type);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if let Some(ref v) = self.family.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.prefixes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.sort_type != ListPathRequest_SortType::NONE {
            my_size += ::protobuf::rt::enum_size(5, self.sort_type);
        }
        if self.enable_filtered != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.table_type != TableType::GLOBAL {
            os.write_enum(1, self.table_type.value())?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if let Some(ref v) = self.family.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.prefixes {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.sort_type != ListPathRequest_SortType::NONE {
            os.write_enum(5, self.sort_type.value())?;
        }
        if self.enable_filtered != false {
            os.write_bool(6, self.enable_filtered)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListPathRequest {
        ListPathRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TableType>>(
                    "table_type",
                    |m: &ListPathRequest| { &m.table_type },
                    |m: &mut ListPathRequest| { &mut m.table_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &ListPathRequest| { &m.name },
                    |m: &mut ListPathRequest| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Family>>(
                    "family",
                    |m: &ListPathRequest| { &m.family },
                    |m: &mut ListPathRequest| { &mut m.family },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TableLookupPrefix>>(
                    "prefixes",
                    |m: &ListPathRequest| { &m.prefixes },
                    |m: &mut ListPathRequest| { &mut m.prefixes },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ListPathRequest_SortType>>(
                    "sort_type",
                    |m: &ListPathRequest| { &m.sort_type },
                    |m: &mut ListPathRequest| { &mut m.sort_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "enable_filtered",
                    |m: &ListPathRequest| { &m.enable_filtered },
                    |m: &mut ListPathRequest| { &mut m.enable_filtered },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListPathRequest>(
                    "ListPathRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListPathRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListPathRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListPathRequest,
        };
        unsafe {
            instance.get(ListPathRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListPathRequest {
    fn clear(&mut self) {
        self.table_type = TableType::GLOBAL;
        self.name.clear();
        self.family.clear();
        self.prefixes.clear();
        self.sort_type = ListPathRequest_SortType::NONE;
        self.enable_filtered = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListPathRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListPathRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ListPathRequest_SortType {
    NONE = 0,
    PREFIX = 1,
}

impl ::protobuf::ProtobufEnum for ListPathRequest_SortType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ListPathRequest_SortType> {
        match value {
            0 => ::std::option::Option::Some(ListPathRequest_SortType::NONE),
            1 => ::std::option::Option::Some(ListPathRequest_SortType::PREFIX),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ListPathRequest_SortType] = &[
            ListPathRequest_SortType::NONE,
            ListPathRequest_SortType::PREFIX,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ListPathRequest_SortType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ListPathRequest_SortType {
}

impl ::std::default::Default for ListPathRequest_SortType {
    fn default() -> Self {
        ListPathRequest_SortType::NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for ListPathRequest_SortType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListPathResponse {
    // message fields
    pub destination: ::protobuf::SingularPtrField<Destination>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListPathResponse {
    fn default() -> &'a ListPathResponse {
        <ListPathResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListPathResponse {
    pub fn new() -> ListPathResponse {
        ::std::default::Default::default()
    }

    // .gobgpapi.Destination destination = 1;


    pub fn get_destination(&self) -> &Destination {
        self.destination.as_ref().unwrap_or_else(|| Destination::default_instance())
    }
    pub fn clear_destination(&mut self) {
        self.destination.clear();
    }

    pub fn has_destination(&self) -> bool {
        self.destination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_destination(&mut self, v: Destination) {
        self.destination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destination(&mut self) -> &mut Destination {
        if self.destination.is_none() {
            self.destination.set_default();
        }
        self.destination.as_mut().unwrap()
    }

    // Take field
    pub fn take_destination(&mut self) -> Destination {
        self.destination.take().unwrap_or_else(|| Destination::new())
    }
}

impl ::protobuf::Message for ListPathResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.destination {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.destination)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.destination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.destination.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListPathResponse {
        ListPathResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Destination>>(
                    "destination",
                    |m: &ListPathResponse| { &m.destination },
                    |m: &mut ListPathResponse| { &mut m.destination },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListPathResponse>(
                    "ListPathResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListPathResponse {
        static mut instance: ::protobuf::lazy::Lazy<ListPathResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListPathResponse,
        };
        unsafe {
            instance.get(ListPathResponse::new)
        }
    }
}

impl ::protobuf::Clear for ListPathResponse {
    fn clear(&mut self) {
        self.destination.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListPathResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListPathResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddPathStreamRequest {
    // message fields
    pub table_type: TableType,
    pub vrf_id: ::std::string::String,
    pub paths: ::protobuf::RepeatedField<Path>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddPathStreamRequest {
    fn default() -> &'a AddPathStreamRequest {
        <AddPathStreamRequest as ::protobuf::Message>::default_instance()
    }
}

impl AddPathStreamRequest {
    pub fn new() -> AddPathStreamRequest {
        ::std::default::Default::default()
    }

    // .gobgpapi.TableType table_type = 1;


    pub fn get_table_type(&self) -> TableType {
        self.table_type
    }
    pub fn clear_table_type(&mut self) {
        self.table_type = TableType::GLOBAL;
    }

    // Param is passed by value, moved
    pub fn set_table_type(&mut self, v: TableType) {
        self.table_type = v;
    }

    // string vrf_id = 2;


    pub fn get_vrf_id(&self) -> &str {
        &self.vrf_id
    }
    pub fn clear_vrf_id(&mut self) {
        self.vrf_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_vrf_id(&mut self, v: ::std::string::String) {
        self.vrf_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vrf_id(&mut self) -> &mut ::std::string::String {
        &mut self.vrf_id
    }

    // Take field
    pub fn take_vrf_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.vrf_id, ::std::string::String::new())
    }

    // repeated .gobgpapi.Path paths = 3;


    pub fn get_paths(&self) -> &[Path] {
        &self.paths
    }
    pub fn clear_paths(&mut self) {
        self.paths.clear();
    }

    // Param is passed by value, moved
    pub fn set_paths(&mut self, v: ::protobuf::RepeatedField<Path>) {
        self.paths = v;
    }

    // Mutable pointer to the field.
    pub fn mut_paths(&mut self) -> &mut ::protobuf::RepeatedField<Path> {
        &mut self.paths
    }

    // Take field
    pub fn take_paths(&mut self) -> ::protobuf::RepeatedField<Path> {
        ::std::mem::replace(&mut self.paths, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AddPathStreamRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.paths {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.table_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.vrf_id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.paths)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.table_type != TableType::GLOBAL {
            my_size += ::protobuf::rt::enum_size(1, self.table_type);
        }
        if !self.vrf_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.vrf_id);
        }
        for value in &self.paths {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.table_type != TableType::GLOBAL {
            os.write_enum(1, self.table_type.value())?;
        }
        if !self.vrf_id.is_empty() {
            os.write_string(2, &self.vrf_id)?;
        }
        for v in &self.paths {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddPathStreamRequest {
        AddPathStreamRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TableType>>(
                    "table_type",
                    |m: &AddPathStreamRequest| { &m.table_type },
                    |m: &mut AddPathStreamRequest| { &mut m.table_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "vrf_id",
                    |m: &AddPathStreamRequest| { &m.vrf_id },
                    |m: &mut AddPathStreamRequest| { &mut m.vrf_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Path>>(
                    "paths",
                    |m: &AddPathStreamRequest| { &m.paths },
                    |m: &mut AddPathStreamRequest| { &mut m.paths },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddPathStreamRequest>(
                    "AddPathStreamRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AddPathStreamRequest {
        static mut instance: ::protobuf::lazy::Lazy<AddPathStreamRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddPathStreamRequest,
        };
        unsafe {
            instance.get(AddPathStreamRequest::new)
        }
    }
}

impl ::protobuf::Clear for AddPathStreamRequest {
    fn clear(&mut self) {
        self.table_type = TableType::GLOBAL;
        self.vrf_id.clear();
        self.paths.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddPathStreamRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddPathStreamRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetTableRequest {
    // message fields
    pub table_type: TableType,
    pub family: ::protobuf::SingularPtrField<Family>,
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetTableRequest {
    fn default() -> &'a GetTableRequest {
        <GetTableRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetTableRequest {
    pub fn new() -> GetTableRequest {
        ::std::default::Default::default()
    }

    // .gobgpapi.TableType table_type = 1;


    pub fn get_table_type(&self) -> TableType {
        self.table_type
    }
    pub fn clear_table_type(&mut self) {
        self.table_type = TableType::GLOBAL;
    }

    // Param is passed by value, moved
    pub fn set_table_type(&mut self, v: TableType) {
        self.table_type = v;
    }

    // .gobgpapi.Family family = 2;


    pub fn get_family(&self) -> &Family {
        self.family.as_ref().unwrap_or_else(|| Family::default_instance())
    }
    pub fn clear_family(&mut self) {
        self.family.clear();
    }

    pub fn has_family(&self) -> bool {
        self.family.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family(&mut self, v: Family) {
        self.family = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_family(&mut self) -> &mut Family {
        if self.family.is_none() {
            self.family.set_default();
        }
        self.family.as_mut().unwrap()
    }

    // Take field
    pub fn take_family(&mut self) -> Family {
        self.family.take().unwrap_or_else(|| Family::new())
    }

    // string name = 3;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetTableRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.family {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.table_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.family)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.table_type != TableType::GLOBAL {
            my_size += ::protobuf::rt::enum_size(1, self.table_type);
        }
        if let Some(ref v) = self.family.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.table_type != TableType::GLOBAL {
            os.write_enum(1, self.table_type.value())?;
        }
        if let Some(ref v) = self.family.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetTableRequest {
        GetTableRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TableType>>(
                    "table_type",
                    |m: &GetTableRequest| { &m.table_type },
                    |m: &mut GetTableRequest| { &mut m.table_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Family>>(
                    "family",
                    |m: &GetTableRequest| { &m.family },
                    |m: &mut GetTableRequest| { &mut m.family },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &GetTableRequest| { &m.name },
                    |m: &mut GetTableRequest| { &mut m.name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetTableRequest>(
                    "GetTableRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetTableRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetTableRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetTableRequest,
        };
        unsafe {
            instance.get(GetTableRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetTableRequest {
    fn clear(&mut self) {
        self.table_type = TableType::GLOBAL;
        self.family.clear();
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetTableRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTableRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetTableResponse {
    // message fields
    pub num_destination: u64,
    pub num_path: u64,
    pub num_accepted: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetTableResponse {
    fn default() -> &'a GetTableResponse {
        <GetTableResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetTableResponse {
    pub fn new() -> GetTableResponse {
        ::std::default::Default::default()
    }

    // uint64 num_destination = 1;


    pub fn get_num_destination(&self) -> u64 {
        self.num_destination
    }
    pub fn clear_num_destination(&mut self) {
        self.num_destination = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_destination(&mut self, v: u64) {
        self.num_destination = v;
    }

    // uint64 num_path = 2;


    pub fn get_num_path(&self) -> u64 {
        self.num_path
    }
    pub fn clear_num_path(&mut self) {
        self.num_path = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_path(&mut self, v: u64) {
        self.num_path = v;
    }

    // uint64 num_accepted = 3;


    pub fn get_num_accepted(&self) -> u64 {
        self.num_accepted
    }
    pub fn clear_num_accepted(&mut self) {
        self.num_accepted = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_accepted(&mut self, v: u64) {
        self.num_accepted = v;
    }
}

impl ::protobuf::Message for GetTableResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.num_destination = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.num_path = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.num_accepted = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.num_destination != 0 {
            my_size += ::protobuf::rt::value_size(1, self.num_destination, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.num_path != 0 {
            my_size += ::protobuf::rt::value_size(2, self.num_path, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.num_accepted != 0 {
            my_size += ::protobuf::rt::value_size(3, self.num_accepted, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.num_destination != 0 {
            os.write_uint64(1, self.num_destination)?;
        }
        if self.num_path != 0 {
            os.write_uint64(2, self.num_path)?;
        }
        if self.num_accepted != 0 {
            os.write_uint64(3, self.num_accepted)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetTableResponse {
        GetTableResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "num_destination",
                    |m: &GetTableResponse| { &m.num_destination },
                    |m: &mut GetTableResponse| { &mut m.num_destination },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "num_path",
                    |m: &GetTableResponse| { &m.num_path },
                    |m: &mut GetTableResponse| { &mut m.num_path },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "num_accepted",
                    |m: &GetTableResponse| { &m.num_accepted },
                    |m: &mut GetTableResponse| { &mut m.num_accepted },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetTableResponse>(
                    "GetTableResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetTableResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetTableResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetTableResponse,
        };
        unsafe {
            instance.get(GetTableResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetTableResponse {
    fn clear(&mut self) {
        self.num_destination = 0;
        self.num_path = 0;
        self.num_accepted = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetTableResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTableResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MonitorTableRequest {
    // message fields
    pub table_type: TableType,
    pub name: ::std::string::String,
    pub family: ::protobuf::SingularPtrField<Family>,
    pub current: bool,
    pub post_policy: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MonitorTableRequest {
    fn default() -> &'a MonitorTableRequest {
        <MonitorTableRequest as ::protobuf::Message>::default_instance()
    }
}

impl MonitorTableRequest {
    pub fn new() -> MonitorTableRequest {
        ::std::default::Default::default()
    }

    // .gobgpapi.TableType table_type = 1;


    pub fn get_table_type(&self) -> TableType {
        self.table_type
    }
    pub fn clear_table_type(&mut self) {
        self.table_type = TableType::GLOBAL;
    }

    // Param is passed by value, moved
    pub fn set_table_type(&mut self, v: TableType) {
        self.table_type = v;
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .gobgpapi.Family family = 3;


    pub fn get_family(&self) -> &Family {
        self.family.as_ref().unwrap_or_else(|| Family::default_instance())
    }
    pub fn clear_family(&mut self) {
        self.family.clear();
    }

    pub fn has_family(&self) -> bool {
        self.family.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family(&mut self, v: Family) {
        self.family = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_family(&mut self) -> &mut Family {
        if self.family.is_none() {
            self.family.set_default();
        }
        self.family.as_mut().unwrap()
    }

    // Take field
    pub fn take_family(&mut self) -> Family {
        self.family.take().unwrap_or_else(|| Family::new())
    }

    // bool current = 4;


    pub fn get_current(&self) -> bool {
        self.current
    }
    pub fn clear_current(&mut self) {
        self.current = false;
    }

    // Param is passed by value, moved
    pub fn set_current(&mut self, v: bool) {
        self.current = v;
    }

    // bool post_policy = 5;


    pub fn get_post_policy(&self) -> bool {
        self.post_policy
    }
    pub fn clear_post_policy(&mut self) {
        self.post_policy = false;
    }

    // Param is passed by value, moved
    pub fn set_post_policy(&mut self, v: bool) {
        self.post_policy = v;
    }
}

impl ::protobuf::Message for MonitorTableRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.family {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.table_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.family)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.current = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.post_policy = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.table_type != TableType::GLOBAL {
            my_size += ::protobuf::rt::enum_size(1, self.table_type);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if let Some(ref v) = self.family.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.current != false {
            my_size += 2;
        }
        if self.post_policy != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.table_type != TableType::GLOBAL {
            os.write_enum(1, self.table_type.value())?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if let Some(ref v) = self.family.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.current != false {
            os.write_bool(4, self.current)?;
        }
        if self.post_policy != false {
            os.write_bool(5, self.post_policy)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MonitorTableRequest {
        MonitorTableRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TableType>>(
                    "table_type",
                    |m: &MonitorTableRequest| { &m.table_type },
                    |m: &mut MonitorTableRequest| { &mut m.table_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &MonitorTableRequest| { &m.name },
                    |m: &mut MonitorTableRequest| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Family>>(
                    "family",
                    |m: &MonitorTableRequest| { &m.family },
                    |m: &mut MonitorTableRequest| { &mut m.family },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "current",
                    |m: &MonitorTableRequest| { &m.current },
                    |m: &mut MonitorTableRequest| { &mut m.current },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "post_policy",
                    |m: &MonitorTableRequest| { &m.post_policy },
                    |m: &mut MonitorTableRequest| { &mut m.post_policy },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MonitorTableRequest>(
                    "MonitorTableRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MonitorTableRequest {
        static mut instance: ::protobuf::lazy::Lazy<MonitorTableRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MonitorTableRequest,
        };
        unsafe {
            instance.get(MonitorTableRequest::new)
        }
    }
}

impl ::protobuf::Clear for MonitorTableRequest {
    fn clear(&mut self) {
        self.table_type = TableType::GLOBAL;
        self.name.clear();
        self.family.clear();
        self.current = false;
        self.post_policy = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MonitorTableRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MonitorTableRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MonitorTableResponse {
    // message fields
    pub path: ::protobuf::SingularPtrField<Path>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MonitorTableResponse {
    fn default() -> &'a MonitorTableResponse {
        <MonitorTableResponse as ::protobuf::Message>::default_instance()
    }
}

impl MonitorTableResponse {
    pub fn new() -> MonitorTableResponse {
        ::std::default::Default::default()
    }

    // .gobgpapi.Path path = 1;


    pub fn get_path(&self) -> &Path {
        self.path.as_ref().unwrap_or_else(|| Path::default_instance())
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: Path) {
        self.path = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut Path {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> Path {
        self.path.take().unwrap_or_else(|| Path::new())
    }
}

impl ::protobuf::Message for MonitorTableResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.path {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.path.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.path.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MonitorTableResponse {
        MonitorTableResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Path>>(
                    "path",
                    |m: &MonitorTableResponse| { &m.path },
                    |m: &mut MonitorTableResponse| { &mut m.path },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MonitorTableResponse>(
                    "MonitorTableResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MonitorTableResponse {
        static mut instance: ::protobuf::lazy::Lazy<MonitorTableResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MonitorTableResponse,
        };
        unsafe {
            instance.get(MonitorTableResponse::new)
        }
    }
}

impl ::protobuf::Clear for MonitorTableResponse {
    fn clear(&mut self) {
        self.path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MonitorTableResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MonitorTableResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddVrfRequest {
    // message fields
    pub vrf: ::protobuf::SingularPtrField<Vrf>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddVrfRequest {
    fn default() -> &'a AddVrfRequest {
        <AddVrfRequest as ::protobuf::Message>::default_instance()
    }
}

impl AddVrfRequest {
    pub fn new() -> AddVrfRequest {
        ::std::default::Default::default()
    }

    // .gobgpapi.Vrf vrf = 1;


    pub fn get_vrf(&self) -> &Vrf {
        self.vrf.as_ref().unwrap_or_else(|| Vrf::default_instance())
    }
    pub fn clear_vrf(&mut self) {
        self.vrf.clear();
    }

    pub fn has_vrf(&self) -> bool {
        self.vrf.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vrf(&mut self, v: Vrf) {
        self.vrf = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vrf(&mut self) -> &mut Vrf {
        if self.vrf.is_none() {
            self.vrf.set_default();
        }
        self.vrf.as_mut().unwrap()
    }

    // Take field
    pub fn take_vrf(&mut self) -> Vrf {
        self.vrf.take().unwrap_or_else(|| Vrf::new())
    }
}

impl ::protobuf::Message for AddVrfRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.vrf {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.vrf)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.vrf.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.vrf.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddVrfRequest {
        AddVrfRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Vrf>>(
                    "vrf",
                    |m: &AddVrfRequest| { &m.vrf },
                    |m: &mut AddVrfRequest| { &mut m.vrf },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddVrfRequest>(
                    "AddVrfRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AddVrfRequest {
        static mut instance: ::protobuf::lazy::Lazy<AddVrfRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddVrfRequest,
        };
        unsafe {
            instance.get(AddVrfRequest::new)
        }
    }
}

impl ::protobuf::Clear for AddVrfRequest {
    fn clear(&mut self) {
        self.vrf.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddVrfRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddVrfRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteVrfRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteVrfRequest {
    fn default() -> &'a DeleteVrfRequest {
        <DeleteVrfRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteVrfRequest {
    pub fn new() -> DeleteVrfRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteVrfRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteVrfRequest {
        DeleteVrfRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &DeleteVrfRequest| { &m.name },
                    |m: &mut DeleteVrfRequest| { &mut m.name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeleteVrfRequest>(
                    "DeleteVrfRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeleteVrfRequest {
        static mut instance: ::protobuf::lazy::Lazy<DeleteVrfRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteVrfRequest,
        };
        unsafe {
            instance.get(DeleteVrfRequest::new)
        }
    }
}

impl ::protobuf::Clear for DeleteVrfRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteVrfRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteVrfRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListVrfRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListVrfRequest {
    fn default() -> &'a ListVrfRequest {
        <ListVrfRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListVrfRequest {
    pub fn new() -> ListVrfRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListVrfRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListVrfRequest {
        ListVrfRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &ListVrfRequest| { &m.name },
                    |m: &mut ListVrfRequest| { &mut m.name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListVrfRequest>(
                    "ListVrfRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListVrfRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListVrfRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListVrfRequest,
        };
        unsafe {
            instance.get(ListVrfRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListVrfRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListVrfRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListVrfRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListVrfResponse {
    // message fields
    pub vrf: ::protobuf::SingularPtrField<Vrf>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListVrfResponse {
    fn default() -> &'a ListVrfResponse {
        <ListVrfResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListVrfResponse {
    pub fn new() -> ListVrfResponse {
        ::std::default::Default::default()
    }

    // .gobgpapi.Vrf vrf = 1;


    pub fn get_vrf(&self) -> &Vrf {
        self.vrf.as_ref().unwrap_or_else(|| Vrf::default_instance())
    }
    pub fn clear_vrf(&mut self) {
        self.vrf.clear();
    }

    pub fn has_vrf(&self) -> bool {
        self.vrf.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vrf(&mut self, v: Vrf) {
        self.vrf = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vrf(&mut self) -> &mut Vrf {
        if self.vrf.is_none() {
            self.vrf.set_default();
        }
        self.vrf.as_mut().unwrap()
    }

    // Take field
    pub fn take_vrf(&mut self) -> Vrf {
        self.vrf.take().unwrap_or_else(|| Vrf::new())
    }
}

impl ::protobuf::Message for ListVrfResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.vrf {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.vrf)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.vrf.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.vrf.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListVrfResponse {
        ListVrfResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Vrf>>(
                    "vrf",
                    |m: &ListVrfResponse| { &m.vrf },
                    |m: &mut ListVrfResponse| { &mut m.vrf },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListVrfResponse>(
                    "ListVrfResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListVrfResponse {
        static mut instance: ::protobuf::lazy::Lazy<ListVrfResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListVrfResponse,
        };
        unsafe {
            instance.get(ListVrfResponse::new)
        }
    }
}

impl ::protobuf::Clear for ListVrfResponse {
    fn clear(&mut self) {
        self.vrf.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListVrfResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListVrfResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddPolicyRequest {
    // message fields
    pub policy: ::protobuf::SingularPtrField<Policy>,
    pub refer_existing_statements: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddPolicyRequest {
    fn default() -> &'a AddPolicyRequest {
        <AddPolicyRequest as ::protobuf::Message>::default_instance()
    }
}

impl AddPolicyRequest {
    pub fn new() -> AddPolicyRequest {
        ::std::default::Default::default()
    }

    // .gobgpapi.Policy policy = 1;


    pub fn get_policy(&self) -> &Policy {
        self.policy.as_ref().unwrap_or_else(|| Policy::default_instance())
    }
    pub fn clear_policy(&mut self) {
        self.policy.clear();
    }

    pub fn has_policy(&self) -> bool {
        self.policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_policy(&mut self, v: Policy) {
        self.policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_policy(&mut self) -> &mut Policy {
        if self.policy.is_none() {
            self.policy.set_default();
        }
        self.policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_policy(&mut self) -> Policy {
        self.policy.take().unwrap_or_else(|| Policy::new())
    }

    // bool refer_existing_statements = 2;


    pub fn get_refer_existing_statements(&self) -> bool {
        self.refer_existing_statements
    }
    pub fn clear_refer_existing_statements(&mut self) {
        self.refer_existing_statements = false;
    }

    // Param is passed by value, moved
    pub fn set_refer_existing_statements(&mut self, v: bool) {
        self.refer_existing_statements = v;
    }
}

impl ::protobuf::Message for AddPolicyRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.policy {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.policy)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.refer_existing_statements = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.policy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.refer_existing_statements != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.policy.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.refer_existing_statements != false {
            os.write_bool(2, self.refer_existing_statements)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddPolicyRequest {
        AddPolicyRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Policy>>(
                    "policy",
                    |m: &AddPolicyRequest| { &m.policy },
                    |m: &mut AddPolicyRequest| { &mut m.policy },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "refer_existing_statements",
                    |m: &AddPolicyRequest| { &m.refer_existing_statements },
                    |m: &mut AddPolicyRequest| { &mut m.refer_existing_statements },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddPolicyRequest>(
                    "AddPolicyRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AddPolicyRequest {
        static mut instance: ::protobuf::lazy::Lazy<AddPolicyRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddPolicyRequest,
        };
        unsafe {
            instance.get(AddPolicyRequest::new)
        }
    }
}

impl ::protobuf::Clear for AddPolicyRequest {
    fn clear(&mut self) {
        self.policy.clear();
        self.refer_existing_statements = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddPolicyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddPolicyRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeletePolicyRequest {
    // message fields
    pub policy: ::protobuf::SingularPtrField<Policy>,
    pub preserve_statements: bool,
    pub all: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeletePolicyRequest {
    fn default() -> &'a DeletePolicyRequest {
        <DeletePolicyRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeletePolicyRequest {
    pub fn new() -> DeletePolicyRequest {
        ::std::default::Default::default()
    }

    // .gobgpapi.Policy policy = 1;


    pub fn get_policy(&self) -> &Policy {
        self.policy.as_ref().unwrap_or_else(|| Policy::default_instance())
    }
    pub fn clear_policy(&mut self) {
        self.policy.clear();
    }

    pub fn has_policy(&self) -> bool {
        self.policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_policy(&mut self, v: Policy) {
        self.policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_policy(&mut self) -> &mut Policy {
        if self.policy.is_none() {
            self.policy.set_default();
        }
        self.policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_policy(&mut self) -> Policy {
        self.policy.take().unwrap_or_else(|| Policy::new())
    }

    // bool preserve_statements = 2;


    pub fn get_preserve_statements(&self) -> bool {
        self.preserve_statements
    }
    pub fn clear_preserve_statements(&mut self) {
        self.preserve_statements = false;
    }

    // Param is passed by value, moved
    pub fn set_preserve_statements(&mut self, v: bool) {
        self.preserve_statements = v;
    }

    // bool all = 3;


    pub fn get_all(&self) -> bool {
        self.all
    }
    pub fn clear_all(&mut self) {
        self.all = false;
    }

    // Param is passed by value, moved
    pub fn set_all(&mut self, v: bool) {
        self.all = v;
    }
}

impl ::protobuf::Message for DeletePolicyRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.policy {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.policy)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.preserve_statements = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.all = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.policy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.preserve_statements != false {
            my_size += 2;
        }
        if self.all != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.policy.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.preserve_statements != false {
            os.write_bool(2, self.preserve_statements)?;
        }
        if self.all != false {
            os.write_bool(3, self.all)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeletePolicyRequest {
        DeletePolicyRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Policy>>(
                    "policy",
                    |m: &DeletePolicyRequest| { &m.policy },
                    |m: &mut DeletePolicyRequest| { &mut m.policy },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "preserve_statements",
                    |m: &DeletePolicyRequest| { &m.preserve_statements },
                    |m: &mut DeletePolicyRequest| { &mut m.preserve_statements },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "all",
                    |m: &DeletePolicyRequest| { &m.all },
                    |m: &mut DeletePolicyRequest| { &mut m.all },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeletePolicyRequest>(
                    "DeletePolicyRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeletePolicyRequest {
        static mut instance: ::protobuf::lazy::Lazy<DeletePolicyRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeletePolicyRequest,
        };
        unsafe {
            instance.get(DeletePolicyRequest::new)
        }
    }
}

impl ::protobuf::Clear for DeletePolicyRequest {
    fn clear(&mut self) {
        self.policy.clear();
        self.preserve_statements = false;
        self.all = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeletePolicyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeletePolicyRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListPolicyRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListPolicyRequest {
    fn default() -> &'a ListPolicyRequest {
        <ListPolicyRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListPolicyRequest {
    pub fn new() -> ListPolicyRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListPolicyRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListPolicyRequest {
        ListPolicyRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &ListPolicyRequest| { &m.name },
                    |m: &mut ListPolicyRequest| { &mut m.name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListPolicyRequest>(
                    "ListPolicyRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListPolicyRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListPolicyRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListPolicyRequest,
        };
        unsafe {
            instance.get(ListPolicyRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListPolicyRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListPolicyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListPolicyRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListPolicyResponse {
    // message fields
    pub policy: ::protobuf::SingularPtrField<Policy>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListPolicyResponse {
    fn default() -> &'a ListPolicyResponse {
        <ListPolicyResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListPolicyResponse {
    pub fn new() -> ListPolicyResponse {
        ::std::default::Default::default()
    }

    // .gobgpapi.Policy policy = 1;


    pub fn get_policy(&self) -> &Policy {
        self.policy.as_ref().unwrap_or_else(|| Policy::default_instance())
    }
    pub fn clear_policy(&mut self) {
        self.policy.clear();
    }

    pub fn has_policy(&self) -> bool {
        self.policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_policy(&mut self, v: Policy) {
        self.policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_policy(&mut self) -> &mut Policy {
        if self.policy.is_none() {
            self.policy.set_default();
        }
        self.policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_policy(&mut self) -> Policy {
        self.policy.take().unwrap_or_else(|| Policy::new())
    }
}

impl ::protobuf::Message for ListPolicyResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.policy {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.policy)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.policy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.policy.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListPolicyResponse {
        ListPolicyResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Policy>>(
                    "policy",
                    |m: &ListPolicyResponse| { &m.policy },
                    |m: &mut ListPolicyResponse| { &mut m.policy },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListPolicyResponse>(
                    "ListPolicyResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListPolicyResponse {
        static mut instance: ::protobuf::lazy::Lazy<ListPolicyResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListPolicyResponse,
        };
        unsafe {
            instance.get(ListPolicyResponse::new)
        }
    }
}

impl ::protobuf::Clear for ListPolicyResponse {
    fn clear(&mut self) {
        self.policy.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListPolicyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListPolicyResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetPoliciesRequest {
    // message fields
    pub defined_sets: ::protobuf::RepeatedField<DefinedSet>,
    pub policies: ::protobuf::RepeatedField<Policy>,
    pub assignments: ::protobuf::RepeatedField<PolicyAssignment>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetPoliciesRequest {
    fn default() -> &'a SetPoliciesRequest {
        <SetPoliciesRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetPoliciesRequest {
    pub fn new() -> SetPoliciesRequest {
        ::std::default::Default::default()
    }

    // repeated .gobgpapi.DefinedSet defined_sets = 1;


    pub fn get_defined_sets(&self) -> &[DefinedSet] {
        &self.defined_sets
    }
    pub fn clear_defined_sets(&mut self) {
        self.defined_sets.clear();
    }

    // Param is passed by value, moved
    pub fn set_defined_sets(&mut self, v: ::protobuf::RepeatedField<DefinedSet>) {
        self.defined_sets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_defined_sets(&mut self) -> &mut ::protobuf::RepeatedField<DefinedSet> {
        &mut self.defined_sets
    }

    // Take field
    pub fn take_defined_sets(&mut self) -> ::protobuf::RepeatedField<DefinedSet> {
        ::std::mem::replace(&mut self.defined_sets, ::protobuf::RepeatedField::new())
    }

    // repeated .gobgpapi.Policy policies = 2;


    pub fn get_policies(&self) -> &[Policy] {
        &self.policies
    }
    pub fn clear_policies(&mut self) {
        self.policies.clear();
    }

    // Param is passed by value, moved
    pub fn set_policies(&mut self, v: ::protobuf::RepeatedField<Policy>) {
        self.policies = v;
    }

    // Mutable pointer to the field.
    pub fn mut_policies(&mut self) -> &mut ::protobuf::RepeatedField<Policy> {
        &mut self.policies
    }

    // Take field
    pub fn take_policies(&mut self) -> ::protobuf::RepeatedField<Policy> {
        ::std::mem::replace(&mut self.policies, ::protobuf::RepeatedField::new())
    }

    // repeated .gobgpapi.PolicyAssignment assignments = 3;


    pub fn get_assignments(&self) -> &[PolicyAssignment] {
        &self.assignments
    }
    pub fn clear_assignments(&mut self) {
        self.assignments.clear();
    }

    // Param is passed by value, moved
    pub fn set_assignments(&mut self, v: ::protobuf::RepeatedField<PolicyAssignment>) {
        self.assignments = v;
    }

    // Mutable pointer to the field.
    pub fn mut_assignments(&mut self) -> &mut ::protobuf::RepeatedField<PolicyAssignment> {
        &mut self.assignments
    }

    // Take field
    pub fn take_assignments(&mut self) -> ::protobuf::RepeatedField<PolicyAssignment> {
        ::std::mem::replace(&mut self.assignments, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SetPoliciesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.defined_sets {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.policies {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.assignments {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.defined_sets)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.policies)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.assignments)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.defined_sets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.policies {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.assignments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.defined_sets {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.policies {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.assignments {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetPoliciesRequest {
        SetPoliciesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DefinedSet>>(
                    "defined_sets",
                    |m: &SetPoliciesRequest| { &m.defined_sets },
                    |m: &mut SetPoliciesRequest| { &mut m.defined_sets },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Policy>>(
                    "policies",
                    |m: &SetPoliciesRequest| { &m.policies },
                    |m: &mut SetPoliciesRequest| { &mut m.policies },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PolicyAssignment>>(
                    "assignments",
                    |m: &SetPoliciesRequest| { &m.assignments },
                    |m: &mut SetPoliciesRequest| { &mut m.assignments },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetPoliciesRequest>(
                    "SetPoliciesRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SetPoliciesRequest {
        static mut instance: ::protobuf::lazy::Lazy<SetPoliciesRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetPoliciesRequest,
        };
        unsafe {
            instance.get(SetPoliciesRequest::new)
        }
    }
}

impl ::protobuf::Clear for SetPoliciesRequest {
    fn clear(&mut self) {
        self.defined_sets.clear();
        self.policies.clear();
        self.assignments.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetPoliciesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetPoliciesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddDefinedSetRequest {
    // message fields
    pub defined_set: ::protobuf::SingularPtrField<DefinedSet>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddDefinedSetRequest {
    fn default() -> &'a AddDefinedSetRequest {
        <AddDefinedSetRequest as ::protobuf::Message>::default_instance()
    }
}

impl AddDefinedSetRequest {
    pub fn new() -> AddDefinedSetRequest {
        ::std::default::Default::default()
    }

    // .gobgpapi.DefinedSet defined_set = 1;


    pub fn get_defined_set(&self) -> &DefinedSet {
        self.defined_set.as_ref().unwrap_or_else(|| DefinedSet::default_instance())
    }
    pub fn clear_defined_set(&mut self) {
        self.defined_set.clear();
    }

    pub fn has_defined_set(&self) -> bool {
        self.defined_set.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defined_set(&mut self, v: DefinedSet) {
        self.defined_set = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_defined_set(&mut self) -> &mut DefinedSet {
        if self.defined_set.is_none() {
            self.defined_set.set_default();
        }
        self.defined_set.as_mut().unwrap()
    }

    // Take field
    pub fn take_defined_set(&mut self) -> DefinedSet {
        self.defined_set.take().unwrap_or_else(|| DefinedSet::new())
    }
}

impl ::protobuf::Message for AddDefinedSetRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.defined_set {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.defined_set)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.defined_set.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.defined_set.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddDefinedSetRequest {
        AddDefinedSetRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DefinedSet>>(
                    "defined_set",
                    |m: &AddDefinedSetRequest| { &m.defined_set },
                    |m: &mut AddDefinedSetRequest| { &mut m.defined_set },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddDefinedSetRequest>(
                    "AddDefinedSetRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AddDefinedSetRequest {
        static mut instance: ::protobuf::lazy::Lazy<AddDefinedSetRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddDefinedSetRequest,
        };
        unsafe {
            instance.get(AddDefinedSetRequest::new)
        }
    }
}

impl ::protobuf::Clear for AddDefinedSetRequest {
    fn clear(&mut self) {
        self.defined_set.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddDefinedSetRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddDefinedSetRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteDefinedSetRequest {
    // message fields
    pub defined_set: ::protobuf::SingularPtrField<DefinedSet>,
    pub all: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteDefinedSetRequest {
    fn default() -> &'a DeleteDefinedSetRequest {
        <DeleteDefinedSetRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteDefinedSetRequest {
    pub fn new() -> DeleteDefinedSetRequest {
        ::std::default::Default::default()
    }

    // .gobgpapi.DefinedSet defined_set = 1;


    pub fn get_defined_set(&self) -> &DefinedSet {
        self.defined_set.as_ref().unwrap_or_else(|| DefinedSet::default_instance())
    }
    pub fn clear_defined_set(&mut self) {
        self.defined_set.clear();
    }

    pub fn has_defined_set(&self) -> bool {
        self.defined_set.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defined_set(&mut self, v: DefinedSet) {
        self.defined_set = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_defined_set(&mut self) -> &mut DefinedSet {
        if self.defined_set.is_none() {
            self.defined_set.set_default();
        }
        self.defined_set.as_mut().unwrap()
    }

    // Take field
    pub fn take_defined_set(&mut self) -> DefinedSet {
        self.defined_set.take().unwrap_or_else(|| DefinedSet::new())
    }

    // bool all = 2;


    pub fn get_all(&self) -> bool {
        self.all
    }
    pub fn clear_all(&mut self) {
        self.all = false;
    }

    // Param is passed by value, moved
    pub fn set_all(&mut self, v: bool) {
        self.all = v;
    }
}

impl ::protobuf::Message for DeleteDefinedSetRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.defined_set {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.defined_set)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.all = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.defined_set.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.all != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.defined_set.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.all != false {
            os.write_bool(2, self.all)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteDefinedSetRequest {
        DeleteDefinedSetRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DefinedSet>>(
                    "defined_set",
                    |m: &DeleteDefinedSetRequest| { &m.defined_set },
                    |m: &mut DeleteDefinedSetRequest| { &mut m.defined_set },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "all",
                    |m: &DeleteDefinedSetRequest| { &m.all },
                    |m: &mut DeleteDefinedSetRequest| { &mut m.all },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeleteDefinedSetRequest>(
                    "DeleteDefinedSetRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeleteDefinedSetRequest {
        static mut instance: ::protobuf::lazy::Lazy<DeleteDefinedSetRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteDefinedSetRequest,
        };
        unsafe {
            instance.get(DeleteDefinedSetRequest::new)
        }
    }
}

impl ::protobuf::Clear for DeleteDefinedSetRequest {
    fn clear(&mut self) {
        self.defined_set.clear();
        self.all = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteDefinedSetRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteDefinedSetRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListDefinedSetRequest {
    // message fields
    pub defined_type: DefinedType,
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListDefinedSetRequest {
    fn default() -> &'a ListDefinedSetRequest {
        <ListDefinedSetRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListDefinedSetRequest {
    pub fn new() -> ListDefinedSetRequest {
        ::std::default::Default::default()
    }

    // .gobgpapi.DefinedType defined_type = 1;


    pub fn get_defined_type(&self) -> DefinedType {
        self.defined_type
    }
    pub fn clear_defined_type(&mut self) {
        self.defined_type = DefinedType::PREFIX;
    }

    // Param is passed by value, moved
    pub fn set_defined_type(&mut self, v: DefinedType) {
        self.defined_type = v;
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListDefinedSetRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.defined_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.defined_type != DefinedType::PREFIX {
            my_size += ::protobuf::rt::enum_size(1, self.defined_type);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.defined_type != DefinedType::PREFIX {
            os.write_enum(1, self.defined_type.value())?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListDefinedSetRequest {
        ListDefinedSetRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DefinedType>>(
                    "defined_type",
                    |m: &ListDefinedSetRequest| { &m.defined_type },
                    |m: &mut ListDefinedSetRequest| { &mut m.defined_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &ListDefinedSetRequest| { &m.name },
                    |m: &mut ListDefinedSetRequest| { &mut m.name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListDefinedSetRequest>(
                    "ListDefinedSetRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListDefinedSetRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListDefinedSetRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListDefinedSetRequest,
        };
        unsafe {
            instance.get(ListDefinedSetRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListDefinedSetRequest {
    fn clear(&mut self) {
        self.defined_type = DefinedType::PREFIX;
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListDefinedSetRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListDefinedSetRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListDefinedSetResponse {
    // message fields
    pub defined_set: ::protobuf::SingularPtrField<DefinedSet>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListDefinedSetResponse {
    fn default() -> &'a ListDefinedSetResponse {
        <ListDefinedSetResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListDefinedSetResponse {
    pub fn new() -> ListDefinedSetResponse {
        ::std::default::Default::default()
    }

    // .gobgpapi.DefinedSet defined_set = 1;


    pub fn get_defined_set(&self) -> &DefinedSet {
        self.defined_set.as_ref().unwrap_or_else(|| DefinedSet::default_instance())
    }
    pub fn clear_defined_set(&mut self) {
        self.defined_set.clear();
    }

    pub fn has_defined_set(&self) -> bool {
        self.defined_set.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defined_set(&mut self, v: DefinedSet) {
        self.defined_set = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_defined_set(&mut self) -> &mut DefinedSet {
        if self.defined_set.is_none() {
            self.defined_set.set_default();
        }
        self.defined_set.as_mut().unwrap()
    }

    // Take field
    pub fn take_defined_set(&mut self) -> DefinedSet {
        self.defined_set.take().unwrap_or_else(|| DefinedSet::new())
    }
}

impl ::protobuf::Message for ListDefinedSetResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.defined_set {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.defined_set)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.defined_set.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.defined_set.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListDefinedSetResponse {
        ListDefinedSetResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DefinedSet>>(
                    "defined_set",
                    |m: &ListDefinedSetResponse| { &m.defined_set },
                    |m: &mut ListDefinedSetResponse| { &mut m.defined_set },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListDefinedSetResponse>(
                    "ListDefinedSetResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListDefinedSetResponse {
        static mut instance: ::protobuf::lazy::Lazy<ListDefinedSetResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListDefinedSetResponse,
        };
        unsafe {
            instance.get(ListDefinedSetResponse::new)
        }
    }
}

impl ::protobuf::Clear for ListDefinedSetResponse {
    fn clear(&mut self) {
        self.defined_set.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListDefinedSetResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListDefinedSetResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddStatementRequest {
    // message fields
    pub statement: ::protobuf::SingularPtrField<Statement>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddStatementRequest {
    fn default() -> &'a AddStatementRequest {
        <AddStatementRequest as ::protobuf::Message>::default_instance()
    }
}

impl AddStatementRequest {
    pub fn new() -> AddStatementRequest {
        ::std::default::Default::default()
    }

    // .gobgpapi.Statement statement = 1;


    pub fn get_statement(&self) -> &Statement {
        self.statement.as_ref().unwrap_or_else(|| Statement::default_instance())
    }
    pub fn clear_statement(&mut self) {
        self.statement.clear();
    }

    pub fn has_statement(&self) -> bool {
        self.statement.is_some()
    }

    // Param is passed by value, moved
    pub fn set_statement(&mut self, v: Statement) {
        self.statement = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_statement(&mut self) -> &mut Statement {
        if self.statement.is_none() {
            self.statement.set_default();
        }
        self.statement.as_mut().unwrap()
    }

    // Take field
    pub fn take_statement(&mut self) -> Statement {
        self.statement.take().unwrap_or_else(|| Statement::new())
    }
}

impl ::protobuf::Message for AddStatementRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.statement {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.statement)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.statement.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.statement.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddStatementRequest {
        AddStatementRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Statement>>(
                    "statement",
                    |m: &AddStatementRequest| { &m.statement },
                    |m: &mut AddStatementRequest| { &mut m.statement },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddStatementRequest>(
                    "AddStatementRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AddStatementRequest {
        static mut instance: ::protobuf::lazy::Lazy<AddStatementRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddStatementRequest,
        };
        unsafe {
            instance.get(AddStatementRequest::new)
        }
    }
}

impl ::protobuf::Clear for AddStatementRequest {
    fn clear(&mut self) {
        self.statement.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddStatementRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddStatementRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteStatementRequest {
    // message fields
    pub statement: ::protobuf::SingularPtrField<Statement>,
    pub all: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteStatementRequest {
    fn default() -> &'a DeleteStatementRequest {
        <DeleteStatementRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteStatementRequest {
    pub fn new() -> DeleteStatementRequest {
        ::std::default::Default::default()
    }

    // .gobgpapi.Statement statement = 1;


    pub fn get_statement(&self) -> &Statement {
        self.statement.as_ref().unwrap_or_else(|| Statement::default_instance())
    }
    pub fn clear_statement(&mut self) {
        self.statement.clear();
    }

    pub fn has_statement(&self) -> bool {
        self.statement.is_some()
    }

    // Param is passed by value, moved
    pub fn set_statement(&mut self, v: Statement) {
        self.statement = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_statement(&mut self) -> &mut Statement {
        if self.statement.is_none() {
            self.statement.set_default();
        }
        self.statement.as_mut().unwrap()
    }

    // Take field
    pub fn take_statement(&mut self) -> Statement {
        self.statement.take().unwrap_or_else(|| Statement::new())
    }

    // bool all = 2;


    pub fn get_all(&self) -> bool {
        self.all
    }
    pub fn clear_all(&mut self) {
        self.all = false;
    }

    // Param is passed by value, moved
    pub fn set_all(&mut self, v: bool) {
        self.all = v;
    }
}

impl ::protobuf::Message for DeleteStatementRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.statement {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.statement)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.all = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.statement.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.all != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.statement.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.all != false {
            os.write_bool(2, self.all)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteStatementRequest {
        DeleteStatementRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Statement>>(
                    "statement",
                    |m: &DeleteStatementRequest| { &m.statement },
                    |m: &mut DeleteStatementRequest| { &mut m.statement },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "all",
                    |m: &DeleteStatementRequest| { &m.all },
                    |m: &mut DeleteStatementRequest| { &mut m.all },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeleteStatementRequest>(
                    "DeleteStatementRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeleteStatementRequest {
        static mut instance: ::protobuf::lazy::Lazy<DeleteStatementRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteStatementRequest,
        };
        unsafe {
            instance.get(DeleteStatementRequest::new)
        }
    }
}

impl ::protobuf::Clear for DeleteStatementRequest {
    fn clear(&mut self) {
        self.statement.clear();
        self.all = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteStatementRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteStatementRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListStatementRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListStatementRequest {
    fn default() -> &'a ListStatementRequest {
        <ListStatementRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListStatementRequest {
    pub fn new() -> ListStatementRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListStatementRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListStatementRequest {
        ListStatementRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &ListStatementRequest| { &m.name },
                    |m: &mut ListStatementRequest| { &mut m.name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListStatementRequest>(
                    "ListStatementRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListStatementRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListStatementRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListStatementRequest,
        };
        unsafe {
            instance.get(ListStatementRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListStatementRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListStatementRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListStatementRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListStatementResponse {
    // message fields
    pub statement: ::protobuf::SingularPtrField<Statement>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListStatementResponse {
    fn default() -> &'a ListStatementResponse {
        <ListStatementResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListStatementResponse {
    pub fn new() -> ListStatementResponse {
        ::std::default::Default::default()
    }

    // .gobgpapi.Statement statement = 1;


    pub fn get_statement(&self) -> &Statement {
        self.statement.as_ref().unwrap_or_else(|| Statement::default_instance())
    }
    pub fn clear_statement(&mut self) {
        self.statement.clear();
    }

    pub fn has_statement(&self) -> bool {
        self.statement.is_some()
    }

    // Param is passed by value, moved
    pub fn set_statement(&mut self, v: Statement) {
        self.statement = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_statement(&mut self) -> &mut Statement {
        if self.statement.is_none() {
            self.statement.set_default();
        }
        self.statement.as_mut().unwrap()
    }

    // Take field
    pub fn take_statement(&mut self) -> Statement {
        self.statement.take().unwrap_or_else(|| Statement::new())
    }
}

impl ::protobuf::Message for ListStatementResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.statement {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.statement)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.statement.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.statement.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListStatementResponse {
        ListStatementResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Statement>>(
                    "statement",
                    |m: &ListStatementResponse| { &m.statement },
                    |m: &mut ListStatementResponse| { &mut m.statement },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListStatementResponse>(
                    "ListStatementResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListStatementResponse {
        static mut instance: ::protobuf::lazy::Lazy<ListStatementResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListStatementResponse,
        };
        unsafe {
            instance.get(ListStatementResponse::new)
        }
    }
}

impl ::protobuf::Clear for ListStatementResponse {
    fn clear(&mut self) {
        self.statement.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListStatementResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListStatementResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddPolicyAssignmentRequest {
    // message fields
    pub assignment: ::protobuf::SingularPtrField<PolicyAssignment>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddPolicyAssignmentRequest {
    fn default() -> &'a AddPolicyAssignmentRequest {
        <AddPolicyAssignmentRequest as ::protobuf::Message>::default_instance()
    }
}

impl AddPolicyAssignmentRequest {
    pub fn new() -> AddPolicyAssignmentRequest {
        ::std::default::Default::default()
    }

    // .gobgpapi.PolicyAssignment assignment = 1;


    pub fn get_assignment(&self) -> &PolicyAssignment {
        self.assignment.as_ref().unwrap_or_else(|| PolicyAssignment::default_instance())
    }
    pub fn clear_assignment(&mut self) {
        self.assignment.clear();
    }

    pub fn has_assignment(&self) -> bool {
        self.assignment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assignment(&mut self, v: PolicyAssignment) {
        self.assignment = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_assignment(&mut self) -> &mut PolicyAssignment {
        if self.assignment.is_none() {
            self.assignment.set_default();
        }
        self.assignment.as_mut().unwrap()
    }

    // Take field
    pub fn take_assignment(&mut self) -> PolicyAssignment {
        self.assignment.take().unwrap_or_else(|| PolicyAssignment::new())
    }
}

impl ::protobuf::Message for AddPolicyAssignmentRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.assignment {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.assignment)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.assignment.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.assignment.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddPolicyAssignmentRequest {
        AddPolicyAssignmentRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PolicyAssignment>>(
                    "assignment",
                    |m: &AddPolicyAssignmentRequest| { &m.assignment },
                    |m: &mut AddPolicyAssignmentRequest| { &mut m.assignment },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddPolicyAssignmentRequest>(
                    "AddPolicyAssignmentRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AddPolicyAssignmentRequest {
        static mut instance: ::protobuf::lazy::Lazy<AddPolicyAssignmentRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddPolicyAssignmentRequest,
        };
        unsafe {
            instance.get(AddPolicyAssignmentRequest::new)
        }
    }
}

impl ::protobuf::Clear for AddPolicyAssignmentRequest {
    fn clear(&mut self) {
        self.assignment.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddPolicyAssignmentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddPolicyAssignmentRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeletePolicyAssignmentRequest {
    // message fields
    pub assignment: ::protobuf::SingularPtrField<PolicyAssignment>,
    pub all: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeletePolicyAssignmentRequest {
    fn default() -> &'a DeletePolicyAssignmentRequest {
        <DeletePolicyAssignmentRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeletePolicyAssignmentRequest {
    pub fn new() -> DeletePolicyAssignmentRequest {
        ::std::default::Default::default()
    }

    // .gobgpapi.PolicyAssignment assignment = 1;


    pub fn get_assignment(&self) -> &PolicyAssignment {
        self.assignment.as_ref().unwrap_or_else(|| PolicyAssignment::default_instance())
    }
    pub fn clear_assignment(&mut self) {
        self.assignment.clear();
    }

    pub fn has_assignment(&self) -> bool {
        self.assignment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assignment(&mut self, v: PolicyAssignment) {
        self.assignment = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_assignment(&mut self) -> &mut PolicyAssignment {
        if self.assignment.is_none() {
            self.assignment.set_default();
        }
        self.assignment.as_mut().unwrap()
    }

    // Take field
    pub fn take_assignment(&mut self) -> PolicyAssignment {
        self.assignment.take().unwrap_or_else(|| PolicyAssignment::new())
    }

    // bool all = 2;


    pub fn get_all(&self) -> bool {
        self.all
    }
    pub fn clear_all(&mut self) {
        self.all = false;
    }

    // Param is passed by value, moved
    pub fn set_all(&mut self, v: bool) {
        self.all = v;
    }
}

impl ::protobuf::Message for DeletePolicyAssignmentRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.assignment {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.assignment)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.all = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.assignment.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.all != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.assignment.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.all != false {
            os.write_bool(2, self.all)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeletePolicyAssignmentRequest {
        DeletePolicyAssignmentRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PolicyAssignment>>(
                    "assignment",
                    |m: &DeletePolicyAssignmentRequest| { &m.assignment },
                    |m: &mut DeletePolicyAssignmentRequest| { &mut m.assignment },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "all",
                    |m: &DeletePolicyAssignmentRequest| { &m.all },
                    |m: &mut DeletePolicyAssignmentRequest| { &mut m.all },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeletePolicyAssignmentRequest>(
                    "DeletePolicyAssignmentRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeletePolicyAssignmentRequest {
        static mut instance: ::protobuf::lazy::Lazy<DeletePolicyAssignmentRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeletePolicyAssignmentRequest,
        };
        unsafe {
            instance.get(DeletePolicyAssignmentRequest::new)
        }
    }
}

impl ::protobuf::Clear for DeletePolicyAssignmentRequest {
    fn clear(&mut self) {
        self.assignment.clear();
        self.all = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeletePolicyAssignmentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeletePolicyAssignmentRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListPolicyAssignmentRequest {
    // message fields
    pub name: ::std::string::String,
    pub direction: PolicyDirection,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListPolicyAssignmentRequest {
    fn default() -> &'a ListPolicyAssignmentRequest {
        <ListPolicyAssignmentRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListPolicyAssignmentRequest {
    pub fn new() -> ListPolicyAssignmentRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .gobgpapi.PolicyDirection direction = 2;


    pub fn get_direction(&self) -> PolicyDirection {
        self.direction
    }
    pub fn clear_direction(&mut self) {
        self.direction = PolicyDirection::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: PolicyDirection) {
        self.direction = v;
    }
}

impl ::protobuf::Message for ListPolicyAssignmentRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.direction, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.direction != PolicyDirection::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(2, self.direction);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.direction != PolicyDirection::UNKNOWN {
            os.write_enum(2, self.direction.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListPolicyAssignmentRequest {
        ListPolicyAssignmentRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &ListPolicyAssignmentRequest| { &m.name },
                    |m: &mut ListPolicyAssignmentRequest| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PolicyDirection>>(
                    "direction",
                    |m: &ListPolicyAssignmentRequest| { &m.direction },
                    |m: &mut ListPolicyAssignmentRequest| { &mut m.direction },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListPolicyAssignmentRequest>(
                    "ListPolicyAssignmentRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListPolicyAssignmentRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListPolicyAssignmentRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListPolicyAssignmentRequest,
        };
        unsafe {
            instance.get(ListPolicyAssignmentRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListPolicyAssignmentRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.direction = PolicyDirection::UNKNOWN;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListPolicyAssignmentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListPolicyAssignmentRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListPolicyAssignmentResponse {
    // message fields
    pub assignment: ::protobuf::SingularPtrField<PolicyAssignment>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListPolicyAssignmentResponse {
    fn default() -> &'a ListPolicyAssignmentResponse {
        <ListPolicyAssignmentResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListPolicyAssignmentResponse {
    pub fn new() -> ListPolicyAssignmentResponse {
        ::std::default::Default::default()
    }

    // .gobgpapi.PolicyAssignment assignment = 1;


    pub fn get_assignment(&self) -> &PolicyAssignment {
        self.assignment.as_ref().unwrap_or_else(|| PolicyAssignment::default_instance())
    }
    pub fn clear_assignment(&mut self) {
        self.assignment.clear();
    }

    pub fn has_assignment(&self) -> bool {
        self.assignment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assignment(&mut self, v: PolicyAssignment) {
        self.assignment = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_assignment(&mut self) -> &mut PolicyAssignment {
        if self.assignment.is_none() {
            self.assignment.set_default();
        }
        self.assignment.as_mut().unwrap()
    }

    // Take field
    pub fn take_assignment(&mut self) -> PolicyAssignment {
        self.assignment.take().unwrap_or_else(|| PolicyAssignment::new())
    }
}

impl ::protobuf::Message for ListPolicyAssignmentResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.assignment {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.assignment)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.assignment.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.assignment.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListPolicyAssignmentResponse {
        ListPolicyAssignmentResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PolicyAssignment>>(
                    "assignment",
                    |m: &ListPolicyAssignmentResponse| { &m.assignment },
                    |m: &mut ListPolicyAssignmentResponse| { &mut m.assignment },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListPolicyAssignmentResponse>(
                    "ListPolicyAssignmentResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListPolicyAssignmentResponse {
        static mut instance: ::protobuf::lazy::Lazy<ListPolicyAssignmentResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListPolicyAssignmentResponse,
        };
        unsafe {
            instance.get(ListPolicyAssignmentResponse::new)
        }
    }
}

impl ::protobuf::Clear for ListPolicyAssignmentResponse {
    fn clear(&mut self) {
        self.assignment.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListPolicyAssignmentResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListPolicyAssignmentResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetPolicyAssignmentRequest {
    // message fields
    pub assignment: ::protobuf::SingularPtrField<PolicyAssignment>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetPolicyAssignmentRequest {
    fn default() -> &'a SetPolicyAssignmentRequest {
        <SetPolicyAssignmentRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetPolicyAssignmentRequest {
    pub fn new() -> SetPolicyAssignmentRequest {
        ::std::default::Default::default()
    }

    // .gobgpapi.PolicyAssignment assignment = 1;


    pub fn get_assignment(&self) -> &PolicyAssignment {
        self.assignment.as_ref().unwrap_or_else(|| PolicyAssignment::default_instance())
    }
    pub fn clear_assignment(&mut self) {
        self.assignment.clear();
    }

    pub fn has_assignment(&self) -> bool {
        self.assignment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assignment(&mut self, v: PolicyAssignment) {
        self.assignment = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_assignment(&mut self) -> &mut PolicyAssignment {
        if self.assignment.is_none() {
            self.assignment.set_default();
        }
        self.assignment.as_mut().unwrap()
    }

    // Take field
    pub fn take_assignment(&mut self) -> PolicyAssignment {
        self.assignment.take().unwrap_or_else(|| PolicyAssignment::new())
    }
}

impl ::protobuf::Message for SetPolicyAssignmentRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.assignment {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.assignment)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.assignment.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.assignment.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetPolicyAssignmentRequest {
        SetPolicyAssignmentRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PolicyAssignment>>(
                    "assignment",
                    |m: &SetPolicyAssignmentRequest| { &m.assignment },
                    |m: &mut SetPolicyAssignmentRequest| { &mut m.assignment },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetPolicyAssignmentRequest>(
                    "SetPolicyAssignmentRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SetPolicyAssignmentRequest {
        static mut instance: ::protobuf::lazy::Lazy<SetPolicyAssignmentRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetPolicyAssignmentRequest,
        };
        unsafe {
            instance.get(SetPolicyAssignmentRequest::new)
        }
    }
}

impl ::protobuf::Clear for SetPolicyAssignmentRequest {
    fn clear(&mut self) {
        self.assignment.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetPolicyAssignmentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetPolicyAssignmentRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddRpkiRequest {
    // message fields
    pub address: ::std::string::String,
    pub port: u32,
    pub lifetime: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddRpkiRequest {
    fn default() -> &'a AddRpkiRequest {
        <AddRpkiRequest as ::protobuf::Message>::default_instance()
    }
}

impl AddRpkiRequest {
    pub fn new() -> AddRpkiRequest {
        ::std::default::Default::default()
    }

    // string address = 1;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // uint32 port = 2;


    pub fn get_port(&self) -> u32 {
        self.port
    }
    pub fn clear_port(&mut self) {
        self.port = 0;
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: u32) {
        self.port = v;
    }

    // int64 lifetime = 3;


    pub fn get_lifetime(&self) -> i64 {
        self.lifetime
    }
    pub fn clear_lifetime(&mut self) {
        self.lifetime = 0;
    }

    // Param is passed by value, moved
    pub fn set_lifetime(&mut self, v: i64) {
        self.lifetime = v;
    }
}

impl ::protobuf::Message for AddRpkiRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.port = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.lifetime = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::value_size(2, self.port, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.lifetime != 0 {
            my_size += ::protobuf::rt::value_size(3, self.lifetime, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if self.port != 0 {
            os.write_uint32(2, self.port)?;
        }
        if self.lifetime != 0 {
            os.write_int64(3, self.lifetime)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddRpkiRequest {
        AddRpkiRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "address",
                    |m: &AddRpkiRequest| { &m.address },
                    |m: &mut AddRpkiRequest| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "port",
                    |m: &AddRpkiRequest| { &m.port },
                    |m: &mut AddRpkiRequest| { &mut m.port },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "lifetime",
                    |m: &AddRpkiRequest| { &m.lifetime },
                    |m: &mut AddRpkiRequest| { &mut m.lifetime },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddRpkiRequest>(
                    "AddRpkiRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AddRpkiRequest {
        static mut instance: ::protobuf::lazy::Lazy<AddRpkiRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddRpkiRequest,
        };
        unsafe {
            instance.get(AddRpkiRequest::new)
        }
    }
}

impl ::protobuf::Clear for AddRpkiRequest {
    fn clear(&mut self) {
        self.address.clear();
        self.port = 0;
        self.lifetime = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddRpkiRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddRpkiRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteRpkiRequest {
    // message fields
    pub address: ::std::string::String,
    pub port: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteRpkiRequest {
    fn default() -> &'a DeleteRpkiRequest {
        <DeleteRpkiRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteRpkiRequest {
    pub fn new() -> DeleteRpkiRequest {
        ::std::default::Default::default()
    }

    // string address = 1;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // uint32 port = 2;


    pub fn get_port(&self) -> u32 {
        self.port
    }
    pub fn clear_port(&mut self) {
        self.port = 0;
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: u32) {
        self.port = v;
    }
}

impl ::protobuf::Message for DeleteRpkiRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.port = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::value_size(2, self.port, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if self.port != 0 {
            os.write_uint32(2, self.port)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteRpkiRequest {
        DeleteRpkiRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "address",
                    |m: &DeleteRpkiRequest| { &m.address },
                    |m: &mut DeleteRpkiRequest| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "port",
                    |m: &DeleteRpkiRequest| { &m.port },
                    |m: &mut DeleteRpkiRequest| { &mut m.port },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeleteRpkiRequest>(
                    "DeleteRpkiRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeleteRpkiRequest {
        static mut instance: ::protobuf::lazy::Lazy<DeleteRpkiRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteRpkiRequest,
        };
        unsafe {
            instance.get(DeleteRpkiRequest::new)
        }
    }
}

impl ::protobuf::Clear for DeleteRpkiRequest {
    fn clear(&mut self) {
        self.address.clear();
        self.port = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteRpkiRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteRpkiRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListRpkiRequest {
    // message fields
    pub family: ::protobuf::SingularPtrField<Family>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListRpkiRequest {
    fn default() -> &'a ListRpkiRequest {
        <ListRpkiRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListRpkiRequest {
    pub fn new() -> ListRpkiRequest {
        ::std::default::Default::default()
    }

    // .gobgpapi.Family family = 1;


    pub fn get_family(&self) -> &Family {
        self.family.as_ref().unwrap_or_else(|| Family::default_instance())
    }
    pub fn clear_family(&mut self) {
        self.family.clear();
    }

    pub fn has_family(&self) -> bool {
        self.family.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family(&mut self, v: Family) {
        self.family = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_family(&mut self) -> &mut Family {
        if self.family.is_none() {
            self.family.set_default();
        }
        self.family.as_mut().unwrap()
    }

    // Take field
    pub fn take_family(&mut self) -> Family {
        self.family.take().unwrap_or_else(|| Family::new())
    }
}

impl ::protobuf::Message for ListRpkiRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.family {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.family)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.family.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.family.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListRpkiRequest {
        ListRpkiRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Family>>(
                    "family",
                    |m: &ListRpkiRequest| { &m.family },
                    |m: &mut ListRpkiRequest| { &mut m.family },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListRpkiRequest>(
                    "ListRpkiRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListRpkiRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListRpkiRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListRpkiRequest,
        };
        unsafe {
            instance.get(ListRpkiRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListRpkiRequest {
    fn clear(&mut self) {
        self.family.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListRpkiRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListRpkiRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListRpkiResponse {
    // message fields
    pub server: ::protobuf::SingularPtrField<Rpki>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListRpkiResponse {
    fn default() -> &'a ListRpkiResponse {
        <ListRpkiResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListRpkiResponse {
    pub fn new() -> ListRpkiResponse {
        ::std::default::Default::default()
    }

    // .gobgpapi.Rpki server = 1;


    pub fn get_server(&self) -> &Rpki {
        self.server.as_ref().unwrap_or_else(|| Rpki::default_instance())
    }
    pub fn clear_server(&mut self) {
        self.server.clear();
    }

    pub fn has_server(&self) -> bool {
        self.server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server(&mut self, v: Rpki) {
        self.server = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server(&mut self) -> &mut Rpki {
        if self.server.is_none() {
            self.server.set_default();
        }
        self.server.as_mut().unwrap()
    }

    // Take field
    pub fn take_server(&mut self) -> Rpki {
        self.server.take().unwrap_or_else(|| Rpki::new())
    }
}

impl ::protobuf::Message for ListRpkiResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.server {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.server)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.server.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.server.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListRpkiResponse {
        ListRpkiResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Rpki>>(
                    "server",
                    |m: &ListRpkiResponse| { &m.server },
                    |m: &mut ListRpkiResponse| { &mut m.server },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListRpkiResponse>(
                    "ListRpkiResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListRpkiResponse {
        static mut instance: ::protobuf::lazy::Lazy<ListRpkiResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListRpkiResponse,
        };
        unsafe {
            instance.get(ListRpkiResponse::new)
        }
    }
}

impl ::protobuf::Clear for ListRpkiResponse {
    fn clear(&mut self) {
        self.server.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListRpkiResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListRpkiResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EnableRpkiRequest {
    // message fields
    pub address: ::std::string::String,
    pub port: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EnableRpkiRequest {
    fn default() -> &'a EnableRpkiRequest {
        <EnableRpkiRequest as ::protobuf::Message>::default_instance()
    }
}

impl EnableRpkiRequest {
    pub fn new() -> EnableRpkiRequest {
        ::std::default::Default::default()
    }

    // string address = 1;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // uint32 port = 2;


    pub fn get_port(&self) -> u32 {
        self.port
    }
    pub fn clear_port(&mut self) {
        self.port = 0;
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: u32) {
        self.port = v;
    }
}

impl ::protobuf::Message for EnableRpkiRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.port = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::value_size(2, self.port, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if self.port != 0 {
            os.write_uint32(2, self.port)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EnableRpkiRequest {
        EnableRpkiRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "address",
                    |m: &EnableRpkiRequest| { &m.address },
                    |m: &mut EnableRpkiRequest| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "port",
                    |m: &EnableRpkiRequest| { &m.port },
                    |m: &mut EnableRpkiRequest| { &mut m.port },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EnableRpkiRequest>(
                    "EnableRpkiRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EnableRpkiRequest {
        static mut instance: ::protobuf::lazy::Lazy<EnableRpkiRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EnableRpkiRequest,
        };
        unsafe {
            instance.get(EnableRpkiRequest::new)
        }
    }
}

impl ::protobuf::Clear for EnableRpkiRequest {
    fn clear(&mut self) {
        self.address.clear();
        self.port = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EnableRpkiRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EnableRpkiRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DisableRpkiRequest {
    // message fields
    pub address: ::std::string::String,
    pub port: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DisableRpkiRequest {
    fn default() -> &'a DisableRpkiRequest {
        <DisableRpkiRequest as ::protobuf::Message>::default_instance()
    }
}

impl DisableRpkiRequest {
    pub fn new() -> DisableRpkiRequest {
        ::std::default::Default::default()
    }

    // string address = 1;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // uint32 port = 2;


    pub fn get_port(&self) -> u32 {
        self.port
    }
    pub fn clear_port(&mut self) {
        self.port = 0;
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: u32) {
        self.port = v;
    }
}

impl ::protobuf::Message for DisableRpkiRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.port = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::value_size(2, self.port, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if self.port != 0 {
            os.write_uint32(2, self.port)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DisableRpkiRequest {
        DisableRpkiRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "address",
                    |m: &DisableRpkiRequest| { &m.address },
                    |m: &mut DisableRpkiRequest| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "port",
                    |m: &DisableRpkiRequest| { &m.port },
                    |m: &mut DisableRpkiRequest| { &mut m.port },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DisableRpkiRequest>(
                    "DisableRpkiRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DisableRpkiRequest {
        static mut instance: ::protobuf::lazy::Lazy<DisableRpkiRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DisableRpkiRequest,
        };
        unsafe {
            instance.get(DisableRpkiRequest::new)
        }
    }
}

impl ::protobuf::Clear for DisableRpkiRequest {
    fn clear(&mut self) {
        self.address.clear();
        self.port = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DisableRpkiRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DisableRpkiRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResetRpkiRequest {
    // message fields
    pub address: ::std::string::String,
    pub port: u32,
    pub soft: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResetRpkiRequest {
    fn default() -> &'a ResetRpkiRequest {
        <ResetRpkiRequest as ::protobuf::Message>::default_instance()
    }
}

impl ResetRpkiRequest {
    pub fn new() -> ResetRpkiRequest {
        ::std::default::Default::default()
    }

    // string address = 1;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // uint32 port = 2;


    pub fn get_port(&self) -> u32 {
        self.port
    }
    pub fn clear_port(&mut self) {
        self.port = 0;
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: u32) {
        self.port = v;
    }

    // bool soft = 3;


    pub fn get_soft(&self) -> bool {
        self.soft
    }
    pub fn clear_soft(&mut self) {
        self.soft = false;
    }

    // Param is passed by value, moved
    pub fn set_soft(&mut self, v: bool) {
        self.soft = v;
    }
}

impl ::protobuf::Message for ResetRpkiRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.port = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.soft = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::value_size(2, self.port, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.soft != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if self.port != 0 {
            os.write_uint32(2, self.port)?;
        }
        if self.soft != false {
            os.write_bool(3, self.soft)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResetRpkiRequest {
        ResetRpkiRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "address",
                    |m: &ResetRpkiRequest| { &m.address },
                    |m: &mut ResetRpkiRequest| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "port",
                    |m: &ResetRpkiRequest| { &m.port },
                    |m: &mut ResetRpkiRequest| { &mut m.port },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "soft",
                    |m: &ResetRpkiRequest| { &m.soft },
                    |m: &mut ResetRpkiRequest| { &mut m.soft },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ResetRpkiRequest>(
                    "ResetRpkiRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ResetRpkiRequest {
        static mut instance: ::protobuf::lazy::Lazy<ResetRpkiRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ResetRpkiRequest,
        };
        unsafe {
            instance.get(ResetRpkiRequest::new)
        }
    }
}

impl ::protobuf::Clear for ResetRpkiRequest {
    fn clear(&mut self) {
        self.address.clear();
        self.port = 0;
        self.soft = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResetRpkiRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResetRpkiRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListRpkiTableRequest {
    // message fields
    pub family: ::protobuf::SingularPtrField<Family>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListRpkiTableRequest {
    fn default() -> &'a ListRpkiTableRequest {
        <ListRpkiTableRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListRpkiTableRequest {
    pub fn new() -> ListRpkiTableRequest {
        ::std::default::Default::default()
    }

    // .gobgpapi.Family family = 1;


    pub fn get_family(&self) -> &Family {
        self.family.as_ref().unwrap_or_else(|| Family::default_instance())
    }
    pub fn clear_family(&mut self) {
        self.family.clear();
    }

    pub fn has_family(&self) -> bool {
        self.family.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family(&mut self, v: Family) {
        self.family = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_family(&mut self) -> &mut Family {
        if self.family.is_none() {
            self.family.set_default();
        }
        self.family.as_mut().unwrap()
    }

    // Take field
    pub fn take_family(&mut self) -> Family {
        self.family.take().unwrap_or_else(|| Family::new())
    }
}

impl ::protobuf::Message for ListRpkiTableRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.family {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.family)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.family.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.family.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListRpkiTableRequest {
        ListRpkiTableRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Family>>(
                    "family",
                    |m: &ListRpkiTableRequest| { &m.family },
                    |m: &mut ListRpkiTableRequest| { &mut m.family },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListRpkiTableRequest>(
                    "ListRpkiTableRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListRpkiTableRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListRpkiTableRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListRpkiTableRequest,
        };
        unsafe {
            instance.get(ListRpkiTableRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListRpkiTableRequest {
    fn clear(&mut self) {
        self.family.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListRpkiTableRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListRpkiTableRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListRpkiTableResponse {
    // message fields
    pub roa: ::protobuf::SingularPtrField<Roa>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListRpkiTableResponse {
    fn default() -> &'a ListRpkiTableResponse {
        <ListRpkiTableResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListRpkiTableResponse {
    pub fn new() -> ListRpkiTableResponse {
        ::std::default::Default::default()
    }

    // .gobgpapi.Roa roa = 1;


    pub fn get_roa(&self) -> &Roa {
        self.roa.as_ref().unwrap_or_else(|| Roa::default_instance())
    }
    pub fn clear_roa(&mut self) {
        self.roa.clear();
    }

    pub fn has_roa(&self) -> bool {
        self.roa.is_some()
    }

    // Param is passed by value, moved
    pub fn set_roa(&mut self, v: Roa) {
        self.roa = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_roa(&mut self) -> &mut Roa {
        if self.roa.is_none() {
            self.roa.set_default();
        }
        self.roa.as_mut().unwrap()
    }

    // Take field
    pub fn take_roa(&mut self) -> Roa {
        self.roa.take().unwrap_or_else(|| Roa::new())
    }
}

impl ::protobuf::Message for ListRpkiTableResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.roa {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.roa)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.roa.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.roa.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListRpkiTableResponse {
        ListRpkiTableResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Roa>>(
                    "roa",
                    |m: &ListRpkiTableResponse| { &m.roa },
                    |m: &mut ListRpkiTableResponse| { &mut m.roa },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListRpkiTableResponse>(
                    "ListRpkiTableResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListRpkiTableResponse {
        static mut instance: ::protobuf::lazy::Lazy<ListRpkiTableResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListRpkiTableResponse,
        };
        unsafe {
            instance.get(ListRpkiTableResponse::new)
        }
    }
}

impl ::protobuf::Clear for ListRpkiTableResponse {
    fn clear(&mut self) {
        self.roa.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListRpkiTableResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListRpkiTableResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EnableZebraRequest {
    // message fields
    pub url: ::std::string::String,
    pub route_types: ::protobuf::RepeatedField<::std::string::String>,
    pub version: u32,
    pub nexthop_trigger_enable: bool,
    pub nexthop_trigger_delay: u32,
    pub mpls_label_range_size: u32,
    pub software_name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EnableZebraRequest {
    fn default() -> &'a EnableZebraRequest {
        <EnableZebraRequest as ::protobuf::Message>::default_instance()
    }
}

impl EnableZebraRequest {
    pub fn new() -> EnableZebraRequest {
        ::std::default::Default::default()
    }

    // string url = 1;


    pub fn get_url(&self) -> &str {
        &self.url
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        &mut self.url
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.url, ::std::string::String::new())
    }

    // repeated string route_types = 2;


    pub fn get_route_types(&self) -> &[::std::string::String] {
        &self.route_types
    }
    pub fn clear_route_types(&mut self) {
        self.route_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_route_types(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.route_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_route_types(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.route_types
    }

    // Take field
    pub fn take_route_types(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.route_types, ::protobuf::RepeatedField::new())
    }

    // uint32 version = 3;


    pub fn get_version(&self) -> u32 {
        self.version
    }
    pub fn clear_version(&mut self) {
        self.version = 0;
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = v;
    }

    // bool nexthop_trigger_enable = 4;


    pub fn get_nexthop_trigger_enable(&self) -> bool {
        self.nexthop_trigger_enable
    }
    pub fn clear_nexthop_trigger_enable(&mut self) {
        self.nexthop_trigger_enable = false;
    }

    // Param is passed by value, moved
    pub fn set_nexthop_trigger_enable(&mut self, v: bool) {
        self.nexthop_trigger_enable = v;
    }

    // uint32 nexthop_trigger_delay = 5;


    pub fn get_nexthop_trigger_delay(&self) -> u32 {
        self.nexthop_trigger_delay
    }
    pub fn clear_nexthop_trigger_delay(&mut self) {
        self.nexthop_trigger_delay = 0;
    }

    // Param is passed by value, moved
    pub fn set_nexthop_trigger_delay(&mut self, v: u32) {
        self.nexthop_trigger_delay = v;
    }

    // uint32 mpls_label_range_size = 6;


    pub fn get_mpls_label_range_size(&self) -> u32 {
        self.mpls_label_range_size
    }
    pub fn clear_mpls_label_range_size(&mut self) {
        self.mpls_label_range_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_mpls_label_range_size(&mut self, v: u32) {
        self.mpls_label_range_size = v;
    }

    // string software_name = 7;


    pub fn get_software_name(&self) -> &str {
        &self.software_name
    }
    pub fn clear_software_name(&mut self) {
        self.software_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_software_name(&mut self, v: ::std::string::String) {
        self.software_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_software_name(&mut self) -> &mut ::std::string::String {
        &mut self.software_name
    }

    // Take field
    pub fn take_software_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.software_name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for EnableZebraRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.url)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.route_types)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.version = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.nexthop_trigger_enable = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.nexthop_trigger_delay = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.mpls_label_range_size = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.software_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.url);
        }
        for value in &self.route_types {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if self.version != 0 {
            my_size += ::protobuf::rt::value_size(3, self.version, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.nexthop_trigger_enable != false {
            my_size += 2;
        }
        if self.nexthop_trigger_delay != 0 {
            my_size += ::protobuf::rt::value_size(5, self.nexthop_trigger_delay, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.mpls_label_range_size != 0 {
            my_size += ::protobuf::rt::value_size(6, self.mpls_label_range_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.software_name.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.software_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.url.is_empty() {
            os.write_string(1, &self.url)?;
        }
        for v in &self.route_types {
            os.write_string(2, &v)?;
        };
        if self.version != 0 {
            os.write_uint32(3, self.version)?;
        }
        if self.nexthop_trigger_enable != false {
            os.write_bool(4, self.nexthop_trigger_enable)?;
        }
        if self.nexthop_trigger_delay != 0 {
            os.write_uint32(5, self.nexthop_trigger_delay)?;
        }
        if self.mpls_label_range_size != 0 {
            os.write_uint32(6, self.mpls_label_range_size)?;
        }
        if !self.software_name.is_empty() {
            os.write_string(7, &self.software_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EnableZebraRequest {
        EnableZebraRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "url",
                    |m: &EnableZebraRequest| { &m.url },
                    |m: &mut EnableZebraRequest| { &mut m.url },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "route_types",
                    |m: &EnableZebraRequest| { &m.route_types },
                    |m: &mut EnableZebraRequest| { &mut m.route_types },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "version",
                    |m: &EnableZebraRequest| { &m.version },
                    |m: &mut EnableZebraRequest| { &mut m.version },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "nexthop_trigger_enable",
                    |m: &EnableZebraRequest| { &m.nexthop_trigger_enable },
                    |m: &mut EnableZebraRequest| { &mut m.nexthop_trigger_enable },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "nexthop_trigger_delay",
                    |m: &EnableZebraRequest| { &m.nexthop_trigger_delay },
                    |m: &mut EnableZebraRequest| { &mut m.nexthop_trigger_delay },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "mpls_label_range_size",
                    |m: &EnableZebraRequest| { &m.mpls_label_range_size },
                    |m: &mut EnableZebraRequest| { &mut m.mpls_label_range_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "software_name",
                    |m: &EnableZebraRequest| { &m.software_name },
                    |m: &mut EnableZebraRequest| { &mut m.software_name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EnableZebraRequest>(
                    "EnableZebraRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EnableZebraRequest {
        static mut instance: ::protobuf::lazy::Lazy<EnableZebraRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EnableZebraRequest,
        };
        unsafe {
            instance.get(EnableZebraRequest::new)
        }
    }
}

impl ::protobuf::Clear for EnableZebraRequest {
    fn clear(&mut self) {
        self.url.clear();
        self.route_types.clear();
        self.version = 0;
        self.nexthop_trigger_enable = false;
        self.nexthop_trigger_delay = 0;
        self.mpls_label_range_size = 0;
        self.software_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EnableZebraRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EnableZebraRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EnableMrtRequest {
    // message fields
    pub dump_type: i32,
    pub filename: ::std::string::String,
    pub dump_interval: u64,
    pub rotation_interval: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EnableMrtRequest {
    fn default() -> &'a EnableMrtRequest {
        <EnableMrtRequest as ::protobuf::Message>::default_instance()
    }
}

impl EnableMrtRequest {
    pub fn new() -> EnableMrtRequest {
        ::std::default::Default::default()
    }

    // int32 dump_type = 1;


    pub fn get_dump_type(&self) -> i32 {
        self.dump_type
    }
    pub fn clear_dump_type(&mut self) {
        self.dump_type = 0;
    }

    // Param is passed by value, moved
    pub fn set_dump_type(&mut self, v: i32) {
        self.dump_type = v;
    }

    // string filename = 2;


    pub fn get_filename(&self) -> &str {
        &self.filename
    }
    pub fn clear_filename(&mut self) {
        self.filename.clear();
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        &mut self.filename
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.filename, ::std::string::String::new())
    }

    // uint64 dump_interval = 3;


    pub fn get_dump_interval(&self) -> u64 {
        self.dump_interval
    }
    pub fn clear_dump_interval(&mut self) {
        self.dump_interval = 0;
    }

    // Param is passed by value, moved
    pub fn set_dump_interval(&mut self, v: u64) {
        self.dump_interval = v;
    }

    // uint64 rotation_interval = 4;


    pub fn get_rotation_interval(&self) -> u64 {
        self.rotation_interval
    }
    pub fn clear_rotation_interval(&mut self) {
        self.rotation_interval = 0;
    }

    // Param is passed by value, moved
    pub fn set_rotation_interval(&mut self, v: u64) {
        self.rotation_interval = v;
    }
}

impl ::protobuf::Message for EnableMrtRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dump_type = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.filename)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.dump_interval = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.rotation_interval = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.dump_type != 0 {
            my_size += ::protobuf::rt::value_size(1, self.dump_type, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.filename.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.filename);
        }
        if self.dump_interval != 0 {
            my_size += ::protobuf::rt::value_size(3, self.dump_interval, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.rotation_interval != 0 {
            my_size += ::protobuf::rt::value_size(4, self.rotation_interval, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.dump_type != 0 {
            os.write_int32(1, self.dump_type)?;
        }
        if !self.filename.is_empty() {
            os.write_string(2, &self.filename)?;
        }
        if self.dump_interval != 0 {
            os.write_uint64(3, self.dump_interval)?;
        }
        if self.rotation_interval != 0 {
            os.write_uint64(4, self.rotation_interval)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EnableMrtRequest {
        EnableMrtRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dump_type",
                    |m: &EnableMrtRequest| { &m.dump_type },
                    |m: &mut EnableMrtRequest| { &mut m.dump_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "filename",
                    |m: &EnableMrtRequest| { &m.filename },
                    |m: &mut EnableMrtRequest| { &mut m.filename },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "dump_interval",
                    |m: &EnableMrtRequest| { &m.dump_interval },
                    |m: &mut EnableMrtRequest| { &mut m.dump_interval },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "rotation_interval",
                    |m: &EnableMrtRequest| { &m.rotation_interval },
                    |m: &mut EnableMrtRequest| { &mut m.rotation_interval },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EnableMrtRequest>(
                    "EnableMrtRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EnableMrtRequest {
        static mut instance: ::protobuf::lazy::Lazy<EnableMrtRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EnableMrtRequest,
        };
        unsafe {
            instance.get(EnableMrtRequest::new)
        }
    }
}

impl ::protobuf::Clear for EnableMrtRequest {
    fn clear(&mut self) {
        self.dump_type = 0;
        self.filename.clear();
        self.dump_interval = 0;
        self.rotation_interval = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EnableMrtRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EnableMrtRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DisableMrtRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DisableMrtRequest {
    fn default() -> &'a DisableMrtRequest {
        <DisableMrtRequest as ::protobuf::Message>::default_instance()
    }
}

impl DisableMrtRequest {
    pub fn new() -> DisableMrtRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DisableMrtRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DisableMrtRequest {
        DisableMrtRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<DisableMrtRequest>(
                    "DisableMrtRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DisableMrtRequest {
        static mut instance: ::protobuf::lazy::Lazy<DisableMrtRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DisableMrtRequest,
        };
        unsafe {
            instance.get(DisableMrtRequest::new)
        }
    }
}

impl ::protobuf::Clear for DisableMrtRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DisableMrtRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DisableMrtRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddBmpRequest {
    // message fields
    pub address: ::std::string::String,
    pub port: u32,
    pub policy: AddBmpRequest_MonitoringPolicy,
    pub StatisticsTimeout: i32,
    pub SysName: ::std::string::String,
    pub SysDescr: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddBmpRequest {
    fn default() -> &'a AddBmpRequest {
        <AddBmpRequest as ::protobuf::Message>::default_instance()
    }
}

impl AddBmpRequest {
    pub fn new() -> AddBmpRequest {
        ::std::default::Default::default()
    }

    // string address = 1;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // uint32 port = 2;


    pub fn get_port(&self) -> u32 {
        self.port
    }
    pub fn clear_port(&mut self) {
        self.port = 0;
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: u32) {
        self.port = v;
    }

    // .gobgpapi.AddBmpRequest.MonitoringPolicy policy = 3;


    pub fn get_policy(&self) -> AddBmpRequest_MonitoringPolicy {
        self.policy
    }
    pub fn clear_policy(&mut self) {
        self.policy = AddBmpRequest_MonitoringPolicy::PRE;
    }

    // Param is passed by value, moved
    pub fn set_policy(&mut self, v: AddBmpRequest_MonitoringPolicy) {
        self.policy = v;
    }

    // int32 StatisticsTimeout = 4;


    pub fn get_StatisticsTimeout(&self) -> i32 {
        self.StatisticsTimeout
    }
    pub fn clear_StatisticsTimeout(&mut self) {
        self.StatisticsTimeout = 0;
    }

    // Param is passed by value, moved
    pub fn set_StatisticsTimeout(&mut self, v: i32) {
        self.StatisticsTimeout = v;
    }

    // string SysName = 5;


    pub fn get_SysName(&self) -> &str {
        &self.SysName
    }
    pub fn clear_SysName(&mut self) {
        self.SysName.clear();
    }

    // Param is passed by value, moved
    pub fn set_SysName(&mut self, v: ::std::string::String) {
        self.SysName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_SysName(&mut self) -> &mut ::std::string::String {
        &mut self.SysName
    }

    // Take field
    pub fn take_SysName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.SysName, ::std::string::String::new())
    }

    // string SysDescr = 6;


    pub fn get_SysDescr(&self) -> &str {
        &self.SysDescr
    }
    pub fn clear_SysDescr(&mut self) {
        self.SysDescr.clear();
    }

    // Param is passed by value, moved
    pub fn set_SysDescr(&mut self, v: ::std::string::String) {
        self.SysDescr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_SysDescr(&mut self) -> &mut ::std::string::String {
        &mut self.SysDescr
    }

    // Take field
    pub fn take_SysDescr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.SysDescr, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AddBmpRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.port = tmp;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.policy, 3, &mut self.unknown_fields)?
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.StatisticsTimeout = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.SysName)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.SysDescr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::value_size(2, self.port, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.policy != AddBmpRequest_MonitoringPolicy::PRE {
            my_size += ::protobuf::rt::enum_size(3, self.policy);
        }
        if self.StatisticsTimeout != 0 {
            my_size += ::protobuf::rt::value_size(4, self.StatisticsTimeout, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.SysName.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.SysName);
        }
        if !self.SysDescr.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.SysDescr);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if self.port != 0 {
            os.write_uint32(2, self.port)?;
        }
        if self.policy != AddBmpRequest_MonitoringPolicy::PRE {
            os.write_enum(3, self.policy.value())?;
        }
        if self.StatisticsTimeout != 0 {
            os.write_int32(4, self.StatisticsTimeout)?;
        }
        if !self.SysName.is_empty() {
            os.write_string(5, &self.SysName)?;
        }
        if !self.SysDescr.is_empty() {
            os.write_string(6, &self.SysDescr)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddBmpRequest {
        AddBmpRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "address",
                    |m: &AddBmpRequest| { &m.address },
                    |m: &mut AddBmpRequest| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "port",
                    |m: &AddBmpRequest| { &m.port },
                    |m: &mut AddBmpRequest| { &mut m.port },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AddBmpRequest_MonitoringPolicy>>(
                    "policy",
                    |m: &AddBmpRequest| { &m.policy },
                    |m: &mut AddBmpRequest| { &mut m.policy },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "StatisticsTimeout",
                    |m: &AddBmpRequest| { &m.StatisticsTimeout },
                    |m: &mut AddBmpRequest| { &mut m.StatisticsTimeout },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "SysName",
                    |m: &AddBmpRequest| { &m.SysName },
                    |m: &mut AddBmpRequest| { &mut m.SysName },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "SysDescr",
                    |m: &AddBmpRequest| { &m.SysDescr },
                    |m: &mut AddBmpRequest| { &mut m.SysDescr },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddBmpRequest>(
                    "AddBmpRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AddBmpRequest {
        static mut instance: ::protobuf::lazy::Lazy<AddBmpRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddBmpRequest,
        };
        unsafe {
            instance.get(AddBmpRequest::new)
        }
    }
}

impl ::protobuf::Clear for AddBmpRequest {
    fn clear(&mut self) {
        self.address.clear();
        self.port = 0;
        self.policy = AddBmpRequest_MonitoringPolicy::PRE;
        self.StatisticsTimeout = 0;
        self.SysName.clear();
        self.SysDescr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddBmpRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddBmpRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AddBmpRequest_MonitoringPolicy {
    PRE = 0,
    POST = 1,
    BOTH = 2,
    LOCAL = 3,
    ALL = 4,
}

impl ::protobuf::ProtobufEnum for AddBmpRequest_MonitoringPolicy {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AddBmpRequest_MonitoringPolicy> {
        match value {
            0 => ::std::option::Option::Some(AddBmpRequest_MonitoringPolicy::PRE),
            1 => ::std::option::Option::Some(AddBmpRequest_MonitoringPolicy::POST),
            2 => ::std::option::Option::Some(AddBmpRequest_MonitoringPolicy::BOTH),
            3 => ::std::option::Option::Some(AddBmpRequest_MonitoringPolicy::LOCAL),
            4 => ::std::option::Option::Some(AddBmpRequest_MonitoringPolicy::ALL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AddBmpRequest_MonitoringPolicy] = &[
            AddBmpRequest_MonitoringPolicy::PRE,
            AddBmpRequest_MonitoringPolicy::POST,
            AddBmpRequest_MonitoringPolicy::BOTH,
            AddBmpRequest_MonitoringPolicy::LOCAL,
            AddBmpRequest_MonitoringPolicy::ALL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("AddBmpRequest_MonitoringPolicy", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for AddBmpRequest_MonitoringPolicy {
}

impl ::std::default::Default for AddBmpRequest_MonitoringPolicy {
    fn default() -> Self {
        AddBmpRequest_MonitoringPolicy::PRE
    }
}

impl ::protobuf::reflect::ProtobufValue for AddBmpRequest_MonitoringPolicy {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteBmpRequest {
    // message fields
    pub address: ::std::string::String,
    pub port: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteBmpRequest {
    fn default() -> &'a DeleteBmpRequest {
        <DeleteBmpRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteBmpRequest {
    pub fn new() -> DeleteBmpRequest {
        ::std::default::Default::default()
    }

    // string address = 1;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // uint32 port = 2;


    pub fn get_port(&self) -> u32 {
        self.port
    }
    pub fn clear_port(&mut self) {
        self.port = 0;
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: u32) {
        self.port = v;
    }
}

impl ::protobuf::Message for DeleteBmpRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.port = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::value_size(2, self.port, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if self.port != 0 {
            os.write_uint32(2, self.port)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteBmpRequest {
        DeleteBmpRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "address",
                    |m: &DeleteBmpRequest| { &m.address },
                    |m: &mut DeleteBmpRequest| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "port",
                    |m: &DeleteBmpRequest| { &m.port },
                    |m: &mut DeleteBmpRequest| { &mut m.port },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeleteBmpRequest>(
                    "DeleteBmpRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeleteBmpRequest {
        static mut instance: ::protobuf::lazy::Lazy<DeleteBmpRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteBmpRequest,
        };
        unsafe {
            instance.get(DeleteBmpRequest::new)
        }
    }
}

impl ::protobuf::Clear for DeleteBmpRequest {
    fn clear(&mut self) {
        self.address.clear();
        self.port = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteBmpRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteBmpRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Family {
    // message fields
    pub afi: Family_Afi,
    pub safi: Family_Safi,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Family {
    fn default() -> &'a Family {
        <Family as ::protobuf::Message>::default_instance()
    }
}

impl Family {
    pub fn new() -> Family {
        ::std::default::Default::default()
    }

    // .gobgpapi.Family.Afi afi = 1;


    pub fn get_afi(&self) -> Family_Afi {
        self.afi
    }
    pub fn clear_afi(&mut self) {
        self.afi = Family_Afi::AFI_UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_afi(&mut self, v: Family_Afi) {
        self.afi = v;
    }

    // .gobgpapi.Family.Safi safi = 2;


    pub fn get_safi(&self) -> Family_Safi {
        self.safi
    }
    pub fn clear_safi(&mut self) {
        self.safi = Family_Safi::SAFI_UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_safi(&mut self, v: Family_Safi) {
        self.safi = v;
    }
}

impl ::protobuf::Message for Family {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.afi, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.safi, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.afi != Family_Afi::AFI_UNKNOWN {
            my_size += ::protobuf::rt::enum_size(1, self.afi);
        }
        if self.safi != Family_Safi::SAFI_UNKNOWN {
            my_size += ::protobuf::rt::enum_size(2, self.safi);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.afi != Family_Afi::AFI_UNKNOWN {
            os.write_enum(1, self.afi.value())?;
        }
        if self.safi != Family_Safi::SAFI_UNKNOWN {
            os.write_enum(2, self.safi.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Family {
        Family::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Family_Afi>>(
                    "afi",
                    |m: &Family| { &m.afi },
                    |m: &mut Family| { &mut m.afi },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Family_Safi>>(
                    "safi",
                    |m: &Family| { &m.safi },
                    |m: &mut Family| { &mut m.safi },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Family>(
                    "Family",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Family {
        static mut instance: ::protobuf::lazy::Lazy<Family> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Family,
        };
        unsafe {
            instance.get(Family::new)
        }
    }
}

impl ::protobuf::Clear for Family {
    fn clear(&mut self) {
        self.afi = Family_Afi::AFI_UNKNOWN;
        self.safi = Family_Safi::SAFI_UNKNOWN;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Family {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Family {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Family_Afi {
    AFI_UNKNOWN = 0,
    AFI_IP = 1,
    AFI_IP6 = 2,
    AFI_L2VPN = 25,
    AFI_LS = 16388,
    AFI_OPAQUE = 16397,
}

impl ::protobuf::ProtobufEnum for Family_Afi {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Family_Afi> {
        match value {
            0 => ::std::option::Option::Some(Family_Afi::AFI_UNKNOWN),
            1 => ::std::option::Option::Some(Family_Afi::AFI_IP),
            2 => ::std::option::Option::Some(Family_Afi::AFI_IP6),
            25 => ::std::option::Option::Some(Family_Afi::AFI_L2VPN),
            16388 => ::std::option::Option::Some(Family_Afi::AFI_LS),
            16397 => ::std::option::Option::Some(Family_Afi::AFI_OPAQUE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Family_Afi] = &[
            Family_Afi::AFI_UNKNOWN,
            Family_Afi::AFI_IP,
            Family_Afi::AFI_IP6,
            Family_Afi::AFI_L2VPN,
            Family_Afi::AFI_LS,
            Family_Afi::AFI_OPAQUE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Family_Afi", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Family_Afi {
}

impl ::std::default::Default for Family_Afi {
    fn default() -> Self {
        Family_Afi::AFI_UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for Family_Afi {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Family_Safi {
    SAFI_UNKNOWN = 0,
    SAFI_UNICAST = 1,
    SAFI_MULTICAST = 2,
    SAFI_MPLS_LABEL = 4,
    SAFI_ENCAPSULATION = 7,
    SAFI_VPLS = 65,
    SAFI_EVPN = 70,
    SAFI_LS = 71,
    SAFI_MPLS_VPN = 128,
    SAFI_MPLS_VPN_MULTICAST = 129,
    SAFI_ROUTE_TARGET_CONSTRAINTS = 132,
    SAFI_FLOW_SPEC_UNICAST = 133,
    SAFI_FLOW_SPEC_VPN = 134,
    SAFI_KEY_VALUE = 241,
}

impl ::protobuf::ProtobufEnum for Family_Safi {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Family_Safi> {
        match value {
            0 => ::std::option::Option::Some(Family_Safi::SAFI_UNKNOWN),
            1 => ::std::option::Option::Some(Family_Safi::SAFI_UNICAST),
            2 => ::std::option::Option::Some(Family_Safi::SAFI_MULTICAST),
            4 => ::std::option::Option::Some(Family_Safi::SAFI_MPLS_LABEL),
            7 => ::std::option::Option::Some(Family_Safi::SAFI_ENCAPSULATION),
            65 => ::std::option::Option::Some(Family_Safi::SAFI_VPLS),
            70 => ::std::option::Option::Some(Family_Safi::SAFI_EVPN),
            71 => ::std::option::Option::Some(Family_Safi::SAFI_LS),
            128 => ::std::option::Option::Some(Family_Safi::SAFI_MPLS_VPN),
            129 => ::std::option::Option::Some(Family_Safi::SAFI_MPLS_VPN_MULTICAST),
            132 => ::std::option::Option::Some(Family_Safi::SAFI_ROUTE_TARGET_CONSTRAINTS),
            133 => ::std::option::Option::Some(Family_Safi::SAFI_FLOW_SPEC_UNICAST),
            134 => ::std::option::Option::Some(Family_Safi::SAFI_FLOW_SPEC_VPN),
            241 => ::std::option::Option::Some(Family_Safi::SAFI_KEY_VALUE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Family_Safi] = &[
            Family_Safi::SAFI_UNKNOWN,
            Family_Safi::SAFI_UNICAST,
            Family_Safi::SAFI_MULTICAST,
            Family_Safi::SAFI_MPLS_LABEL,
            Family_Safi::SAFI_ENCAPSULATION,
            Family_Safi::SAFI_VPLS,
            Family_Safi::SAFI_EVPN,
            Family_Safi::SAFI_LS,
            Family_Safi::SAFI_MPLS_VPN,
            Family_Safi::SAFI_MPLS_VPN_MULTICAST,
            Family_Safi::SAFI_ROUTE_TARGET_CONSTRAINTS,
            Family_Safi::SAFI_FLOW_SPEC_UNICAST,
            Family_Safi::SAFI_FLOW_SPEC_VPN,
            Family_Safi::SAFI_KEY_VALUE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Family_Safi", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Family_Safi {
}

impl ::std::default::Default for Family_Safi {
    fn default() -> Self {
        Family_Safi::SAFI_UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for Family_Safi {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Validation {
    // message fields
    pub state: Validation_State,
    pub reason: Validation_Reason,
    pub matched: ::protobuf::RepeatedField<Roa>,
    pub unmatched_as: ::protobuf::RepeatedField<Roa>,
    pub unmatched_length: ::protobuf::RepeatedField<Roa>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Validation {
    fn default() -> &'a Validation {
        <Validation as ::protobuf::Message>::default_instance()
    }
}

impl Validation {
    pub fn new() -> Validation {
        ::std::default::Default::default()
    }

    // .gobgpapi.Validation.State state = 1;


    pub fn get_state(&self) -> Validation_State {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = Validation_State::STATE_NONE;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: Validation_State) {
        self.state = v;
    }

    // .gobgpapi.Validation.Reason reason = 2;


    pub fn get_reason(&self) -> Validation_Reason {
        self.reason
    }
    pub fn clear_reason(&mut self) {
        self.reason = Validation_Reason::REASOT_NONE;
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: Validation_Reason) {
        self.reason = v;
    }

    // repeated .gobgpapi.Roa matched = 3;


    pub fn get_matched(&self) -> &[Roa] {
        &self.matched
    }
    pub fn clear_matched(&mut self) {
        self.matched.clear();
    }

    // Param is passed by value, moved
    pub fn set_matched(&mut self, v: ::protobuf::RepeatedField<Roa>) {
        self.matched = v;
    }

    // Mutable pointer to the field.
    pub fn mut_matched(&mut self) -> &mut ::protobuf::RepeatedField<Roa> {
        &mut self.matched
    }

    // Take field
    pub fn take_matched(&mut self) -> ::protobuf::RepeatedField<Roa> {
        ::std::mem::replace(&mut self.matched, ::protobuf::RepeatedField::new())
    }

    // repeated .gobgpapi.Roa unmatched_as = 4;


    pub fn get_unmatched_as(&self) -> &[Roa] {
        &self.unmatched_as
    }
    pub fn clear_unmatched_as(&mut self) {
        self.unmatched_as.clear();
    }

    // Param is passed by value, moved
    pub fn set_unmatched_as(&mut self, v: ::protobuf::RepeatedField<Roa>) {
        self.unmatched_as = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unmatched_as(&mut self) -> &mut ::protobuf::RepeatedField<Roa> {
        &mut self.unmatched_as
    }

    // Take field
    pub fn take_unmatched_as(&mut self) -> ::protobuf::RepeatedField<Roa> {
        ::std::mem::replace(&mut self.unmatched_as, ::protobuf::RepeatedField::new())
    }

    // repeated .gobgpapi.Roa unmatched_length = 5;


    pub fn get_unmatched_length(&self) -> &[Roa] {
        &self.unmatched_length
    }
    pub fn clear_unmatched_length(&mut self) {
        self.unmatched_length.clear();
    }

    // Param is passed by value, moved
    pub fn set_unmatched_length(&mut self, v: ::protobuf::RepeatedField<Roa>) {
        self.unmatched_length = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unmatched_length(&mut self) -> &mut ::protobuf::RepeatedField<Roa> {
        &mut self.unmatched_length
    }

    // Take field
    pub fn take_unmatched_length(&mut self) -> ::protobuf::RepeatedField<Roa> {
        ::std::mem::replace(&mut self.unmatched_length, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Validation {
    fn is_initialized(&self) -> bool {
        for v in &self.matched {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unmatched_as {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unmatched_length {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.reason, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.matched)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.unmatched_as)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.unmatched_length)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.state != Validation_State::STATE_NONE {
            my_size += ::protobuf::rt::enum_size(1, self.state);
        }
        if self.reason != Validation_Reason::REASOT_NONE {
            my_size += ::protobuf::rt::enum_size(2, self.reason);
        }
        for value in &self.matched {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.unmatched_as {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.unmatched_length {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.state != Validation_State::STATE_NONE {
            os.write_enum(1, self.state.value())?;
        }
        if self.reason != Validation_Reason::REASOT_NONE {
            os.write_enum(2, self.reason.value())?;
        }
        for v in &self.matched {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.unmatched_as {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.unmatched_length {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Validation {
        Validation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Validation_State>>(
                    "state",
                    |m: &Validation| { &m.state },
                    |m: &mut Validation| { &mut m.state },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Validation_Reason>>(
                    "reason",
                    |m: &Validation| { &m.reason },
                    |m: &mut Validation| { &mut m.reason },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Roa>>(
                    "matched",
                    |m: &Validation| { &m.matched },
                    |m: &mut Validation| { &mut m.matched },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Roa>>(
                    "unmatched_as",
                    |m: &Validation| { &m.unmatched_as },
                    |m: &mut Validation| { &mut m.unmatched_as },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Roa>>(
                    "unmatched_length",
                    |m: &Validation| { &m.unmatched_length },
                    |m: &mut Validation| { &mut m.unmatched_length },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Validation>(
                    "Validation",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Validation {
        static mut instance: ::protobuf::lazy::Lazy<Validation> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Validation,
        };
        unsafe {
            instance.get(Validation::new)
        }
    }
}

impl ::protobuf::Clear for Validation {
    fn clear(&mut self) {
        self.state = Validation_State::STATE_NONE;
        self.reason = Validation_Reason::REASOT_NONE;
        self.matched.clear();
        self.unmatched_as.clear();
        self.unmatched_length.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Validation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Validation {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Validation_State {
    STATE_NONE = 0,
    STATE_NOT_FOUND = 1,
    STATE_VALID = 2,
    STATE_INVALID = 3,
}

impl ::protobuf::ProtobufEnum for Validation_State {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Validation_State> {
        match value {
            0 => ::std::option::Option::Some(Validation_State::STATE_NONE),
            1 => ::std::option::Option::Some(Validation_State::STATE_NOT_FOUND),
            2 => ::std::option::Option::Some(Validation_State::STATE_VALID),
            3 => ::std::option::Option::Some(Validation_State::STATE_INVALID),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Validation_State] = &[
            Validation_State::STATE_NONE,
            Validation_State::STATE_NOT_FOUND,
            Validation_State::STATE_VALID,
            Validation_State::STATE_INVALID,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Validation_State", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Validation_State {
}

impl ::std::default::Default for Validation_State {
    fn default() -> Self {
        Validation_State::STATE_NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for Validation_State {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Validation_Reason {
    REASOT_NONE = 0,
    REASON_AS = 1,
    REASON_LENGTH = 2,
}

impl ::protobuf::ProtobufEnum for Validation_Reason {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Validation_Reason> {
        match value {
            0 => ::std::option::Option::Some(Validation_Reason::REASOT_NONE),
            1 => ::std::option::Option::Some(Validation_Reason::REASON_AS),
            2 => ::std::option::Option::Some(Validation_Reason::REASON_LENGTH),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Validation_Reason] = &[
            Validation_Reason::REASOT_NONE,
            Validation_Reason::REASON_AS,
            Validation_Reason::REASON_LENGTH,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Validation_Reason", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Validation_Reason {
}

impl ::std::default::Default for Validation_Reason {
    fn default() -> Self {
        Validation_Reason::REASOT_NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for Validation_Reason {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Path {
    // message fields
    pub nlri: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    pub pattrs: ::protobuf::RepeatedField<::protobuf::well_known_types::Any>,
    pub age: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub best: bool,
    pub is_withdraw: bool,
    pub validation: ::protobuf::SingularPtrField<Validation>,
    pub no_implicit_withdraw: bool,
    pub family: ::protobuf::SingularPtrField<Family>,
    pub source_asn: u32,
    pub source_id: ::std::string::String,
    pub filtered: bool,
    pub stale: bool,
    pub is_from_external: bool,
    pub neighbor_ip: ::std::string::String,
    pub uuid: ::std::vec::Vec<u8>,
    pub is_nexthop_invalid: bool,
    pub identifier: u32,
    pub local_identifier: u32,
    pub nlri_binary: ::std::vec::Vec<u8>,
    pub pattrs_binary: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Path {
    fn default() -> &'a Path {
        <Path as ::protobuf::Message>::default_instance()
    }
}

impl Path {
    pub fn new() -> Path {
        ::std::default::Default::default()
    }

    // .google.protobuf.Any nlri = 1;


    pub fn get_nlri(&self) -> &::protobuf::well_known_types::Any {
        self.nlri.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Any::default_instance())
    }
    pub fn clear_nlri(&mut self) {
        self.nlri.clear();
    }

    pub fn has_nlri(&self) -> bool {
        self.nlri.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nlri(&mut self, v: ::protobuf::well_known_types::Any) {
        self.nlri = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nlri(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.nlri.is_none() {
            self.nlri.set_default();
        }
        self.nlri.as_mut().unwrap()
    }

    // Take field
    pub fn take_nlri(&mut self) -> ::protobuf::well_known_types::Any {
        self.nlri.take().unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }

    // repeated .google.protobuf.Any pattrs = 2;


    pub fn get_pattrs(&self) -> &[::protobuf::well_known_types::Any] {
        &self.pattrs
    }
    pub fn clear_pattrs(&mut self) {
        self.pattrs.clear();
    }

    // Param is passed by value, moved
    pub fn set_pattrs(&mut self, v: ::protobuf::RepeatedField<::protobuf::well_known_types::Any>) {
        self.pattrs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pattrs(&mut self) -> &mut ::protobuf::RepeatedField<::protobuf::well_known_types::Any> {
        &mut self.pattrs
    }

    // Take field
    pub fn take_pattrs(&mut self) -> ::protobuf::RepeatedField<::protobuf::well_known_types::Any> {
        ::std::mem::replace(&mut self.pattrs, ::protobuf::RepeatedField::new())
    }

    // .google.protobuf.Timestamp age = 3;


    pub fn get_age(&self) -> &::protobuf::well_known_types::Timestamp {
        self.age.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
    pub fn clear_age(&mut self) {
        self.age.clear();
    }

    pub fn has_age(&self) -> bool {
        self.age.is_some()
    }

    // Param is passed by value, moved
    pub fn set_age(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.age = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_age(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.age.is_none() {
            self.age.set_default();
        }
        self.age.as_mut().unwrap()
    }

    // Take field
    pub fn take_age(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.age.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // bool best = 4;


    pub fn get_best(&self) -> bool {
        self.best
    }
    pub fn clear_best(&mut self) {
        self.best = false;
    }

    // Param is passed by value, moved
    pub fn set_best(&mut self, v: bool) {
        self.best = v;
    }

    // bool is_withdraw = 5;


    pub fn get_is_withdraw(&self) -> bool {
        self.is_withdraw
    }
    pub fn clear_is_withdraw(&mut self) {
        self.is_withdraw = false;
    }

    // Param is passed by value, moved
    pub fn set_is_withdraw(&mut self, v: bool) {
        self.is_withdraw = v;
    }

    // .gobgpapi.Validation validation = 7;


    pub fn get_validation(&self) -> &Validation {
        self.validation.as_ref().unwrap_or_else(|| Validation::default_instance())
    }
    pub fn clear_validation(&mut self) {
        self.validation.clear();
    }

    pub fn has_validation(&self) -> bool {
        self.validation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_validation(&mut self, v: Validation) {
        self.validation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_validation(&mut self) -> &mut Validation {
        if self.validation.is_none() {
            self.validation.set_default();
        }
        self.validation.as_mut().unwrap()
    }

    // Take field
    pub fn take_validation(&mut self) -> Validation {
        self.validation.take().unwrap_or_else(|| Validation::new())
    }

    // bool no_implicit_withdraw = 8;


    pub fn get_no_implicit_withdraw(&self) -> bool {
        self.no_implicit_withdraw
    }
    pub fn clear_no_implicit_withdraw(&mut self) {
        self.no_implicit_withdraw = false;
    }

    // Param is passed by value, moved
    pub fn set_no_implicit_withdraw(&mut self, v: bool) {
        self.no_implicit_withdraw = v;
    }

    // .gobgpapi.Family family = 9;


    pub fn get_family(&self) -> &Family {
        self.family.as_ref().unwrap_or_else(|| Family::default_instance())
    }
    pub fn clear_family(&mut self) {
        self.family.clear();
    }

    pub fn has_family(&self) -> bool {
        self.family.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family(&mut self, v: Family) {
        self.family = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_family(&mut self) -> &mut Family {
        if self.family.is_none() {
            self.family.set_default();
        }
        self.family.as_mut().unwrap()
    }

    // Take field
    pub fn take_family(&mut self) -> Family {
        self.family.take().unwrap_or_else(|| Family::new())
    }

    // uint32 source_asn = 10;


    pub fn get_source_asn(&self) -> u32 {
        self.source_asn
    }
    pub fn clear_source_asn(&mut self) {
        self.source_asn = 0;
    }

    // Param is passed by value, moved
    pub fn set_source_asn(&mut self, v: u32) {
        self.source_asn = v;
    }

    // string source_id = 11;


    pub fn get_source_id(&self) -> &str {
        &self.source_id
    }
    pub fn clear_source_id(&mut self) {
        self.source_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_source_id(&mut self, v: ::std::string::String) {
        self.source_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source_id(&mut self) -> &mut ::std::string::String {
        &mut self.source_id
    }

    // Take field
    pub fn take_source_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.source_id, ::std::string::String::new())
    }

    // bool filtered = 12;


    pub fn get_filtered(&self) -> bool {
        self.filtered
    }
    pub fn clear_filtered(&mut self) {
        self.filtered = false;
    }

    // Param is passed by value, moved
    pub fn set_filtered(&mut self, v: bool) {
        self.filtered = v;
    }

    // bool stale = 13;


    pub fn get_stale(&self) -> bool {
        self.stale
    }
    pub fn clear_stale(&mut self) {
        self.stale = false;
    }

    // Param is passed by value, moved
    pub fn set_stale(&mut self, v: bool) {
        self.stale = v;
    }

    // bool is_from_external = 14;


    pub fn get_is_from_external(&self) -> bool {
        self.is_from_external
    }
    pub fn clear_is_from_external(&mut self) {
        self.is_from_external = false;
    }

    // Param is passed by value, moved
    pub fn set_is_from_external(&mut self, v: bool) {
        self.is_from_external = v;
    }

    // string neighbor_ip = 15;


    pub fn get_neighbor_ip(&self) -> &str {
        &self.neighbor_ip
    }
    pub fn clear_neighbor_ip(&mut self) {
        self.neighbor_ip.clear();
    }

    // Param is passed by value, moved
    pub fn set_neighbor_ip(&mut self, v: ::std::string::String) {
        self.neighbor_ip = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_neighbor_ip(&mut self) -> &mut ::std::string::String {
        &mut self.neighbor_ip
    }

    // Take field
    pub fn take_neighbor_ip(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.neighbor_ip, ::std::string::String::new())
    }

    // bytes uuid = 16;


    pub fn get_uuid(&self) -> &[u8] {
        &self.uuid
    }
    pub fn clear_uuid(&mut self) {
        self.uuid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uuid(&mut self, v: ::std::vec::Vec<u8>) {
        self.uuid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uuid(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.uuid
    }

    // Take field
    pub fn take_uuid(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.uuid, ::std::vec::Vec::new())
    }

    // bool is_nexthop_invalid = 17;


    pub fn get_is_nexthop_invalid(&self) -> bool {
        self.is_nexthop_invalid
    }
    pub fn clear_is_nexthop_invalid(&mut self) {
        self.is_nexthop_invalid = false;
    }

    // Param is passed by value, moved
    pub fn set_is_nexthop_invalid(&mut self, v: bool) {
        self.is_nexthop_invalid = v;
    }

    // uint32 identifier = 18;


    pub fn get_identifier(&self) -> u32 {
        self.identifier
    }
    pub fn clear_identifier(&mut self) {
        self.identifier = 0;
    }

    // Param is passed by value, moved
    pub fn set_identifier(&mut self, v: u32) {
        self.identifier = v;
    }

    // uint32 local_identifier = 19;


    pub fn get_local_identifier(&self) -> u32 {
        self.local_identifier
    }
    pub fn clear_local_identifier(&mut self) {
        self.local_identifier = 0;
    }

    // Param is passed by value, moved
    pub fn set_local_identifier(&mut self, v: u32) {
        self.local_identifier = v;
    }

    // bytes nlri_binary = 20;


    pub fn get_nlri_binary(&self) -> &[u8] {
        &self.nlri_binary
    }
    pub fn clear_nlri_binary(&mut self) {
        self.nlri_binary.clear();
    }

    // Param is passed by value, moved
    pub fn set_nlri_binary(&mut self, v: ::std::vec::Vec<u8>) {
        self.nlri_binary = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nlri_binary(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.nlri_binary
    }

    // Take field
    pub fn take_nlri_binary(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.nlri_binary, ::std::vec::Vec::new())
    }

    // repeated bytes pattrs_binary = 21;


    pub fn get_pattrs_binary(&self) -> &[::std::vec::Vec<u8>] {
        &self.pattrs_binary
    }
    pub fn clear_pattrs_binary(&mut self) {
        self.pattrs_binary.clear();
    }

    // Param is passed by value, moved
    pub fn set_pattrs_binary(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.pattrs_binary = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pattrs_binary(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.pattrs_binary
    }

    // Take field
    pub fn take_pattrs_binary(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.pattrs_binary, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Path {
    fn is_initialized(&self) -> bool {
        for v in &self.nlri {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pattrs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.age {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.validation {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.family {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.nlri)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pattrs)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.age)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.best = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_withdraw = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.validation)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.no_implicit_withdraw = tmp;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.family)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.source_asn = tmp;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.source_id)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.filtered = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.stale = tmp;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_from_external = tmp;
                },
                15 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.neighbor_ip)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.uuid)?;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_nexthop_invalid = tmp;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.identifier = tmp;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.local_identifier = tmp;
                },
                20 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.nlri_binary)?;
                },
                21 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.pattrs_binary)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.nlri.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.pattrs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.age.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.best != false {
            my_size += 2;
        }
        if self.is_withdraw != false {
            my_size += 2;
        }
        if let Some(ref v) = self.validation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.no_implicit_withdraw != false {
            my_size += 2;
        }
        if let Some(ref v) = self.family.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.source_asn != 0 {
            my_size += ::protobuf::rt::value_size(10, self.source_asn, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.source_id.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.source_id);
        }
        if self.filtered != false {
            my_size += 2;
        }
        if self.stale != false {
            my_size += 2;
        }
        if self.is_from_external != false {
            my_size += 2;
        }
        if !self.neighbor_ip.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.neighbor_ip);
        }
        if !self.uuid.is_empty() {
            my_size += ::protobuf::rt::bytes_size(16, &self.uuid);
        }
        if self.is_nexthop_invalid != false {
            my_size += 3;
        }
        if self.identifier != 0 {
            my_size += ::protobuf::rt::value_size(18, self.identifier, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.local_identifier != 0 {
            my_size += ::protobuf::rt::value_size(19, self.local_identifier, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.nlri_binary.is_empty() {
            my_size += ::protobuf::rt::bytes_size(20, &self.nlri_binary);
        }
        for value in &self.pattrs_binary {
            my_size += ::protobuf::rt::bytes_size(21, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.nlri.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.pattrs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.age.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.best != false {
            os.write_bool(4, self.best)?;
        }
        if self.is_withdraw != false {
            os.write_bool(5, self.is_withdraw)?;
        }
        if let Some(ref v) = self.validation.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.no_implicit_withdraw != false {
            os.write_bool(8, self.no_implicit_withdraw)?;
        }
        if let Some(ref v) = self.family.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.source_asn != 0 {
            os.write_uint32(10, self.source_asn)?;
        }
        if !self.source_id.is_empty() {
            os.write_string(11, &self.source_id)?;
        }
        if self.filtered != false {
            os.write_bool(12, self.filtered)?;
        }
        if self.stale != false {
            os.write_bool(13, self.stale)?;
        }
        if self.is_from_external != false {
            os.write_bool(14, self.is_from_external)?;
        }
        if !self.neighbor_ip.is_empty() {
            os.write_string(15, &self.neighbor_ip)?;
        }
        if !self.uuid.is_empty() {
            os.write_bytes(16, &self.uuid)?;
        }
        if self.is_nexthop_invalid != false {
            os.write_bool(17, self.is_nexthop_invalid)?;
        }
        if self.identifier != 0 {
            os.write_uint32(18, self.identifier)?;
        }
        if self.local_identifier != 0 {
            os.write_uint32(19, self.local_identifier)?;
        }
        if !self.nlri_binary.is_empty() {
            os.write_bytes(20, &self.nlri_binary)?;
        }
        for v in &self.pattrs_binary {
            os.write_bytes(21, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Path {
        Path::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                    "nlri",
                    |m: &Path| { &m.nlri },
                    |m: &mut Path| { &mut m.nlri },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                    "pattrs",
                    |m: &Path| { &m.pattrs },
                    |m: &mut Path| { &mut m.pattrs },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "age",
                    |m: &Path| { &m.age },
                    |m: &mut Path| { &mut m.age },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "best",
                    |m: &Path| { &m.best },
                    |m: &mut Path| { &mut m.best },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_withdraw",
                    |m: &Path| { &m.is_withdraw },
                    |m: &mut Path| { &mut m.is_withdraw },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Validation>>(
                    "validation",
                    |m: &Path| { &m.validation },
                    |m: &mut Path| { &mut m.validation },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "no_implicit_withdraw",
                    |m: &Path| { &m.no_implicit_withdraw },
                    |m: &mut Path| { &mut m.no_implicit_withdraw },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Family>>(
                    "family",
                    |m: &Path| { &m.family },
                    |m: &mut Path| { &mut m.family },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "source_asn",
                    |m: &Path| { &m.source_asn },
                    |m: &mut Path| { &mut m.source_asn },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "source_id",
                    |m: &Path| { &m.source_id },
                    |m: &mut Path| { &mut m.source_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "filtered",
                    |m: &Path| { &m.filtered },
                    |m: &mut Path| { &mut m.filtered },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "stale",
                    |m: &Path| { &m.stale },
                    |m: &mut Path| { &mut m.stale },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_from_external",
                    |m: &Path| { &m.is_from_external },
                    |m: &mut Path| { &mut m.is_from_external },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "neighbor_ip",
                    |m: &Path| { &m.neighbor_ip },
                    |m: &mut Path| { &mut m.neighbor_ip },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "uuid",
                    |m: &Path| { &m.uuid },
                    |m: &mut Path| { &mut m.uuid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_nexthop_invalid",
                    |m: &Path| { &m.is_nexthop_invalid },
                    |m: &mut Path| { &mut m.is_nexthop_invalid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "identifier",
                    |m: &Path| { &m.identifier },
                    |m: &mut Path| { &mut m.identifier },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "local_identifier",
                    |m: &Path| { &m.local_identifier },
                    |m: &mut Path| { &mut m.local_identifier },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "nlri_binary",
                    |m: &Path| { &m.nlri_binary },
                    |m: &mut Path| { &mut m.nlri_binary },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "pattrs_binary",
                    |m: &Path| { &m.pattrs_binary },
                    |m: &mut Path| { &mut m.pattrs_binary },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Path>(
                    "Path",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Path {
        static mut instance: ::protobuf::lazy::Lazy<Path> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Path,
        };
        unsafe {
            instance.get(Path::new)
        }
    }
}

impl ::protobuf::Clear for Path {
    fn clear(&mut self) {
        self.nlri.clear();
        self.pattrs.clear();
        self.age.clear();
        self.best = false;
        self.is_withdraw = false;
        self.validation.clear();
        self.no_implicit_withdraw = false;
        self.family.clear();
        self.source_asn = 0;
        self.source_id.clear();
        self.filtered = false;
        self.stale = false;
        self.is_from_external = false;
        self.neighbor_ip.clear();
        self.uuid.clear();
        self.is_nexthop_invalid = false;
        self.identifier = 0;
        self.local_identifier = 0;
        self.nlri_binary.clear();
        self.pattrs_binary.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Path {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Path {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Destination {
    // message fields
    pub prefix: ::std::string::String,
    pub paths: ::protobuf::RepeatedField<Path>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Destination {
    fn default() -> &'a Destination {
        <Destination as ::protobuf::Message>::default_instance()
    }
}

impl Destination {
    pub fn new() -> Destination {
        ::std::default::Default::default()
    }

    // string prefix = 1;


    pub fn get_prefix(&self) -> &str {
        &self.prefix
    }
    pub fn clear_prefix(&mut self) {
        self.prefix.clear();
    }

    // Param is passed by value, moved
    pub fn set_prefix(&mut self, v: ::std::string::String) {
        self.prefix = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prefix(&mut self) -> &mut ::std::string::String {
        &mut self.prefix
    }

    // Take field
    pub fn take_prefix(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.prefix, ::std::string::String::new())
    }

    // repeated .gobgpapi.Path paths = 2;


    pub fn get_paths(&self) -> &[Path] {
        &self.paths
    }
    pub fn clear_paths(&mut self) {
        self.paths.clear();
    }

    // Param is passed by value, moved
    pub fn set_paths(&mut self, v: ::protobuf::RepeatedField<Path>) {
        self.paths = v;
    }

    // Mutable pointer to the field.
    pub fn mut_paths(&mut self) -> &mut ::protobuf::RepeatedField<Path> {
        &mut self.paths
    }

    // Take field
    pub fn take_paths(&mut self) -> ::protobuf::RepeatedField<Path> {
        ::std::mem::replace(&mut self.paths, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Destination {
    fn is_initialized(&self) -> bool {
        for v in &self.paths {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.prefix)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.paths)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.prefix.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.prefix);
        }
        for value in &self.paths {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.prefix.is_empty() {
            os.write_string(1, &self.prefix)?;
        }
        for v in &self.paths {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Destination {
        Destination::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "prefix",
                    |m: &Destination| { &m.prefix },
                    |m: &mut Destination| { &mut m.prefix },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Path>>(
                    "paths",
                    |m: &Destination| { &m.paths },
                    |m: &mut Destination| { &mut m.paths },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Destination>(
                    "Destination",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Destination {
        static mut instance: ::protobuf::lazy::Lazy<Destination> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Destination,
        };
        unsafe {
            instance.get(Destination::new)
        }
    }
}

impl ::protobuf::Clear for Destination {
    fn clear(&mut self) {
        self.prefix.clear();
        self.paths.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Destination {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Destination {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TableLookupPrefix {
    // message fields
    pub prefix: ::std::string::String,
    pub lookup_option: TableLookupOption,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TableLookupPrefix {
    fn default() -> &'a TableLookupPrefix {
        <TableLookupPrefix as ::protobuf::Message>::default_instance()
    }
}

impl TableLookupPrefix {
    pub fn new() -> TableLookupPrefix {
        ::std::default::Default::default()
    }

    // string prefix = 1;


    pub fn get_prefix(&self) -> &str {
        &self.prefix
    }
    pub fn clear_prefix(&mut self) {
        self.prefix.clear();
    }

    // Param is passed by value, moved
    pub fn set_prefix(&mut self, v: ::std::string::String) {
        self.prefix = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prefix(&mut self) -> &mut ::std::string::String {
        &mut self.prefix
    }

    // Take field
    pub fn take_prefix(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.prefix, ::std::string::String::new())
    }

    // .gobgpapi.TableLookupOption lookup_option = 2;


    pub fn get_lookup_option(&self) -> TableLookupOption {
        self.lookup_option
    }
    pub fn clear_lookup_option(&mut self) {
        self.lookup_option = TableLookupOption::LOOKUP_EXACT;
    }

    // Param is passed by value, moved
    pub fn set_lookup_option(&mut self, v: TableLookupOption) {
        self.lookup_option = v;
    }
}

impl ::protobuf::Message for TableLookupPrefix {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.prefix)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.lookup_option, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.prefix.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.prefix);
        }
        if self.lookup_option != TableLookupOption::LOOKUP_EXACT {
            my_size += ::protobuf::rt::enum_size(2, self.lookup_option);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.prefix.is_empty() {
            os.write_string(1, &self.prefix)?;
        }
        if self.lookup_option != TableLookupOption::LOOKUP_EXACT {
            os.write_enum(2, self.lookup_option.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TableLookupPrefix {
        TableLookupPrefix::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "prefix",
                    |m: &TableLookupPrefix| { &m.prefix },
                    |m: &mut TableLookupPrefix| { &mut m.prefix },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TableLookupOption>>(
                    "lookup_option",
                    |m: &TableLookupPrefix| { &m.lookup_option },
                    |m: &mut TableLookupPrefix| { &mut m.lookup_option },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TableLookupPrefix>(
                    "TableLookupPrefix",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TableLookupPrefix {
        static mut instance: ::protobuf::lazy::Lazy<TableLookupPrefix> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TableLookupPrefix,
        };
        unsafe {
            instance.get(TableLookupPrefix::new)
        }
    }
}

impl ::protobuf::Clear for TableLookupPrefix {
    fn clear(&mut self) {
        self.prefix.clear();
        self.lookup_option = TableLookupOption::LOOKUP_EXACT;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TableLookupPrefix {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TableLookupPrefix {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Peer {
    // message fields
    pub apply_policy: ::protobuf::SingularPtrField<ApplyPolicy>,
    pub conf: ::protobuf::SingularPtrField<PeerConf>,
    pub ebgp_multihop: ::protobuf::SingularPtrField<EbgpMultihop>,
    pub route_reflector: ::protobuf::SingularPtrField<RouteReflector>,
    pub state: ::protobuf::SingularPtrField<PeerState>,
    pub timers: ::protobuf::SingularPtrField<Timers>,
    pub transport: ::protobuf::SingularPtrField<Transport>,
    pub route_server: ::protobuf::SingularPtrField<RouteServer>,
    pub graceful_restart: ::protobuf::SingularPtrField<GracefulRestart>,
    pub afi_safis: ::protobuf::RepeatedField<AfiSafi>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Peer {
    fn default() -> &'a Peer {
        <Peer as ::protobuf::Message>::default_instance()
    }
}

impl Peer {
    pub fn new() -> Peer {
        ::std::default::Default::default()
    }

    // .gobgpapi.ApplyPolicy apply_policy = 1;


    pub fn get_apply_policy(&self) -> &ApplyPolicy {
        self.apply_policy.as_ref().unwrap_or_else(|| ApplyPolicy::default_instance())
    }
    pub fn clear_apply_policy(&mut self) {
        self.apply_policy.clear();
    }

    pub fn has_apply_policy(&self) -> bool {
        self.apply_policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apply_policy(&mut self, v: ApplyPolicy) {
        self.apply_policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_apply_policy(&mut self) -> &mut ApplyPolicy {
        if self.apply_policy.is_none() {
            self.apply_policy.set_default();
        }
        self.apply_policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_apply_policy(&mut self) -> ApplyPolicy {
        self.apply_policy.take().unwrap_or_else(|| ApplyPolicy::new())
    }

    // .gobgpapi.PeerConf conf = 2;


    pub fn get_conf(&self) -> &PeerConf {
        self.conf.as_ref().unwrap_or_else(|| PeerConf::default_instance())
    }
    pub fn clear_conf(&mut self) {
        self.conf.clear();
    }

    pub fn has_conf(&self) -> bool {
        self.conf.is_some()
    }

    // Param is passed by value, moved
    pub fn set_conf(&mut self, v: PeerConf) {
        self.conf = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_conf(&mut self) -> &mut PeerConf {
        if self.conf.is_none() {
            self.conf.set_default();
        }
        self.conf.as_mut().unwrap()
    }

    // Take field
    pub fn take_conf(&mut self) -> PeerConf {
        self.conf.take().unwrap_or_else(|| PeerConf::new())
    }

    // .gobgpapi.EbgpMultihop ebgp_multihop = 3;


    pub fn get_ebgp_multihop(&self) -> &EbgpMultihop {
        self.ebgp_multihop.as_ref().unwrap_or_else(|| EbgpMultihop::default_instance())
    }
    pub fn clear_ebgp_multihop(&mut self) {
        self.ebgp_multihop.clear();
    }

    pub fn has_ebgp_multihop(&self) -> bool {
        self.ebgp_multihop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ebgp_multihop(&mut self, v: EbgpMultihop) {
        self.ebgp_multihop = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ebgp_multihop(&mut self) -> &mut EbgpMultihop {
        if self.ebgp_multihop.is_none() {
            self.ebgp_multihop.set_default();
        }
        self.ebgp_multihop.as_mut().unwrap()
    }

    // Take field
    pub fn take_ebgp_multihop(&mut self) -> EbgpMultihop {
        self.ebgp_multihop.take().unwrap_or_else(|| EbgpMultihop::new())
    }

    // .gobgpapi.RouteReflector route_reflector = 4;


    pub fn get_route_reflector(&self) -> &RouteReflector {
        self.route_reflector.as_ref().unwrap_or_else(|| RouteReflector::default_instance())
    }
    pub fn clear_route_reflector(&mut self) {
        self.route_reflector.clear();
    }

    pub fn has_route_reflector(&self) -> bool {
        self.route_reflector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_route_reflector(&mut self, v: RouteReflector) {
        self.route_reflector = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_route_reflector(&mut self) -> &mut RouteReflector {
        if self.route_reflector.is_none() {
            self.route_reflector.set_default();
        }
        self.route_reflector.as_mut().unwrap()
    }

    // Take field
    pub fn take_route_reflector(&mut self) -> RouteReflector {
        self.route_reflector.take().unwrap_or_else(|| RouteReflector::new())
    }

    // .gobgpapi.PeerState state = 5;


    pub fn get_state(&self) -> &PeerState {
        self.state.as_ref().unwrap_or_else(|| PeerState::default_instance())
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: PeerState) {
        self.state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut PeerState {
        if self.state.is_none() {
            self.state.set_default();
        }
        self.state.as_mut().unwrap()
    }

    // Take field
    pub fn take_state(&mut self) -> PeerState {
        self.state.take().unwrap_or_else(|| PeerState::new())
    }

    // .gobgpapi.Timers timers = 6;


    pub fn get_timers(&self) -> &Timers {
        self.timers.as_ref().unwrap_or_else(|| Timers::default_instance())
    }
    pub fn clear_timers(&mut self) {
        self.timers.clear();
    }

    pub fn has_timers(&self) -> bool {
        self.timers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timers(&mut self, v: Timers) {
        self.timers = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_timers(&mut self) -> &mut Timers {
        if self.timers.is_none() {
            self.timers.set_default();
        }
        self.timers.as_mut().unwrap()
    }

    // Take field
    pub fn take_timers(&mut self) -> Timers {
        self.timers.take().unwrap_or_else(|| Timers::new())
    }

    // .gobgpapi.Transport transport = 7;


    pub fn get_transport(&self) -> &Transport {
        self.transport.as_ref().unwrap_or_else(|| Transport::default_instance())
    }
    pub fn clear_transport(&mut self) {
        self.transport.clear();
    }

    pub fn has_transport(&self) -> bool {
        self.transport.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transport(&mut self, v: Transport) {
        self.transport = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transport(&mut self) -> &mut Transport {
        if self.transport.is_none() {
            self.transport.set_default();
        }
        self.transport.as_mut().unwrap()
    }

    // Take field
    pub fn take_transport(&mut self) -> Transport {
        self.transport.take().unwrap_or_else(|| Transport::new())
    }

    // .gobgpapi.RouteServer route_server = 8;


    pub fn get_route_server(&self) -> &RouteServer {
        self.route_server.as_ref().unwrap_or_else(|| RouteServer::default_instance())
    }
    pub fn clear_route_server(&mut self) {
        self.route_server.clear();
    }

    pub fn has_route_server(&self) -> bool {
        self.route_server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_route_server(&mut self, v: RouteServer) {
        self.route_server = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_route_server(&mut self) -> &mut RouteServer {
        if self.route_server.is_none() {
            self.route_server.set_default();
        }
        self.route_server.as_mut().unwrap()
    }

    // Take field
    pub fn take_route_server(&mut self) -> RouteServer {
        self.route_server.take().unwrap_or_else(|| RouteServer::new())
    }

    // .gobgpapi.GracefulRestart graceful_restart = 9;


    pub fn get_graceful_restart(&self) -> &GracefulRestart {
        self.graceful_restart.as_ref().unwrap_or_else(|| GracefulRestart::default_instance())
    }
    pub fn clear_graceful_restart(&mut self) {
        self.graceful_restart.clear();
    }

    pub fn has_graceful_restart(&self) -> bool {
        self.graceful_restart.is_some()
    }

    // Param is passed by value, moved
    pub fn set_graceful_restart(&mut self, v: GracefulRestart) {
        self.graceful_restart = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_graceful_restart(&mut self) -> &mut GracefulRestart {
        if self.graceful_restart.is_none() {
            self.graceful_restart.set_default();
        }
        self.graceful_restart.as_mut().unwrap()
    }

    // Take field
    pub fn take_graceful_restart(&mut self) -> GracefulRestart {
        self.graceful_restart.take().unwrap_or_else(|| GracefulRestart::new())
    }

    // repeated .gobgpapi.AfiSafi afi_safis = 10;


    pub fn get_afi_safis(&self) -> &[AfiSafi] {
        &self.afi_safis
    }
    pub fn clear_afi_safis(&mut self) {
        self.afi_safis.clear();
    }

    // Param is passed by value, moved
    pub fn set_afi_safis(&mut self, v: ::protobuf::RepeatedField<AfiSafi>) {
        self.afi_safis = v;
    }

    // Mutable pointer to the field.
    pub fn mut_afi_safis(&mut self) -> &mut ::protobuf::RepeatedField<AfiSafi> {
        &mut self.afi_safis
    }

    // Take field
    pub fn take_afi_safis(&mut self) -> ::protobuf::RepeatedField<AfiSafi> {
        ::std::mem::replace(&mut self.afi_safis, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Peer {
    fn is_initialized(&self) -> bool {
        for v in &self.apply_policy {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.conf {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ebgp_multihop {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.route_reflector {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.state {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.timers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transport {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.route_server {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.graceful_restart {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.afi_safis {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.apply_policy)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.conf)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ebgp_multihop)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.route_reflector)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.state)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.timers)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.transport)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.route_server)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.graceful_restart)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.afi_safis)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.apply_policy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.conf.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ebgp_multihop.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.route_reflector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.timers.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.transport.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.route_server.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.graceful_restart.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.afi_safis {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.apply_policy.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.conf.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ebgp_multihop.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.route_reflector.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.state.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.timers.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.transport.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.route_server.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.graceful_restart.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.afi_safis {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Peer {
        Peer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ApplyPolicy>>(
                    "apply_policy",
                    |m: &Peer| { &m.apply_policy },
                    |m: &mut Peer| { &mut m.apply_policy },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PeerConf>>(
                    "conf",
                    |m: &Peer| { &m.conf },
                    |m: &mut Peer| { &mut m.conf },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EbgpMultihop>>(
                    "ebgp_multihop",
                    |m: &Peer| { &m.ebgp_multihop },
                    |m: &mut Peer| { &mut m.ebgp_multihop },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RouteReflector>>(
                    "route_reflector",
                    |m: &Peer| { &m.route_reflector },
                    |m: &mut Peer| { &mut m.route_reflector },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PeerState>>(
                    "state",
                    |m: &Peer| { &m.state },
                    |m: &mut Peer| { &mut m.state },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Timers>>(
                    "timers",
                    |m: &Peer| { &m.timers },
                    |m: &mut Peer| { &mut m.timers },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Transport>>(
                    "transport",
                    |m: &Peer| { &m.transport },
                    |m: &mut Peer| { &mut m.transport },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RouteServer>>(
                    "route_server",
                    |m: &Peer| { &m.route_server },
                    |m: &mut Peer| { &mut m.route_server },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GracefulRestart>>(
                    "graceful_restart",
                    |m: &Peer| { &m.graceful_restart },
                    |m: &mut Peer| { &mut m.graceful_restart },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AfiSafi>>(
                    "afi_safis",
                    |m: &Peer| { &m.afi_safis },
                    |m: &mut Peer| { &mut m.afi_safis },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Peer>(
                    "Peer",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Peer {
        static mut instance: ::protobuf::lazy::Lazy<Peer> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Peer,
        };
        unsafe {
            instance.get(Peer::new)
        }
    }
}

impl ::protobuf::Clear for Peer {
    fn clear(&mut self) {
        self.apply_policy.clear();
        self.conf.clear();
        self.ebgp_multihop.clear();
        self.route_reflector.clear();
        self.state.clear();
        self.timers.clear();
        self.transport.clear();
        self.route_server.clear();
        self.graceful_restart.clear();
        self.afi_safis.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Peer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Peer {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PeerGroup {
    // message fields
    pub apply_policy: ::protobuf::SingularPtrField<ApplyPolicy>,
    pub conf: ::protobuf::SingularPtrField<PeerGroupConf>,
    pub ebgp_multihop: ::protobuf::SingularPtrField<EbgpMultihop>,
    pub route_reflector: ::protobuf::SingularPtrField<RouteReflector>,
    pub info: ::protobuf::SingularPtrField<PeerGroupState>,
    pub timers: ::protobuf::SingularPtrField<Timers>,
    pub transport: ::protobuf::SingularPtrField<Transport>,
    pub route_server: ::protobuf::SingularPtrField<RouteServer>,
    pub graceful_restart: ::protobuf::SingularPtrField<GracefulRestart>,
    pub afi_safis: ::protobuf::RepeatedField<AfiSafi>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PeerGroup {
    fn default() -> &'a PeerGroup {
        <PeerGroup as ::protobuf::Message>::default_instance()
    }
}

impl PeerGroup {
    pub fn new() -> PeerGroup {
        ::std::default::Default::default()
    }

    // .gobgpapi.ApplyPolicy apply_policy = 1;


    pub fn get_apply_policy(&self) -> &ApplyPolicy {
        self.apply_policy.as_ref().unwrap_or_else(|| ApplyPolicy::default_instance())
    }
    pub fn clear_apply_policy(&mut self) {
        self.apply_policy.clear();
    }

    pub fn has_apply_policy(&self) -> bool {
        self.apply_policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apply_policy(&mut self, v: ApplyPolicy) {
        self.apply_policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_apply_policy(&mut self) -> &mut ApplyPolicy {
        if self.apply_policy.is_none() {
            self.apply_policy.set_default();
        }
        self.apply_policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_apply_policy(&mut self) -> ApplyPolicy {
        self.apply_policy.take().unwrap_or_else(|| ApplyPolicy::new())
    }

    // .gobgpapi.PeerGroupConf conf = 2;


    pub fn get_conf(&self) -> &PeerGroupConf {
        self.conf.as_ref().unwrap_or_else(|| PeerGroupConf::default_instance())
    }
    pub fn clear_conf(&mut self) {
        self.conf.clear();
    }

    pub fn has_conf(&self) -> bool {
        self.conf.is_some()
    }

    // Param is passed by value, moved
    pub fn set_conf(&mut self, v: PeerGroupConf) {
        self.conf = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_conf(&mut self) -> &mut PeerGroupConf {
        if self.conf.is_none() {
            self.conf.set_default();
        }
        self.conf.as_mut().unwrap()
    }

    // Take field
    pub fn take_conf(&mut self) -> PeerGroupConf {
        self.conf.take().unwrap_or_else(|| PeerGroupConf::new())
    }

    // .gobgpapi.EbgpMultihop ebgp_multihop = 3;


    pub fn get_ebgp_multihop(&self) -> &EbgpMultihop {
        self.ebgp_multihop.as_ref().unwrap_or_else(|| EbgpMultihop::default_instance())
    }
    pub fn clear_ebgp_multihop(&mut self) {
        self.ebgp_multihop.clear();
    }

    pub fn has_ebgp_multihop(&self) -> bool {
        self.ebgp_multihop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ebgp_multihop(&mut self, v: EbgpMultihop) {
        self.ebgp_multihop = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ebgp_multihop(&mut self) -> &mut EbgpMultihop {
        if self.ebgp_multihop.is_none() {
            self.ebgp_multihop.set_default();
        }
        self.ebgp_multihop.as_mut().unwrap()
    }

    // Take field
    pub fn take_ebgp_multihop(&mut self) -> EbgpMultihop {
        self.ebgp_multihop.take().unwrap_or_else(|| EbgpMultihop::new())
    }

    // .gobgpapi.RouteReflector route_reflector = 4;


    pub fn get_route_reflector(&self) -> &RouteReflector {
        self.route_reflector.as_ref().unwrap_or_else(|| RouteReflector::default_instance())
    }
    pub fn clear_route_reflector(&mut self) {
        self.route_reflector.clear();
    }

    pub fn has_route_reflector(&self) -> bool {
        self.route_reflector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_route_reflector(&mut self, v: RouteReflector) {
        self.route_reflector = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_route_reflector(&mut self) -> &mut RouteReflector {
        if self.route_reflector.is_none() {
            self.route_reflector.set_default();
        }
        self.route_reflector.as_mut().unwrap()
    }

    // Take field
    pub fn take_route_reflector(&mut self) -> RouteReflector {
        self.route_reflector.take().unwrap_or_else(|| RouteReflector::new())
    }

    // .gobgpapi.PeerGroupState info = 5;


    pub fn get_info(&self) -> &PeerGroupState {
        self.info.as_ref().unwrap_or_else(|| PeerGroupState::default_instance())
    }
    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: PeerGroupState) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut PeerGroupState {
        if self.info.is_none() {
            self.info.set_default();
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> PeerGroupState {
        self.info.take().unwrap_or_else(|| PeerGroupState::new())
    }

    // .gobgpapi.Timers timers = 6;


    pub fn get_timers(&self) -> &Timers {
        self.timers.as_ref().unwrap_or_else(|| Timers::default_instance())
    }
    pub fn clear_timers(&mut self) {
        self.timers.clear();
    }

    pub fn has_timers(&self) -> bool {
        self.timers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timers(&mut self, v: Timers) {
        self.timers = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_timers(&mut self) -> &mut Timers {
        if self.timers.is_none() {
            self.timers.set_default();
        }
        self.timers.as_mut().unwrap()
    }

    // Take field
    pub fn take_timers(&mut self) -> Timers {
        self.timers.take().unwrap_or_else(|| Timers::new())
    }

    // .gobgpapi.Transport transport = 7;


    pub fn get_transport(&self) -> &Transport {
        self.transport.as_ref().unwrap_or_else(|| Transport::default_instance())
    }
    pub fn clear_transport(&mut self) {
        self.transport.clear();
    }

    pub fn has_transport(&self) -> bool {
        self.transport.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transport(&mut self, v: Transport) {
        self.transport = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transport(&mut self) -> &mut Transport {
        if self.transport.is_none() {
            self.transport.set_default();
        }
        self.transport.as_mut().unwrap()
    }

    // Take field
    pub fn take_transport(&mut self) -> Transport {
        self.transport.take().unwrap_or_else(|| Transport::new())
    }

    // .gobgpapi.RouteServer route_server = 8;


    pub fn get_route_server(&self) -> &RouteServer {
        self.route_server.as_ref().unwrap_or_else(|| RouteServer::default_instance())
    }
    pub fn clear_route_server(&mut self) {
        self.route_server.clear();
    }

    pub fn has_route_server(&self) -> bool {
        self.route_server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_route_server(&mut self, v: RouteServer) {
        self.route_server = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_route_server(&mut self) -> &mut RouteServer {
        if self.route_server.is_none() {
            self.route_server.set_default();
        }
        self.route_server.as_mut().unwrap()
    }

    // Take field
    pub fn take_route_server(&mut self) -> RouteServer {
        self.route_server.take().unwrap_or_else(|| RouteServer::new())
    }

    // .gobgpapi.GracefulRestart graceful_restart = 9;


    pub fn get_graceful_restart(&self) -> &GracefulRestart {
        self.graceful_restart.as_ref().unwrap_or_else(|| GracefulRestart::default_instance())
    }
    pub fn clear_graceful_restart(&mut self) {
        self.graceful_restart.clear();
    }

    pub fn has_graceful_restart(&self) -> bool {
        self.graceful_restart.is_some()
    }

    // Param is passed by value, moved
    pub fn set_graceful_restart(&mut self, v: GracefulRestart) {
        self.graceful_restart = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_graceful_restart(&mut self) -> &mut GracefulRestart {
        if self.graceful_restart.is_none() {
            self.graceful_restart.set_default();
        }
        self.graceful_restart.as_mut().unwrap()
    }

    // Take field
    pub fn take_graceful_restart(&mut self) -> GracefulRestart {
        self.graceful_restart.take().unwrap_or_else(|| GracefulRestart::new())
    }

    // repeated .gobgpapi.AfiSafi afi_safis = 10;


    pub fn get_afi_safis(&self) -> &[AfiSafi] {
        &self.afi_safis
    }
    pub fn clear_afi_safis(&mut self) {
        self.afi_safis.clear();
    }

    // Param is passed by value, moved
    pub fn set_afi_safis(&mut self, v: ::protobuf::RepeatedField<AfiSafi>) {
        self.afi_safis = v;
    }

    // Mutable pointer to the field.
    pub fn mut_afi_safis(&mut self) -> &mut ::protobuf::RepeatedField<AfiSafi> {
        &mut self.afi_safis
    }

    // Take field
    pub fn take_afi_safis(&mut self) -> ::protobuf::RepeatedField<AfiSafi> {
        ::std::mem::replace(&mut self.afi_safis, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PeerGroup {
    fn is_initialized(&self) -> bool {
        for v in &self.apply_policy {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.conf {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ebgp_multihop {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.route_reflector {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.timers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transport {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.route_server {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.graceful_restart {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.afi_safis {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.apply_policy)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.conf)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ebgp_multihop)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.route_reflector)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.info)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.timers)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.transport)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.route_server)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.graceful_restart)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.afi_safis)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.apply_policy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.conf.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ebgp_multihop.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.route_reflector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.timers.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.transport.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.route_server.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.graceful_restart.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.afi_safis {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.apply_policy.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.conf.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ebgp_multihop.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.route_reflector.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.info.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.timers.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.transport.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.route_server.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.graceful_restart.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.afi_safis {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PeerGroup {
        PeerGroup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ApplyPolicy>>(
                    "apply_policy",
                    |m: &PeerGroup| { &m.apply_policy },
                    |m: &mut PeerGroup| { &mut m.apply_policy },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PeerGroupConf>>(
                    "conf",
                    |m: &PeerGroup| { &m.conf },
                    |m: &mut PeerGroup| { &mut m.conf },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EbgpMultihop>>(
                    "ebgp_multihop",
                    |m: &PeerGroup| { &m.ebgp_multihop },
                    |m: &mut PeerGroup| { &mut m.ebgp_multihop },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RouteReflector>>(
                    "route_reflector",
                    |m: &PeerGroup| { &m.route_reflector },
                    |m: &mut PeerGroup| { &mut m.route_reflector },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PeerGroupState>>(
                    "info",
                    |m: &PeerGroup| { &m.info },
                    |m: &mut PeerGroup| { &mut m.info },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Timers>>(
                    "timers",
                    |m: &PeerGroup| { &m.timers },
                    |m: &mut PeerGroup| { &mut m.timers },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Transport>>(
                    "transport",
                    |m: &PeerGroup| { &m.transport },
                    |m: &mut PeerGroup| { &mut m.transport },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RouteServer>>(
                    "route_server",
                    |m: &PeerGroup| { &m.route_server },
                    |m: &mut PeerGroup| { &mut m.route_server },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GracefulRestart>>(
                    "graceful_restart",
                    |m: &PeerGroup| { &m.graceful_restart },
                    |m: &mut PeerGroup| { &mut m.graceful_restart },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AfiSafi>>(
                    "afi_safis",
                    |m: &PeerGroup| { &m.afi_safis },
                    |m: &mut PeerGroup| { &mut m.afi_safis },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PeerGroup>(
                    "PeerGroup",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PeerGroup {
        static mut instance: ::protobuf::lazy::Lazy<PeerGroup> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PeerGroup,
        };
        unsafe {
            instance.get(PeerGroup::new)
        }
    }
}

impl ::protobuf::Clear for PeerGroup {
    fn clear(&mut self) {
        self.apply_policy.clear();
        self.conf.clear();
        self.ebgp_multihop.clear();
        self.route_reflector.clear();
        self.info.clear();
        self.timers.clear();
        self.transport.clear();
        self.route_server.clear();
        self.graceful_restart.clear();
        self.afi_safis.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PeerGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PeerGroup {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DynamicNeighbor {
    // message fields
    pub prefix: ::std::string::String,
    pub peer_group: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DynamicNeighbor {
    fn default() -> &'a DynamicNeighbor {
        <DynamicNeighbor as ::protobuf::Message>::default_instance()
    }
}

impl DynamicNeighbor {
    pub fn new() -> DynamicNeighbor {
        ::std::default::Default::default()
    }

    // string prefix = 1;


    pub fn get_prefix(&self) -> &str {
        &self.prefix
    }
    pub fn clear_prefix(&mut self) {
        self.prefix.clear();
    }

    // Param is passed by value, moved
    pub fn set_prefix(&mut self, v: ::std::string::String) {
        self.prefix = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prefix(&mut self) -> &mut ::std::string::String {
        &mut self.prefix
    }

    // Take field
    pub fn take_prefix(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.prefix, ::std::string::String::new())
    }

    // string peer_group = 2;


    pub fn get_peer_group(&self) -> &str {
        &self.peer_group
    }
    pub fn clear_peer_group(&mut self) {
        self.peer_group.clear();
    }

    // Param is passed by value, moved
    pub fn set_peer_group(&mut self, v: ::std::string::String) {
        self.peer_group = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_peer_group(&mut self) -> &mut ::std::string::String {
        &mut self.peer_group
    }

    // Take field
    pub fn take_peer_group(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.peer_group, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DynamicNeighbor {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.prefix)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.peer_group)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.prefix.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.prefix);
        }
        if !self.peer_group.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.peer_group);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.prefix.is_empty() {
            os.write_string(1, &self.prefix)?;
        }
        if !self.peer_group.is_empty() {
            os.write_string(2, &self.peer_group)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DynamicNeighbor {
        DynamicNeighbor::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "prefix",
                    |m: &DynamicNeighbor| { &m.prefix },
                    |m: &mut DynamicNeighbor| { &mut m.prefix },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "peer_group",
                    |m: &DynamicNeighbor| { &m.peer_group },
                    |m: &mut DynamicNeighbor| { &mut m.peer_group },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DynamicNeighbor>(
                    "DynamicNeighbor",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DynamicNeighbor {
        static mut instance: ::protobuf::lazy::Lazy<DynamicNeighbor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DynamicNeighbor,
        };
        unsafe {
            instance.get(DynamicNeighbor::new)
        }
    }
}

impl ::protobuf::Clear for DynamicNeighbor {
    fn clear(&mut self) {
        self.prefix.clear();
        self.peer_group.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DynamicNeighbor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DynamicNeighbor {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ApplyPolicy {
    // message fields
    pub in_policy: ::protobuf::SingularPtrField<PolicyAssignment>,
    pub export_policy: ::protobuf::SingularPtrField<PolicyAssignment>,
    pub import_policy: ::protobuf::SingularPtrField<PolicyAssignment>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ApplyPolicy {
    fn default() -> &'a ApplyPolicy {
        <ApplyPolicy as ::protobuf::Message>::default_instance()
    }
}

impl ApplyPolicy {
    pub fn new() -> ApplyPolicy {
        ::std::default::Default::default()
    }

    // .gobgpapi.PolicyAssignment in_policy = 1;


    pub fn get_in_policy(&self) -> &PolicyAssignment {
        self.in_policy.as_ref().unwrap_or_else(|| PolicyAssignment::default_instance())
    }
    pub fn clear_in_policy(&mut self) {
        self.in_policy.clear();
    }

    pub fn has_in_policy(&self) -> bool {
        self.in_policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_policy(&mut self, v: PolicyAssignment) {
        self.in_policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_in_policy(&mut self) -> &mut PolicyAssignment {
        if self.in_policy.is_none() {
            self.in_policy.set_default();
        }
        self.in_policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_in_policy(&mut self) -> PolicyAssignment {
        self.in_policy.take().unwrap_or_else(|| PolicyAssignment::new())
    }

    // .gobgpapi.PolicyAssignment export_policy = 2;


    pub fn get_export_policy(&self) -> &PolicyAssignment {
        self.export_policy.as_ref().unwrap_or_else(|| PolicyAssignment::default_instance())
    }
    pub fn clear_export_policy(&mut self) {
        self.export_policy.clear();
    }

    pub fn has_export_policy(&self) -> bool {
        self.export_policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_export_policy(&mut self, v: PolicyAssignment) {
        self.export_policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_export_policy(&mut self) -> &mut PolicyAssignment {
        if self.export_policy.is_none() {
            self.export_policy.set_default();
        }
        self.export_policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_export_policy(&mut self) -> PolicyAssignment {
        self.export_policy.take().unwrap_or_else(|| PolicyAssignment::new())
    }

    // .gobgpapi.PolicyAssignment import_policy = 3;


    pub fn get_import_policy(&self) -> &PolicyAssignment {
        self.import_policy.as_ref().unwrap_or_else(|| PolicyAssignment::default_instance())
    }
    pub fn clear_import_policy(&mut self) {
        self.import_policy.clear();
    }

    pub fn has_import_policy(&self) -> bool {
        self.import_policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_import_policy(&mut self, v: PolicyAssignment) {
        self.import_policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_import_policy(&mut self) -> &mut PolicyAssignment {
        if self.import_policy.is_none() {
            self.import_policy.set_default();
        }
        self.import_policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_import_policy(&mut self) -> PolicyAssignment {
        self.import_policy.take().unwrap_or_else(|| PolicyAssignment::new())
    }
}

impl ::protobuf::Message for ApplyPolicy {
    fn is_initialized(&self) -> bool {
        for v in &self.in_policy {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.export_policy {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.import_policy {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.in_policy)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.export_policy)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.import_policy)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.in_policy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.export_policy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.import_policy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.in_policy.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.export_policy.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.import_policy.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ApplyPolicy {
        ApplyPolicy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PolicyAssignment>>(
                    "in_policy",
                    |m: &ApplyPolicy| { &m.in_policy },
                    |m: &mut ApplyPolicy| { &mut m.in_policy },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PolicyAssignment>>(
                    "export_policy",
                    |m: &ApplyPolicy| { &m.export_policy },
                    |m: &mut ApplyPolicy| { &mut m.export_policy },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PolicyAssignment>>(
                    "import_policy",
                    |m: &ApplyPolicy| { &m.import_policy },
                    |m: &mut ApplyPolicy| { &mut m.import_policy },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ApplyPolicy>(
                    "ApplyPolicy",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ApplyPolicy {
        static mut instance: ::protobuf::lazy::Lazy<ApplyPolicy> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ApplyPolicy,
        };
        unsafe {
            instance.get(ApplyPolicy::new)
        }
    }
}

impl ::protobuf::Clear for ApplyPolicy {
    fn clear(&mut self) {
        self.in_policy.clear();
        self.export_policy.clear();
        self.import_policy.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ApplyPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ApplyPolicy {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PrefixLimit {
    // message fields
    pub family: ::protobuf::SingularPtrField<Family>,
    pub max_prefixes: u32,
    pub shutdown_threshold_pct: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PrefixLimit {
    fn default() -> &'a PrefixLimit {
        <PrefixLimit as ::protobuf::Message>::default_instance()
    }
}

impl PrefixLimit {
    pub fn new() -> PrefixLimit {
        ::std::default::Default::default()
    }

    // .gobgpapi.Family family = 1;


    pub fn get_family(&self) -> &Family {
        self.family.as_ref().unwrap_or_else(|| Family::default_instance())
    }
    pub fn clear_family(&mut self) {
        self.family.clear();
    }

    pub fn has_family(&self) -> bool {
        self.family.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family(&mut self, v: Family) {
        self.family = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_family(&mut self) -> &mut Family {
        if self.family.is_none() {
            self.family.set_default();
        }
        self.family.as_mut().unwrap()
    }

    // Take field
    pub fn take_family(&mut self) -> Family {
        self.family.take().unwrap_or_else(|| Family::new())
    }

    // uint32 max_prefixes = 2;


    pub fn get_max_prefixes(&self) -> u32 {
        self.max_prefixes
    }
    pub fn clear_max_prefixes(&mut self) {
        self.max_prefixes = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_prefixes(&mut self, v: u32) {
        self.max_prefixes = v;
    }

    // uint32 shutdown_threshold_pct = 3;


    pub fn get_shutdown_threshold_pct(&self) -> u32 {
        self.shutdown_threshold_pct
    }
    pub fn clear_shutdown_threshold_pct(&mut self) {
        self.shutdown_threshold_pct = 0;
    }

    // Param is passed by value, moved
    pub fn set_shutdown_threshold_pct(&mut self, v: u32) {
        self.shutdown_threshold_pct = v;
    }
}

impl ::protobuf::Message for PrefixLimit {
    fn is_initialized(&self) -> bool {
        for v in &self.family {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.family)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_prefixes = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.shutdown_threshold_pct = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.family.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.max_prefixes != 0 {
            my_size += ::protobuf::rt::value_size(2, self.max_prefixes, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.shutdown_threshold_pct != 0 {
            my_size += ::protobuf::rt::value_size(3, self.shutdown_threshold_pct, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.family.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.max_prefixes != 0 {
            os.write_uint32(2, self.max_prefixes)?;
        }
        if self.shutdown_threshold_pct != 0 {
            os.write_uint32(3, self.shutdown_threshold_pct)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PrefixLimit {
        PrefixLimit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Family>>(
                    "family",
                    |m: &PrefixLimit| { &m.family },
                    |m: &mut PrefixLimit| { &mut m.family },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "max_prefixes",
                    |m: &PrefixLimit| { &m.max_prefixes },
                    |m: &mut PrefixLimit| { &mut m.max_prefixes },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "shutdown_threshold_pct",
                    |m: &PrefixLimit| { &m.shutdown_threshold_pct },
                    |m: &mut PrefixLimit| { &mut m.shutdown_threshold_pct },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PrefixLimit>(
                    "PrefixLimit",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PrefixLimit {
        static mut instance: ::protobuf::lazy::Lazy<PrefixLimit> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PrefixLimit,
        };
        unsafe {
            instance.get(PrefixLimit::new)
        }
    }
}

impl ::protobuf::Clear for PrefixLimit {
    fn clear(&mut self) {
        self.family.clear();
        self.max_prefixes = 0;
        self.shutdown_threshold_pct = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PrefixLimit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PrefixLimit {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PeerConf {
    // message fields
    pub auth_password: ::std::string::String,
    pub description: ::std::string::String,
    pub local_as: u32,
    pub neighbor_address: ::std::string::String,
    pub peer_as: u32,
    pub peer_group: ::std::string::String,
    pub peer_type: u32,
    pub remove_private_as: PeerConf_RemovePrivateAs,
    pub route_flap_damping: bool,
    pub send_community: u32,
    pub neighbor_interface: ::std::string::String,
    pub vrf: ::std::string::String,
    pub allow_own_as: u32,
    pub replace_peer_as: bool,
    pub admin_down: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PeerConf {
    fn default() -> &'a PeerConf {
        <PeerConf as ::protobuf::Message>::default_instance()
    }
}

impl PeerConf {
    pub fn new() -> PeerConf {
        ::std::default::Default::default()
    }

    // string auth_password = 1;


    pub fn get_auth_password(&self) -> &str {
        &self.auth_password
    }
    pub fn clear_auth_password(&mut self) {
        self.auth_password.clear();
    }

    // Param is passed by value, moved
    pub fn set_auth_password(&mut self, v: ::std::string::String) {
        self.auth_password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth_password(&mut self) -> &mut ::std::string::String {
        &mut self.auth_password
    }

    // Take field
    pub fn take_auth_password(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.auth_password, ::std::string::String::new())
    }

    // string description = 2;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // uint32 local_as = 3;


    pub fn get_local_as(&self) -> u32 {
        self.local_as
    }
    pub fn clear_local_as(&mut self) {
        self.local_as = 0;
    }

    // Param is passed by value, moved
    pub fn set_local_as(&mut self, v: u32) {
        self.local_as = v;
    }

    // string neighbor_address = 4;


    pub fn get_neighbor_address(&self) -> &str {
        &self.neighbor_address
    }
    pub fn clear_neighbor_address(&mut self) {
        self.neighbor_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_neighbor_address(&mut self, v: ::std::string::String) {
        self.neighbor_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_neighbor_address(&mut self) -> &mut ::std::string::String {
        &mut self.neighbor_address
    }

    // Take field
    pub fn take_neighbor_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.neighbor_address, ::std::string::String::new())
    }

    // uint32 peer_as = 5;


    pub fn get_peer_as(&self) -> u32 {
        self.peer_as
    }
    pub fn clear_peer_as(&mut self) {
        self.peer_as = 0;
    }

    // Param is passed by value, moved
    pub fn set_peer_as(&mut self, v: u32) {
        self.peer_as = v;
    }

    // string peer_group = 6;


    pub fn get_peer_group(&self) -> &str {
        &self.peer_group
    }
    pub fn clear_peer_group(&mut self) {
        self.peer_group.clear();
    }

    // Param is passed by value, moved
    pub fn set_peer_group(&mut self, v: ::std::string::String) {
        self.peer_group = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_peer_group(&mut self) -> &mut ::std::string::String {
        &mut self.peer_group
    }

    // Take field
    pub fn take_peer_group(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.peer_group, ::std::string::String::new())
    }

    // uint32 peer_type = 7;


    pub fn get_peer_type(&self) -> u32 {
        self.peer_type
    }
    pub fn clear_peer_type(&mut self) {
        self.peer_type = 0;
    }

    // Param is passed by value, moved
    pub fn set_peer_type(&mut self, v: u32) {
        self.peer_type = v;
    }

    // .gobgpapi.PeerConf.RemovePrivateAs remove_private_as = 8;


    pub fn get_remove_private_as(&self) -> PeerConf_RemovePrivateAs {
        self.remove_private_as
    }
    pub fn clear_remove_private_as(&mut self) {
        self.remove_private_as = PeerConf_RemovePrivateAs::NONE;
    }

    // Param is passed by value, moved
    pub fn set_remove_private_as(&mut self, v: PeerConf_RemovePrivateAs) {
        self.remove_private_as = v;
    }

    // bool route_flap_damping = 9;


    pub fn get_route_flap_damping(&self) -> bool {
        self.route_flap_damping
    }
    pub fn clear_route_flap_damping(&mut self) {
        self.route_flap_damping = false;
    }

    // Param is passed by value, moved
    pub fn set_route_flap_damping(&mut self, v: bool) {
        self.route_flap_damping = v;
    }

    // uint32 send_community = 10;


    pub fn get_send_community(&self) -> u32 {
        self.send_community
    }
    pub fn clear_send_community(&mut self) {
        self.send_community = 0;
    }

    // Param is passed by value, moved
    pub fn set_send_community(&mut self, v: u32) {
        self.send_community = v;
    }

    // string neighbor_interface = 11;


    pub fn get_neighbor_interface(&self) -> &str {
        &self.neighbor_interface
    }
    pub fn clear_neighbor_interface(&mut self) {
        self.neighbor_interface.clear();
    }

    // Param is passed by value, moved
    pub fn set_neighbor_interface(&mut self, v: ::std::string::String) {
        self.neighbor_interface = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_neighbor_interface(&mut self) -> &mut ::std::string::String {
        &mut self.neighbor_interface
    }

    // Take field
    pub fn take_neighbor_interface(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.neighbor_interface, ::std::string::String::new())
    }

    // string vrf = 12;


    pub fn get_vrf(&self) -> &str {
        &self.vrf
    }
    pub fn clear_vrf(&mut self) {
        self.vrf.clear();
    }

    // Param is passed by value, moved
    pub fn set_vrf(&mut self, v: ::std::string::String) {
        self.vrf = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vrf(&mut self) -> &mut ::std::string::String {
        &mut self.vrf
    }

    // Take field
    pub fn take_vrf(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.vrf, ::std::string::String::new())
    }

    // uint32 allow_own_as = 13;


    pub fn get_allow_own_as(&self) -> u32 {
        self.allow_own_as
    }
    pub fn clear_allow_own_as(&mut self) {
        self.allow_own_as = 0;
    }

    // Param is passed by value, moved
    pub fn set_allow_own_as(&mut self, v: u32) {
        self.allow_own_as = v;
    }

    // bool replace_peer_as = 14;


    pub fn get_replace_peer_as(&self) -> bool {
        self.replace_peer_as
    }
    pub fn clear_replace_peer_as(&mut self) {
        self.replace_peer_as = false;
    }

    // Param is passed by value, moved
    pub fn set_replace_peer_as(&mut self, v: bool) {
        self.replace_peer_as = v;
    }

    // bool admin_down = 15;


    pub fn get_admin_down(&self) -> bool {
        self.admin_down
    }
    pub fn clear_admin_down(&mut self) {
        self.admin_down = false;
    }

    // Param is passed by value, moved
    pub fn set_admin_down(&mut self, v: bool) {
        self.admin_down = v;
    }
}

impl ::protobuf::Message for PeerConf {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.auth_password)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.local_as = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.neighbor_address)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.peer_as = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.peer_group)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.peer_type = tmp;
                },
                8 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.remove_private_as, 8, &mut self.unknown_fields)?
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.route_flap_damping = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.send_community = tmp;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.neighbor_interface)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.vrf)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.allow_own_as = tmp;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.replace_peer_as = tmp;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.admin_down = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.auth_password.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.auth_password);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        if self.local_as != 0 {
            my_size += ::protobuf::rt::value_size(3, self.local_as, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.neighbor_address.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.neighbor_address);
        }
        if self.peer_as != 0 {
            my_size += ::protobuf::rt::value_size(5, self.peer_as, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.peer_group.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.peer_group);
        }
        if self.peer_type != 0 {
            my_size += ::protobuf::rt::value_size(7, self.peer_type, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.remove_private_as != PeerConf_RemovePrivateAs::NONE {
            my_size += ::protobuf::rt::enum_size(8, self.remove_private_as);
        }
        if self.route_flap_damping != false {
            my_size += 2;
        }
        if self.send_community != 0 {
            my_size += ::protobuf::rt::value_size(10, self.send_community, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.neighbor_interface.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.neighbor_interface);
        }
        if !self.vrf.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.vrf);
        }
        if self.allow_own_as != 0 {
            my_size += ::protobuf::rt::value_size(13, self.allow_own_as, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.replace_peer_as != false {
            my_size += 2;
        }
        if self.admin_down != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.auth_password.is_empty() {
            os.write_string(1, &self.auth_password)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        if self.local_as != 0 {
            os.write_uint32(3, self.local_as)?;
        }
        if !self.neighbor_address.is_empty() {
            os.write_string(4, &self.neighbor_address)?;
        }
        if self.peer_as != 0 {
            os.write_uint32(5, self.peer_as)?;
        }
        if !self.peer_group.is_empty() {
            os.write_string(6, &self.peer_group)?;
        }
        if self.peer_type != 0 {
            os.write_uint32(7, self.peer_type)?;
        }
        if self.remove_private_as != PeerConf_RemovePrivateAs::NONE {
            os.write_enum(8, self.remove_private_as.value())?;
        }
        if self.route_flap_damping != false {
            os.write_bool(9, self.route_flap_damping)?;
        }
        if self.send_community != 0 {
            os.write_uint32(10, self.send_community)?;
        }
        if !self.neighbor_interface.is_empty() {
            os.write_string(11, &self.neighbor_interface)?;
        }
        if !self.vrf.is_empty() {
            os.write_string(12, &self.vrf)?;
        }
        if self.allow_own_as != 0 {
            os.write_uint32(13, self.allow_own_as)?;
        }
        if self.replace_peer_as != false {
            os.write_bool(14, self.replace_peer_as)?;
        }
        if self.admin_down != false {
            os.write_bool(15, self.admin_down)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PeerConf {
        PeerConf::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "auth_password",
                    |m: &PeerConf| { &m.auth_password },
                    |m: &mut PeerConf| { &mut m.auth_password },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "description",
                    |m: &PeerConf| { &m.description },
                    |m: &mut PeerConf| { &mut m.description },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "local_as",
                    |m: &PeerConf| { &m.local_as },
                    |m: &mut PeerConf| { &mut m.local_as },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "neighbor_address",
                    |m: &PeerConf| { &m.neighbor_address },
                    |m: &mut PeerConf| { &mut m.neighbor_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "peer_as",
                    |m: &PeerConf| { &m.peer_as },
                    |m: &mut PeerConf| { &mut m.peer_as },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "peer_group",
                    |m: &PeerConf| { &m.peer_group },
                    |m: &mut PeerConf| { &mut m.peer_group },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "peer_type",
                    |m: &PeerConf| { &m.peer_type },
                    |m: &mut PeerConf| { &mut m.peer_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PeerConf_RemovePrivateAs>>(
                    "remove_private_as",
                    |m: &PeerConf| { &m.remove_private_as },
                    |m: &mut PeerConf| { &mut m.remove_private_as },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "route_flap_damping",
                    |m: &PeerConf| { &m.route_flap_damping },
                    |m: &mut PeerConf| { &mut m.route_flap_damping },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "send_community",
                    |m: &PeerConf| { &m.send_community },
                    |m: &mut PeerConf| { &mut m.send_community },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "neighbor_interface",
                    |m: &PeerConf| { &m.neighbor_interface },
                    |m: &mut PeerConf| { &mut m.neighbor_interface },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "vrf",
                    |m: &PeerConf| { &m.vrf },
                    |m: &mut PeerConf| { &mut m.vrf },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "allow_own_as",
                    |m: &PeerConf| { &m.allow_own_as },
                    |m: &mut PeerConf| { &mut m.allow_own_as },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "replace_peer_as",
                    |m: &PeerConf| { &m.replace_peer_as },
                    |m: &mut PeerConf| { &mut m.replace_peer_as },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "admin_down",
                    |m: &PeerConf| { &m.admin_down },
                    |m: &mut PeerConf| { &mut m.admin_down },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PeerConf>(
                    "PeerConf",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PeerConf {
        static mut instance: ::protobuf::lazy::Lazy<PeerConf> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PeerConf,
        };
        unsafe {
            instance.get(PeerConf::new)
        }
    }
}

impl ::protobuf::Clear for PeerConf {
    fn clear(&mut self) {
        self.auth_password.clear();
        self.description.clear();
        self.local_as = 0;
        self.neighbor_address.clear();
        self.peer_as = 0;
        self.peer_group.clear();
        self.peer_type = 0;
        self.remove_private_as = PeerConf_RemovePrivateAs::NONE;
        self.route_flap_damping = false;
        self.send_community = 0;
        self.neighbor_interface.clear();
        self.vrf.clear();
        self.allow_own_as = 0;
        self.replace_peer_as = false;
        self.admin_down = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PeerConf {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PeerConf {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PeerConf_RemovePrivateAs {
    NONE = 0,
    ALL = 1,
    REPLACE = 2,
}

impl ::protobuf::ProtobufEnum for PeerConf_RemovePrivateAs {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PeerConf_RemovePrivateAs> {
        match value {
            0 => ::std::option::Option::Some(PeerConf_RemovePrivateAs::NONE),
            1 => ::std::option::Option::Some(PeerConf_RemovePrivateAs::ALL),
            2 => ::std::option::Option::Some(PeerConf_RemovePrivateAs::REPLACE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PeerConf_RemovePrivateAs] = &[
            PeerConf_RemovePrivateAs::NONE,
            PeerConf_RemovePrivateAs::ALL,
            PeerConf_RemovePrivateAs::REPLACE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("PeerConf_RemovePrivateAs", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for PeerConf_RemovePrivateAs {
}

impl ::std::default::Default for PeerConf_RemovePrivateAs {
    fn default() -> Self {
        PeerConf_RemovePrivateAs::NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for PeerConf_RemovePrivateAs {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PeerGroupConf {
    // message fields
    pub auth_password: ::std::string::String,
    pub description: ::std::string::String,
    pub local_as: u32,
    pub peer_as: u32,
    pub peer_group_name: ::std::string::String,
    pub peer_type: u32,
    pub remove_private_as: PeerGroupConf_RemovePrivateAs,
    pub route_flap_damping: bool,
    pub send_community: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PeerGroupConf {
    fn default() -> &'a PeerGroupConf {
        <PeerGroupConf as ::protobuf::Message>::default_instance()
    }
}

impl PeerGroupConf {
    pub fn new() -> PeerGroupConf {
        ::std::default::Default::default()
    }

    // string auth_password = 1;


    pub fn get_auth_password(&self) -> &str {
        &self.auth_password
    }
    pub fn clear_auth_password(&mut self) {
        self.auth_password.clear();
    }

    // Param is passed by value, moved
    pub fn set_auth_password(&mut self, v: ::std::string::String) {
        self.auth_password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth_password(&mut self) -> &mut ::std::string::String {
        &mut self.auth_password
    }

    // Take field
    pub fn take_auth_password(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.auth_password, ::std::string::String::new())
    }

    // string description = 2;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // uint32 local_as = 3;


    pub fn get_local_as(&self) -> u32 {
        self.local_as
    }
    pub fn clear_local_as(&mut self) {
        self.local_as = 0;
    }

    // Param is passed by value, moved
    pub fn set_local_as(&mut self, v: u32) {
        self.local_as = v;
    }

    // uint32 peer_as = 4;


    pub fn get_peer_as(&self) -> u32 {
        self.peer_as
    }
    pub fn clear_peer_as(&mut self) {
        self.peer_as = 0;
    }

    // Param is passed by value, moved
    pub fn set_peer_as(&mut self, v: u32) {
        self.peer_as = v;
    }

    // string peer_group_name = 5;


    pub fn get_peer_group_name(&self) -> &str {
        &self.peer_group_name
    }
    pub fn clear_peer_group_name(&mut self) {
        self.peer_group_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_peer_group_name(&mut self, v: ::std::string::String) {
        self.peer_group_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_peer_group_name(&mut self) -> &mut ::std::string::String {
        &mut self.peer_group_name
    }

    // Take field
    pub fn take_peer_group_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.peer_group_name, ::std::string::String::new())
    }

    // uint32 peer_type = 6;


    pub fn get_peer_type(&self) -> u32 {
        self.peer_type
    }
    pub fn clear_peer_type(&mut self) {
        self.peer_type = 0;
    }

    // Param is passed by value, moved
    pub fn set_peer_type(&mut self, v: u32) {
        self.peer_type = v;
    }

    // .gobgpapi.PeerGroupConf.RemovePrivateAs remove_private_as = 7;


    pub fn get_remove_private_as(&self) -> PeerGroupConf_RemovePrivateAs {
        self.remove_private_as
    }
    pub fn clear_remove_private_as(&mut self) {
        self.remove_private_as = PeerGroupConf_RemovePrivateAs::NONE;
    }

    // Param is passed by value, moved
    pub fn set_remove_private_as(&mut self, v: PeerGroupConf_RemovePrivateAs) {
        self.remove_private_as = v;
    }

    // bool route_flap_damping = 8;


    pub fn get_route_flap_damping(&self) -> bool {
        self.route_flap_damping
    }
    pub fn clear_route_flap_damping(&mut self) {
        self.route_flap_damping = false;
    }

    // Param is passed by value, moved
    pub fn set_route_flap_damping(&mut self, v: bool) {
        self.route_flap_damping = v;
    }

    // uint32 send_community = 9;


    pub fn get_send_community(&self) -> u32 {
        self.send_community
    }
    pub fn clear_send_community(&mut self) {
        self.send_community = 0;
    }

    // Param is passed by value, moved
    pub fn set_send_community(&mut self, v: u32) {
        self.send_community = v;
    }
}

impl ::protobuf::Message for PeerGroupConf {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.auth_password)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.local_as = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.peer_as = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.peer_group_name)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.peer_type = tmp;
                },
                7 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.remove_private_as, 7, &mut self.unknown_fields)?
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.route_flap_damping = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.send_community = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.auth_password.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.auth_password);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        if self.local_as != 0 {
            my_size += ::protobuf::rt::value_size(3, self.local_as, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.peer_as != 0 {
            my_size += ::protobuf::rt::value_size(4, self.peer_as, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.peer_group_name.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.peer_group_name);
        }
        if self.peer_type != 0 {
            my_size += ::protobuf::rt::value_size(6, self.peer_type, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.remove_private_as != PeerGroupConf_RemovePrivateAs::NONE {
            my_size += ::protobuf::rt::enum_size(7, self.remove_private_as);
        }
        if self.route_flap_damping != false {
            my_size += 2;
        }
        if self.send_community != 0 {
            my_size += ::protobuf::rt::value_size(9, self.send_community, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.auth_password.is_empty() {
            os.write_string(1, &self.auth_password)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        if self.local_as != 0 {
            os.write_uint32(3, self.local_as)?;
        }
        if self.peer_as != 0 {
            os.write_uint32(4, self.peer_as)?;
        }
        if !self.peer_group_name.is_empty() {
            os.write_string(5, &self.peer_group_name)?;
        }
        if self.peer_type != 0 {
            os.write_uint32(6, self.peer_type)?;
        }
        if self.remove_private_as != PeerGroupConf_RemovePrivateAs::NONE {
            os.write_enum(7, self.remove_private_as.value())?;
        }
        if self.route_flap_damping != false {
            os.write_bool(8, self.route_flap_damping)?;
        }
        if self.send_community != 0 {
            os.write_uint32(9, self.send_community)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PeerGroupConf {
        PeerGroupConf::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "auth_password",
                    |m: &PeerGroupConf| { &m.auth_password },
                    |m: &mut PeerGroupConf| { &mut m.auth_password },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "description",
                    |m: &PeerGroupConf| { &m.description },
                    |m: &mut PeerGroupConf| { &mut m.description },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "local_as",
                    |m: &PeerGroupConf| { &m.local_as },
                    |m: &mut PeerGroupConf| { &mut m.local_as },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "peer_as",
                    |m: &PeerGroupConf| { &m.peer_as },
                    |m: &mut PeerGroupConf| { &mut m.peer_as },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "peer_group_name",
                    |m: &PeerGroupConf| { &m.peer_group_name },
                    |m: &mut PeerGroupConf| { &mut m.peer_group_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "peer_type",
                    |m: &PeerGroupConf| { &m.peer_type },
                    |m: &mut PeerGroupConf| { &mut m.peer_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PeerGroupConf_RemovePrivateAs>>(
                    "remove_private_as",
                    |m: &PeerGroupConf| { &m.remove_private_as },
                    |m: &mut PeerGroupConf| { &mut m.remove_private_as },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "route_flap_damping",
                    |m: &PeerGroupConf| { &m.route_flap_damping },
                    |m: &mut PeerGroupConf| { &mut m.route_flap_damping },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "send_community",
                    |m: &PeerGroupConf| { &m.send_community },
                    |m: &mut PeerGroupConf| { &mut m.send_community },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PeerGroupConf>(
                    "PeerGroupConf",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PeerGroupConf {
        static mut instance: ::protobuf::lazy::Lazy<PeerGroupConf> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PeerGroupConf,
        };
        unsafe {
            instance.get(PeerGroupConf::new)
        }
    }
}

impl ::protobuf::Clear for PeerGroupConf {
    fn clear(&mut self) {
        self.auth_password.clear();
        self.description.clear();
        self.local_as = 0;
        self.peer_as = 0;
        self.peer_group_name.clear();
        self.peer_type = 0;
        self.remove_private_as = PeerGroupConf_RemovePrivateAs::NONE;
        self.route_flap_damping = false;
        self.send_community = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PeerGroupConf {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PeerGroupConf {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PeerGroupConf_RemovePrivateAs {
    NONE = 0,
    ALL = 1,
    REPLACE = 2,
}

impl ::protobuf::ProtobufEnum for PeerGroupConf_RemovePrivateAs {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PeerGroupConf_RemovePrivateAs> {
        match value {
            0 => ::std::option::Option::Some(PeerGroupConf_RemovePrivateAs::NONE),
            1 => ::std::option::Option::Some(PeerGroupConf_RemovePrivateAs::ALL),
            2 => ::std::option::Option::Some(PeerGroupConf_RemovePrivateAs::REPLACE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PeerGroupConf_RemovePrivateAs] = &[
            PeerGroupConf_RemovePrivateAs::NONE,
            PeerGroupConf_RemovePrivateAs::ALL,
            PeerGroupConf_RemovePrivateAs::REPLACE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("PeerGroupConf_RemovePrivateAs", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for PeerGroupConf_RemovePrivateAs {
}

impl ::std::default::Default for PeerGroupConf_RemovePrivateAs {
    fn default() -> Self {
        PeerGroupConf_RemovePrivateAs::NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for PeerGroupConf_RemovePrivateAs {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PeerGroupState {
    // message fields
    pub auth_password: ::std::string::String,
    pub description: ::std::string::String,
    pub local_as: u32,
    pub peer_as: u32,
    pub peer_group_name: ::std::string::String,
    pub peer_type: u32,
    pub remove_private_as: PeerGroupState_RemovePrivateAs,
    pub route_flap_damping: bool,
    pub send_community: u32,
    pub total_paths: u32,
    pub total_prefixes: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PeerGroupState {
    fn default() -> &'a PeerGroupState {
        <PeerGroupState as ::protobuf::Message>::default_instance()
    }
}

impl PeerGroupState {
    pub fn new() -> PeerGroupState {
        ::std::default::Default::default()
    }

    // string auth_password = 1;


    pub fn get_auth_password(&self) -> &str {
        &self.auth_password
    }
    pub fn clear_auth_password(&mut self) {
        self.auth_password.clear();
    }

    // Param is passed by value, moved
    pub fn set_auth_password(&mut self, v: ::std::string::String) {
        self.auth_password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth_password(&mut self) -> &mut ::std::string::String {
        &mut self.auth_password
    }

    // Take field
    pub fn take_auth_password(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.auth_password, ::std::string::String::new())
    }

    // string description = 2;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // uint32 local_as = 3;


    pub fn get_local_as(&self) -> u32 {
        self.local_as
    }
    pub fn clear_local_as(&mut self) {
        self.local_as = 0;
    }

    // Param is passed by value, moved
    pub fn set_local_as(&mut self, v: u32) {
        self.local_as = v;
    }

    // uint32 peer_as = 4;


    pub fn get_peer_as(&self) -> u32 {
        self.peer_as
    }
    pub fn clear_peer_as(&mut self) {
        self.peer_as = 0;
    }

    // Param is passed by value, moved
    pub fn set_peer_as(&mut self, v: u32) {
        self.peer_as = v;
    }

    // string peer_group_name = 5;


    pub fn get_peer_group_name(&self) -> &str {
        &self.peer_group_name
    }
    pub fn clear_peer_group_name(&mut self) {
        self.peer_group_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_peer_group_name(&mut self, v: ::std::string::String) {
        self.peer_group_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_peer_group_name(&mut self) -> &mut ::std::string::String {
        &mut self.peer_group_name
    }

    // Take field
    pub fn take_peer_group_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.peer_group_name, ::std::string::String::new())
    }

    // uint32 peer_type = 6;


    pub fn get_peer_type(&self) -> u32 {
        self.peer_type
    }
    pub fn clear_peer_type(&mut self) {
        self.peer_type = 0;
    }

    // Param is passed by value, moved
    pub fn set_peer_type(&mut self, v: u32) {
        self.peer_type = v;
    }

    // .gobgpapi.PeerGroupState.RemovePrivateAs remove_private_as = 7;


    pub fn get_remove_private_as(&self) -> PeerGroupState_RemovePrivateAs {
        self.remove_private_as
    }
    pub fn clear_remove_private_as(&mut self) {
        self.remove_private_as = PeerGroupState_RemovePrivateAs::NONE;
    }

    // Param is passed by value, moved
    pub fn set_remove_private_as(&mut self, v: PeerGroupState_RemovePrivateAs) {
        self.remove_private_as = v;
    }

    // bool route_flap_damping = 8;


    pub fn get_route_flap_damping(&self) -> bool {
        self.route_flap_damping
    }
    pub fn clear_route_flap_damping(&mut self) {
        self.route_flap_damping = false;
    }

    // Param is passed by value, moved
    pub fn set_route_flap_damping(&mut self, v: bool) {
        self.route_flap_damping = v;
    }

    // uint32 send_community = 9;


    pub fn get_send_community(&self) -> u32 {
        self.send_community
    }
    pub fn clear_send_community(&mut self) {
        self.send_community = 0;
    }

    // Param is passed by value, moved
    pub fn set_send_community(&mut self, v: u32) {
        self.send_community = v;
    }

    // uint32 total_paths = 10;


    pub fn get_total_paths(&self) -> u32 {
        self.total_paths
    }
    pub fn clear_total_paths(&mut self) {
        self.total_paths = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_paths(&mut self, v: u32) {
        self.total_paths = v;
    }

    // uint32 total_prefixes = 11;


    pub fn get_total_prefixes(&self) -> u32 {
        self.total_prefixes
    }
    pub fn clear_total_prefixes(&mut self) {
        self.total_prefixes = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_prefixes(&mut self, v: u32) {
        self.total_prefixes = v;
    }
}

impl ::protobuf::Message for PeerGroupState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.auth_password)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.local_as = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.peer_as = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.peer_group_name)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.peer_type = tmp;
                },
                7 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.remove_private_as, 7, &mut self.unknown_fields)?
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.route_flap_damping = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.send_community = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total_paths = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total_prefixes = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.auth_password.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.auth_password);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        if self.local_as != 0 {
            my_size += ::protobuf::rt::value_size(3, self.local_as, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.peer_as != 0 {
            my_size += ::protobuf::rt::value_size(4, self.peer_as, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.peer_group_name.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.peer_group_name);
        }
        if self.peer_type != 0 {
            my_size += ::protobuf::rt::value_size(6, self.peer_type, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.remove_private_as != PeerGroupState_RemovePrivateAs::NONE {
            my_size += ::protobuf::rt::enum_size(7, self.remove_private_as);
        }
        if self.route_flap_damping != false {
            my_size += 2;
        }
        if self.send_community != 0 {
            my_size += ::protobuf::rt::value_size(9, self.send_community, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total_paths != 0 {
            my_size += ::protobuf::rt::value_size(10, self.total_paths, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total_prefixes != 0 {
            my_size += ::protobuf::rt::value_size(11, self.total_prefixes, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.auth_password.is_empty() {
            os.write_string(1, &self.auth_password)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        if self.local_as != 0 {
            os.write_uint32(3, self.local_as)?;
        }
        if self.peer_as != 0 {
            os.write_uint32(4, self.peer_as)?;
        }
        if !self.peer_group_name.is_empty() {
            os.write_string(5, &self.peer_group_name)?;
        }
        if self.peer_type != 0 {
            os.write_uint32(6, self.peer_type)?;
        }
        if self.remove_private_as != PeerGroupState_RemovePrivateAs::NONE {
            os.write_enum(7, self.remove_private_as.value())?;
        }
        if self.route_flap_damping != false {
            os.write_bool(8, self.route_flap_damping)?;
        }
        if self.send_community != 0 {
            os.write_uint32(9, self.send_community)?;
        }
        if self.total_paths != 0 {
            os.write_uint32(10, self.total_paths)?;
        }
        if self.total_prefixes != 0 {
            os.write_uint32(11, self.total_prefixes)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PeerGroupState {
        PeerGroupState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "auth_password",
                    |m: &PeerGroupState| { &m.auth_password },
                    |m: &mut PeerGroupState| { &mut m.auth_password },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "description",
                    |m: &PeerGroupState| { &m.description },
                    |m: &mut PeerGroupState| { &mut m.description },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "local_as",
                    |m: &PeerGroupState| { &m.local_as },
                    |m: &mut PeerGroupState| { &mut m.local_as },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "peer_as",
                    |m: &PeerGroupState| { &m.peer_as },
                    |m: &mut PeerGroupState| { &mut m.peer_as },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "peer_group_name",
                    |m: &PeerGroupState| { &m.peer_group_name },
                    |m: &mut PeerGroupState| { &mut m.peer_group_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "peer_type",
                    |m: &PeerGroupState| { &m.peer_type },
                    |m: &mut PeerGroupState| { &mut m.peer_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PeerGroupState_RemovePrivateAs>>(
                    "remove_private_as",
                    |m: &PeerGroupState| { &m.remove_private_as },
                    |m: &mut PeerGroupState| { &mut m.remove_private_as },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "route_flap_damping",
                    |m: &PeerGroupState| { &m.route_flap_damping },
                    |m: &mut PeerGroupState| { &mut m.route_flap_damping },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "send_community",
                    |m: &PeerGroupState| { &m.send_community },
                    |m: &mut PeerGroupState| { &mut m.send_community },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "total_paths",
                    |m: &PeerGroupState| { &m.total_paths },
                    |m: &mut PeerGroupState| { &mut m.total_paths },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "total_prefixes",
                    |m: &PeerGroupState| { &m.total_prefixes },
                    |m: &mut PeerGroupState| { &mut m.total_prefixes },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PeerGroupState>(
                    "PeerGroupState",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PeerGroupState {
        static mut instance: ::protobuf::lazy::Lazy<PeerGroupState> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PeerGroupState,
        };
        unsafe {
            instance.get(PeerGroupState::new)
        }
    }
}

impl ::protobuf::Clear for PeerGroupState {
    fn clear(&mut self) {
        self.auth_password.clear();
        self.description.clear();
        self.local_as = 0;
        self.peer_as = 0;
        self.peer_group_name.clear();
        self.peer_type = 0;
        self.remove_private_as = PeerGroupState_RemovePrivateAs::NONE;
        self.route_flap_damping = false;
        self.send_community = 0;
        self.total_paths = 0;
        self.total_prefixes = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PeerGroupState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PeerGroupState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PeerGroupState_RemovePrivateAs {
    NONE = 0,
    ALL = 1,
    REPLACE = 2,
}

impl ::protobuf::ProtobufEnum for PeerGroupState_RemovePrivateAs {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PeerGroupState_RemovePrivateAs> {
        match value {
            0 => ::std::option::Option::Some(PeerGroupState_RemovePrivateAs::NONE),
            1 => ::std::option::Option::Some(PeerGroupState_RemovePrivateAs::ALL),
            2 => ::std::option::Option::Some(PeerGroupState_RemovePrivateAs::REPLACE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PeerGroupState_RemovePrivateAs] = &[
            PeerGroupState_RemovePrivateAs::NONE,
            PeerGroupState_RemovePrivateAs::ALL,
            PeerGroupState_RemovePrivateAs::REPLACE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("PeerGroupState_RemovePrivateAs", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for PeerGroupState_RemovePrivateAs {
}

impl ::std::default::Default for PeerGroupState_RemovePrivateAs {
    fn default() -> Self {
        PeerGroupState_RemovePrivateAs::NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for PeerGroupState_RemovePrivateAs {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EbgpMultihop {
    // message fields
    pub enabled: bool,
    pub multihop_ttl: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EbgpMultihop {
    fn default() -> &'a EbgpMultihop {
        <EbgpMultihop as ::protobuf::Message>::default_instance()
    }
}

impl EbgpMultihop {
    pub fn new() -> EbgpMultihop {
        ::std::default::Default::default()
    }

    // bool enabled = 1;


    pub fn get_enabled(&self) -> bool {
        self.enabled
    }
    pub fn clear_enabled(&mut self) {
        self.enabled = false;
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: bool) {
        self.enabled = v;
    }

    // uint32 multihop_ttl = 2;


    pub fn get_multihop_ttl(&self) -> u32 {
        self.multihop_ttl
    }
    pub fn clear_multihop_ttl(&mut self) {
        self.multihop_ttl = 0;
    }

    // Param is passed by value, moved
    pub fn set_multihop_ttl(&mut self, v: u32) {
        self.multihop_ttl = v;
    }
}

impl ::protobuf::Message for EbgpMultihop {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enabled = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.multihop_ttl = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.enabled != false {
            my_size += 2;
        }
        if self.multihop_ttl != 0 {
            my_size += ::protobuf::rt::value_size(2, self.multihop_ttl, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.enabled != false {
            os.write_bool(1, self.enabled)?;
        }
        if self.multihop_ttl != 0 {
            os.write_uint32(2, self.multihop_ttl)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EbgpMultihop {
        EbgpMultihop::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "enabled",
                    |m: &EbgpMultihop| { &m.enabled },
                    |m: &mut EbgpMultihop| { &mut m.enabled },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "multihop_ttl",
                    |m: &EbgpMultihop| { &m.multihop_ttl },
                    |m: &mut EbgpMultihop| { &mut m.multihop_ttl },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EbgpMultihop>(
                    "EbgpMultihop",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EbgpMultihop {
        static mut instance: ::protobuf::lazy::Lazy<EbgpMultihop> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EbgpMultihop,
        };
        unsafe {
            instance.get(EbgpMultihop::new)
        }
    }
}

impl ::protobuf::Clear for EbgpMultihop {
    fn clear(&mut self) {
        self.enabled = false;
        self.multihop_ttl = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EbgpMultihop {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EbgpMultihop {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RouteReflector {
    // message fields
    pub route_reflector_client: bool,
    pub route_reflector_cluster_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RouteReflector {
    fn default() -> &'a RouteReflector {
        <RouteReflector as ::protobuf::Message>::default_instance()
    }
}

impl RouteReflector {
    pub fn new() -> RouteReflector {
        ::std::default::Default::default()
    }

    // bool route_reflector_client = 1;


    pub fn get_route_reflector_client(&self) -> bool {
        self.route_reflector_client
    }
    pub fn clear_route_reflector_client(&mut self) {
        self.route_reflector_client = false;
    }

    // Param is passed by value, moved
    pub fn set_route_reflector_client(&mut self, v: bool) {
        self.route_reflector_client = v;
    }

    // string route_reflector_cluster_id = 2;


    pub fn get_route_reflector_cluster_id(&self) -> &str {
        &self.route_reflector_cluster_id
    }
    pub fn clear_route_reflector_cluster_id(&mut self) {
        self.route_reflector_cluster_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_route_reflector_cluster_id(&mut self, v: ::std::string::String) {
        self.route_reflector_cluster_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_route_reflector_cluster_id(&mut self) -> &mut ::std::string::String {
        &mut self.route_reflector_cluster_id
    }

    // Take field
    pub fn take_route_reflector_cluster_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.route_reflector_cluster_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RouteReflector {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.route_reflector_client = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.route_reflector_cluster_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.route_reflector_client != false {
            my_size += 2;
        }
        if !self.route_reflector_cluster_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.route_reflector_cluster_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.route_reflector_client != false {
            os.write_bool(1, self.route_reflector_client)?;
        }
        if !self.route_reflector_cluster_id.is_empty() {
            os.write_string(2, &self.route_reflector_cluster_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouteReflector {
        RouteReflector::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "route_reflector_client",
                    |m: &RouteReflector| { &m.route_reflector_client },
                    |m: &mut RouteReflector| { &mut m.route_reflector_client },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "route_reflector_cluster_id",
                    |m: &RouteReflector| { &m.route_reflector_cluster_id },
                    |m: &mut RouteReflector| { &mut m.route_reflector_cluster_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RouteReflector>(
                    "RouteReflector",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RouteReflector {
        static mut instance: ::protobuf::lazy::Lazy<RouteReflector> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RouteReflector,
        };
        unsafe {
            instance.get(RouteReflector::new)
        }
    }
}

impl ::protobuf::Clear for RouteReflector {
    fn clear(&mut self) {
        self.route_reflector_client = false;
        self.route_reflector_cluster_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouteReflector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteReflector {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PeerState {
    // message fields
    pub auth_password: ::std::string::String,
    pub description: ::std::string::String,
    pub local_as: u32,
    pub messages: ::protobuf::SingularPtrField<Messages>,
    pub neighbor_address: ::std::string::String,
    pub peer_as: u32,
    pub peer_group: ::std::string::String,
    pub peer_type: u32,
    pub queues: ::protobuf::SingularPtrField<Queues>,
    pub remove_private_as: u32,
    pub route_flap_damping: bool,
    pub send_community: u32,
    pub session_state: PeerState_SessionState,
    pub admin_state: PeerState_AdminState,
    pub out_q: u32,
    pub flops: u32,
    pub remote_cap: ::protobuf::RepeatedField<::protobuf::well_known_types::Any>,
    pub local_cap: ::protobuf::RepeatedField<::protobuf::well_known_types::Any>,
    pub router_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PeerState {
    fn default() -> &'a PeerState {
        <PeerState as ::protobuf::Message>::default_instance()
    }
}

impl PeerState {
    pub fn new() -> PeerState {
        ::std::default::Default::default()
    }

    // string auth_password = 1;


    pub fn get_auth_password(&self) -> &str {
        &self.auth_password
    }
    pub fn clear_auth_password(&mut self) {
        self.auth_password.clear();
    }

    // Param is passed by value, moved
    pub fn set_auth_password(&mut self, v: ::std::string::String) {
        self.auth_password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth_password(&mut self) -> &mut ::std::string::String {
        &mut self.auth_password
    }

    // Take field
    pub fn take_auth_password(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.auth_password, ::std::string::String::new())
    }

    // string description = 2;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // uint32 local_as = 3;


    pub fn get_local_as(&self) -> u32 {
        self.local_as
    }
    pub fn clear_local_as(&mut self) {
        self.local_as = 0;
    }

    // Param is passed by value, moved
    pub fn set_local_as(&mut self, v: u32) {
        self.local_as = v;
    }

    // .gobgpapi.Messages messages = 4;


    pub fn get_messages(&self) -> &Messages {
        self.messages.as_ref().unwrap_or_else(|| Messages::default_instance())
    }
    pub fn clear_messages(&mut self) {
        self.messages.clear();
    }

    pub fn has_messages(&self) -> bool {
        self.messages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_messages(&mut self, v: Messages) {
        self.messages = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_messages(&mut self) -> &mut Messages {
        if self.messages.is_none() {
            self.messages.set_default();
        }
        self.messages.as_mut().unwrap()
    }

    // Take field
    pub fn take_messages(&mut self) -> Messages {
        self.messages.take().unwrap_or_else(|| Messages::new())
    }

    // string neighbor_address = 5;


    pub fn get_neighbor_address(&self) -> &str {
        &self.neighbor_address
    }
    pub fn clear_neighbor_address(&mut self) {
        self.neighbor_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_neighbor_address(&mut self, v: ::std::string::String) {
        self.neighbor_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_neighbor_address(&mut self) -> &mut ::std::string::String {
        &mut self.neighbor_address
    }

    // Take field
    pub fn take_neighbor_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.neighbor_address, ::std::string::String::new())
    }

    // uint32 peer_as = 6;


    pub fn get_peer_as(&self) -> u32 {
        self.peer_as
    }
    pub fn clear_peer_as(&mut self) {
        self.peer_as = 0;
    }

    // Param is passed by value, moved
    pub fn set_peer_as(&mut self, v: u32) {
        self.peer_as = v;
    }

    // string peer_group = 7;


    pub fn get_peer_group(&self) -> &str {
        &self.peer_group
    }
    pub fn clear_peer_group(&mut self) {
        self.peer_group.clear();
    }

    // Param is passed by value, moved
    pub fn set_peer_group(&mut self, v: ::std::string::String) {
        self.peer_group = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_peer_group(&mut self) -> &mut ::std::string::String {
        &mut self.peer_group
    }

    // Take field
    pub fn take_peer_group(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.peer_group, ::std::string::String::new())
    }

    // uint32 peer_type = 8;


    pub fn get_peer_type(&self) -> u32 {
        self.peer_type
    }
    pub fn clear_peer_type(&mut self) {
        self.peer_type = 0;
    }

    // Param is passed by value, moved
    pub fn set_peer_type(&mut self, v: u32) {
        self.peer_type = v;
    }

    // .gobgpapi.Queues queues = 9;


    pub fn get_queues(&self) -> &Queues {
        self.queues.as_ref().unwrap_or_else(|| Queues::default_instance())
    }
    pub fn clear_queues(&mut self) {
        self.queues.clear();
    }

    pub fn has_queues(&self) -> bool {
        self.queues.is_some()
    }

    // Param is passed by value, moved
    pub fn set_queues(&mut self, v: Queues) {
        self.queues = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_queues(&mut self) -> &mut Queues {
        if self.queues.is_none() {
            self.queues.set_default();
        }
        self.queues.as_mut().unwrap()
    }

    // Take field
    pub fn take_queues(&mut self) -> Queues {
        self.queues.take().unwrap_or_else(|| Queues::new())
    }

    // uint32 remove_private_as = 10;


    pub fn get_remove_private_as(&self) -> u32 {
        self.remove_private_as
    }
    pub fn clear_remove_private_as(&mut self) {
        self.remove_private_as = 0;
    }

    // Param is passed by value, moved
    pub fn set_remove_private_as(&mut self, v: u32) {
        self.remove_private_as = v;
    }

    // bool route_flap_damping = 11;


    pub fn get_route_flap_damping(&self) -> bool {
        self.route_flap_damping
    }
    pub fn clear_route_flap_damping(&mut self) {
        self.route_flap_damping = false;
    }

    // Param is passed by value, moved
    pub fn set_route_flap_damping(&mut self, v: bool) {
        self.route_flap_damping = v;
    }

    // uint32 send_community = 12;


    pub fn get_send_community(&self) -> u32 {
        self.send_community
    }
    pub fn clear_send_community(&mut self) {
        self.send_community = 0;
    }

    // Param is passed by value, moved
    pub fn set_send_community(&mut self, v: u32) {
        self.send_community = v;
    }

    // .gobgpapi.PeerState.SessionState session_state = 13;


    pub fn get_session_state(&self) -> PeerState_SessionState {
        self.session_state
    }
    pub fn clear_session_state(&mut self) {
        self.session_state = PeerState_SessionState::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_session_state(&mut self, v: PeerState_SessionState) {
        self.session_state = v;
    }

    // .gobgpapi.PeerState.AdminState admin_state = 15;


    pub fn get_admin_state(&self) -> PeerState_AdminState {
        self.admin_state
    }
    pub fn clear_admin_state(&mut self) {
        self.admin_state = PeerState_AdminState::UP;
    }

    // Param is passed by value, moved
    pub fn set_admin_state(&mut self, v: PeerState_AdminState) {
        self.admin_state = v;
    }

    // uint32 out_q = 16;


    pub fn get_out_q(&self) -> u32 {
        self.out_q
    }
    pub fn clear_out_q(&mut self) {
        self.out_q = 0;
    }

    // Param is passed by value, moved
    pub fn set_out_q(&mut self, v: u32) {
        self.out_q = v;
    }

    // uint32 flops = 17;


    pub fn get_flops(&self) -> u32 {
        self.flops
    }
    pub fn clear_flops(&mut self) {
        self.flops = 0;
    }

    // Param is passed by value, moved
    pub fn set_flops(&mut self, v: u32) {
        self.flops = v;
    }

    // repeated .google.protobuf.Any remote_cap = 18;


    pub fn get_remote_cap(&self) -> &[::protobuf::well_known_types::Any] {
        &self.remote_cap
    }
    pub fn clear_remote_cap(&mut self) {
        self.remote_cap.clear();
    }

    // Param is passed by value, moved
    pub fn set_remote_cap(&mut self, v: ::protobuf::RepeatedField<::protobuf::well_known_types::Any>) {
        self.remote_cap = v;
    }

    // Mutable pointer to the field.
    pub fn mut_remote_cap(&mut self) -> &mut ::protobuf::RepeatedField<::protobuf::well_known_types::Any> {
        &mut self.remote_cap
    }

    // Take field
    pub fn take_remote_cap(&mut self) -> ::protobuf::RepeatedField<::protobuf::well_known_types::Any> {
        ::std::mem::replace(&mut self.remote_cap, ::protobuf::RepeatedField::new())
    }

    // repeated .google.protobuf.Any local_cap = 19;


    pub fn get_local_cap(&self) -> &[::protobuf::well_known_types::Any] {
        &self.local_cap
    }
    pub fn clear_local_cap(&mut self) {
        self.local_cap.clear();
    }

    // Param is passed by value, moved
    pub fn set_local_cap(&mut self, v: ::protobuf::RepeatedField<::protobuf::well_known_types::Any>) {
        self.local_cap = v;
    }

    // Mutable pointer to the field.
    pub fn mut_local_cap(&mut self) -> &mut ::protobuf::RepeatedField<::protobuf::well_known_types::Any> {
        &mut self.local_cap
    }

    // Take field
    pub fn take_local_cap(&mut self) -> ::protobuf::RepeatedField<::protobuf::well_known_types::Any> {
        ::std::mem::replace(&mut self.local_cap, ::protobuf::RepeatedField::new())
    }

    // string router_id = 20;


    pub fn get_router_id(&self) -> &str {
        &self.router_id
    }
    pub fn clear_router_id(&mut self) {
        self.router_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_router_id(&mut self, v: ::std::string::String) {
        self.router_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_router_id(&mut self) -> &mut ::std::string::String {
        &mut self.router_id
    }

    // Take field
    pub fn take_router_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.router_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PeerState {
    fn is_initialized(&self) -> bool {
        for v in &self.messages {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.queues {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.remote_cap {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.local_cap {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.auth_password)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.local_as = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.messages)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.neighbor_address)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.peer_as = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.peer_group)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.peer_type = tmp;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.queues)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.remove_private_as = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.route_flap_damping = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.send_community = tmp;
                },
                13 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.session_state, 13, &mut self.unknown_fields)?
                },
                15 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.admin_state, 15, &mut self.unknown_fields)?
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.out_q = tmp;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flops = tmp;
                },
                18 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.remote_cap)?;
                },
                19 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.local_cap)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.router_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.auth_password.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.auth_password);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        if self.local_as != 0 {
            my_size += ::protobuf::rt::value_size(3, self.local_as, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.messages.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.neighbor_address.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.neighbor_address);
        }
        if self.peer_as != 0 {
            my_size += ::protobuf::rt::value_size(6, self.peer_as, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.peer_group.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.peer_group);
        }
        if self.peer_type != 0 {
            my_size += ::protobuf::rt::value_size(8, self.peer_type, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.queues.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.remove_private_as != 0 {
            my_size += ::protobuf::rt::value_size(10, self.remove_private_as, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.route_flap_damping != false {
            my_size += 2;
        }
        if self.send_community != 0 {
            my_size += ::protobuf::rt::value_size(12, self.send_community, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.session_state != PeerState_SessionState::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(13, self.session_state);
        }
        if self.admin_state != PeerState_AdminState::UP {
            my_size += ::protobuf::rt::enum_size(15, self.admin_state);
        }
        if self.out_q != 0 {
            my_size += ::protobuf::rt::value_size(16, self.out_q, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.flops != 0 {
            my_size += ::protobuf::rt::value_size(17, self.flops, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.remote_cap {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.local_cap {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.router_id.is_empty() {
            my_size += ::protobuf::rt::string_size(20, &self.router_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.auth_password.is_empty() {
            os.write_string(1, &self.auth_password)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        if self.local_as != 0 {
            os.write_uint32(3, self.local_as)?;
        }
        if let Some(ref v) = self.messages.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.neighbor_address.is_empty() {
            os.write_string(5, &self.neighbor_address)?;
        }
        if self.peer_as != 0 {
            os.write_uint32(6, self.peer_as)?;
        }
        if !self.peer_group.is_empty() {
            os.write_string(7, &self.peer_group)?;
        }
        if self.peer_type != 0 {
            os.write_uint32(8, self.peer_type)?;
        }
        if let Some(ref v) = self.queues.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.remove_private_as != 0 {
            os.write_uint32(10, self.remove_private_as)?;
        }
        if self.route_flap_damping != false {
            os.write_bool(11, self.route_flap_damping)?;
        }
        if self.send_community != 0 {
            os.write_uint32(12, self.send_community)?;
        }
        if self.session_state != PeerState_SessionState::UNKNOWN {
            os.write_enum(13, self.session_state.value())?;
        }
        if self.admin_state != PeerState_AdminState::UP {
            os.write_enum(15, self.admin_state.value())?;
        }
        if self.out_q != 0 {
            os.write_uint32(16, self.out_q)?;
        }
        if self.flops != 0 {
            os.write_uint32(17, self.flops)?;
        }
        for v in &self.remote_cap {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.local_cap {
            os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.router_id.is_empty() {
            os.write_string(20, &self.router_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PeerState {
        PeerState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "auth_password",
                    |m: &PeerState| { &m.auth_password },
                    |m: &mut PeerState| { &mut m.auth_password },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "description",
                    |m: &PeerState| { &m.description },
                    |m: &mut PeerState| { &mut m.description },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "local_as",
                    |m: &PeerState| { &m.local_as },
                    |m: &mut PeerState| { &mut m.local_as },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Messages>>(
                    "messages",
                    |m: &PeerState| { &m.messages },
                    |m: &mut PeerState| { &mut m.messages },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "neighbor_address",
                    |m: &PeerState| { &m.neighbor_address },
                    |m: &mut PeerState| { &mut m.neighbor_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "peer_as",
                    |m: &PeerState| { &m.peer_as },
                    |m: &mut PeerState| { &mut m.peer_as },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "peer_group",
                    |m: &PeerState| { &m.peer_group },
                    |m: &mut PeerState| { &mut m.peer_group },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "peer_type",
                    |m: &PeerState| { &m.peer_type },
                    |m: &mut PeerState| { &mut m.peer_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Queues>>(
                    "queues",
                    |m: &PeerState| { &m.queues },
                    |m: &mut PeerState| { &mut m.queues },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "remove_private_as",
                    |m: &PeerState| { &m.remove_private_as },
                    |m: &mut PeerState| { &mut m.remove_private_as },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "route_flap_damping",
                    |m: &PeerState| { &m.route_flap_damping },
                    |m: &mut PeerState| { &mut m.route_flap_damping },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "send_community",
                    |m: &PeerState| { &m.send_community },
                    |m: &mut PeerState| { &mut m.send_community },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PeerState_SessionState>>(
                    "session_state",
                    |m: &PeerState| { &m.session_state },
                    |m: &mut PeerState| { &mut m.session_state },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PeerState_AdminState>>(
                    "admin_state",
                    |m: &PeerState| { &m.admin_state },
                    |m: &mut PeerState| { &mut m.admin_state },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "out_q",
                    |m: &PeerState| { &m.out_q },
                    |m: &mut PeerState| { &mut m.out_q },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "flops",
                    |m: &PeerState| { &m.flops },
                    |m: &mut PeerState| { &mut m.flops },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                    "remote_cap",
                    |m: &PeerState| { &m.remote_cap },
                    |m: &mut PeerState| { &mut m.remote_cap },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                    "local_cap",
                    |m: &PeerState| { &m.local_cap },
                    |m: &mut PeerState| { &mut m.local_cap },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "router_id",
                    |m: &PeerState| { &m.router_id },
                    |m: &mut PeerState| { &mut m.router_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PeerState>(
                    "PeerState",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PeerState {
        static mut instance: ::protobuf::lazy::Lazy<PeerState> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PeerState,
        };
        unsafe {
            instance.get(PeerState::new)
        }
    }
}

impl ::protobuf::Clear for PeerState {
    fn clear(&mut self) {
        self.auth_password.clear();
        self.description.clear();
        self.local_as = 0;
        self.messages.clear();
        self.neighbor_address.clear();
        self.peer_as = 0;
        self.peer_group.clear();
        self.peer_type = 0;
        self.queues.clear();
        self.remove_private_as = 0;
        self.route_flap_damping = false;
        self.send_community = 0;
        self.session_state = PeerState_SessionState::UNKNOWN;
        self.admin_state = PeerState_AdminState::UP;
        self.out_q = 0;
        self.flops = 0;
        self.remote_cap.clear();
        self.local_cap.clear();
        self.router_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PeerState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PeerState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PeerState_SessionState {
    UNKNOWN = 0,
    IDLE = 1,
    CONNECT = 2,
    ACTIVE = 3,
    OPENSENT = 4,
    OPENCONFIRM = 5,
    ESTABLISHED = 6,
}

impl ::protobuf::ProtobufEnum for PeerState_SessionState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PeerState_SessionState> {
        match value {
            0 => ::std::option::Option::Some(PeerState_SessionState::UNKNOWN),
            1 => ::std::option::Option::Some(PeerState_SessionState::IDLE),
            2 => ::std::option::Option::Some(PeerState_SessionState::CONNECT),
            3 => ::std::option::Option::Some(PeerState_SessionState::ACTIVE),
            4 => ::std::option::Option::Some(PeerState_SessionState::OPENSENT),
            5 => ::std::option::Option::Some(PeerState_SessionState::OPENCONFIRM),
            6 => ::std::option::Option::Some(PeerState_SessionState::ESTABLISHED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PeerState_SessionState] = &[
            PeerState_SessionState::UNKNOWN,
            PeerState_SessionState::IDLE,
            PeerState_SessionState::CONNECT,
            PeerState_SessionState::ACTIVE,
            PeerState_SessionState::OPENSENT,
            PeerState_SessionState::OPENCONFIRM,
            PeerState_SessionState::ESTABLISHED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("PeerState_SessionState", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for PeerState_SessionState {
}

impl ::std::default::Default for PeerState_SessionState {
    fn default() -> Self {
        PeerState_SessionState::UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for PeerState_SessionState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PeerState_AdminState {
    UP = 0,
    DOWN = 1,
    PFX_CT = 2,
}

impl ::protobuf::ProtobufEnum for PeerState_AdminState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PeerState_AdminState> {
        match value {
            0 => ::std::option::Option::Some(PeerState_AdminState::UP),
            1 => ::std::option::Option::Some(PeerState_AdminState::DOWN),
            2 => ::std::option::Option::Some(PeerState_AdminState::PFX_CT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PeerState_AdminState] = &[
            PeerState_AdminState::UP,
            PeerState_AdminState::DOWN,
            PeerState_AdminState::PFX_CT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("PeerState_AdminState", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for PeerState_AdminState {
}

impl ::std::default::Default for PeerState_AdminState {
    fn default() -> Self {
        PeerState_AdminState::UP
    }
}

impl ::protobuf::reflect::ProtobufValue for PeerState_AdminState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Messages {
    // message fields
    pub received: ::protobuf::SingularPtrField<Message>,
    pub sent: ::protobuf::SingularPtrField<Message>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Messages {
    fn default() -> &'a Messages {
        <Messages as ::protobuf::Message>::default_instance()
    }
}

impl Messages {
    pub fn new() -> Messages {
        ::std::default::Default::default()
    }

    // .gobgpapi.Message received = 1;


    pub fn get_received(&self) -> &Message {
        self.received.as_ref().unwrap_or_else(|| Message::default_instance())
    }
    pub fn clear_received(&mut self) {
        self.received.clear();
    }

    pub fn has_received(&self) -> bool {
        self.received.is_some()
    }

    // Param is passed by value, moved
    pub fn set_received(&mut self, v: Message) {
        self.received = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_received(&mut self) -> &mut Message {
        if self.received.is_none() {
            self.received.set_default();
        }
        self.received.as_mut().unwrap()
    }

    // Take field
    pub fn take_received(&mut self) -> Message {
        self.received.take().unwrap_or_else(|| Message::new())
    }

    // .gobgpapi.Message sent = 2;


    pub fn get_sent(&self) -> &Message {
        self.sent.as_ref().unwrap_or_else(|| Message::default_instance())
    }
    pub fn clear_sent(&mut self) {
        self.sent.clear();
    }

    pub fn has_sent(&self) -> bool {
        self.sent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sent(&mut self, v: Message) {
        self.sent = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sent(&mut self) -> &mut Message {
        if self.sent.is_none() {
            self.sent.set_default();
        }
        self.sent.as_mut().unwrap()
    }

    // Take field
    pub fn take_sent(&mut self) -> Message {
        self.sent.take().unwrap_or_else(|| Message::new())
    }
}

impl ::protobuf::Message for Messages {
    fn is_initialized(&self) -> bool {
        for v in &self.received {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sent {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.received)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sent)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.received.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.sent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.received.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.sent.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Messages {
        Messages::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Message>>(
                    "received",
                    |m: &Messages| { &m.received },
                    |m: &mut Messages| { &mut m.received },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Message>>(
                    "sent",
                    |m: &Messages| { &m.sent },
                    |m: &mut Messages| { &mut m.sent },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Messages>(
                    "Messages",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Messages {
        static mut instance: ::protobuf::lazy::Lazy<Messages> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Messages,
        };
        unsafe {
            instance.get(Messages::new)
        }
    }
}

impl ::protobuf::Clear for Messages {
    fn clear(&mut self) {
        self.received.clear();
        self.sent.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Messages {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Messages {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Message {
    // message fields
    pub notification: u64,
    pub update: u64,
    pub open: u64,
    pub keepalive: u64,
    pub refresh: u64,
    pub discarded: u64,
    pub total: u64,
    pub withdraw_update: u64,
    pub withdraw_prefix: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Message {
    fn default() -> &'a Message {
        <Message as ::protobuf::Message>::default_instance()
    }
}

impl Message {
    pub fn new() -> Message {
        ::std::default::Default::default()
    }

    // uint64 notification = 1;


    pub fn get_notification(&self) -> u64 {
        self.notification
    }
    pub fn clear_notification(&mut self) {
        self.notification = 0;
    }

    // Param is passed by value, moved
    pub fn set_notification(&mut self, v: u64) {
        self.notification = v;
    }

    // uint64 update = 2;


    pub fn get_update(&self) -> u64 {
        self.update
    }
    pub fn clear_update(&mut self) {
        self.update = 0;
    }

    // Param is passed by value, moved
    pub fn set_update(&mut self, v: u64) {
        self.update = v;
    }

    // uint64 open = 3;


    pub fn get_open(&self) -> u64 {
        self.open
    }
    pub fn clear_open(&mut self) {
        self.open = 0;
    }

    // Param is passed by value, moved
    pub fn set_open(&mut self, v: u64) {
        self.open = v;
    }

    // uint64 keepalive = 4;


    pub fn get_keepalive(&self) -> u64 {
        self.keepalive
    }
    pub fn clear_keepalive(&mut self) {
        self.keepalive = 0;
    }

    // Param is passed by value, moved
    pub fn set_keepalive(&mut self, v: u64) {
        self.keepalive = v;
    }

    // uint64 refresh = 5;


    pub fn get_refresh(&self) -> u64 {
        self.refresh
    }
    pub fn clear_refresh(&mut self) {
        self.refresh = 0;
    }

    // Param is passed by value, moved
    pub fn set_refresh(&mut self, v: u64) {
        self.refresh = v;
    }

    // uint64 discarded = 6;


    pub fn get_discarded(&self) -> u64 {
        self.discarded
    }
    pub fn clear_discarded(&mut self) {
        self.discarded = 0;
    }

    // Param is passed by value, moved
    pub fn set_discarded(&mut self, v: u64) {
        self.discarded = v;
    }

    // uint64 total = 7;


    pub fn get_total(&self) -> u64 {
        self.total
    }
    pub fn clear_total(&mut self) {
        self.total = 0;
    }

    // Param is passed by value, moved
    pub fn set_total(&mut self, v: u64) {
        self.total = v;
    }

    // uint64 withdraw_update = 8;


    pub fn get_withdraw_update(&self) -> u64 {
        self.withdraw_update
    }
    pub fn clear_withdraw_update(&mut self) {
        self.withdraw_update = 0;
    }

    // Param is passed by value, moved
    pub fn set_withdraw_update(&mut self, v: u64) {
        self.withdraw_update = v;
    }

    // uint64 withdraw_prefix = 9;


    pub fn get_withdraw_prefix(&self) -> u64 {
        self.withdraw_prefix
    }
    pub fn clear_withdraw_prefix(&mut self) {
        self.withdraw_prefix = 0;
    }

    // Param is passed by value, moved
    pub fn set_withdraw_prefix(&mut self, v: u64) {
        self.withdraw_prefix = v;
    }
}

impl ::protobuf::Message for Message {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.notification = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.update = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.open = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.keepalive = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.refresh = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.discarded = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.total = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.withdraw_update = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.withdraw_prefix = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.notification != 0 {
            my_size += ::protobuf::rt::value_size(1, self.notification, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.update != 0 {
            my_size += ::protobuf::rt::value_size(2, self.update, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.open != 0 {
            my_size += ::protobuf::rt::value_size(3, self.open, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.keepalive != 0 {
            my_size += ::protobuf::rt::value_size(4, self.keepalive, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.refresh != 0 {
            my_size += ::protobuf::rt::value_size(5, self.refresh, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.discarded != 0 {
            my_size += ::protobuf::rt::value_size(6, self.discarded, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total != 0 {
            my_size += ::protobuf::rt::value_size(7, self.total, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.withdraw_update != 0 {
            my_size += ::protobuf::rt::value_size(8, self.withdraw_update, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.withdraw_prefix != 0 {
            my_size += ::protobuf::rt::value_size(9, self.withdraw_prefix, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.notification != 0 {
            os.write_uint64(1, self.notification)?;
        }
        if self.update != 0 {
            os.write_uint64(2, self.update)?;
        }
        if self.open != 0 {
            os.write_uint64(3, self.open)?;
        }
        if self.keepalive != 0 {
            os.write_uint64(4, self.keepalive)?;
        }
        if self.refresh != 0 {
            os.write_uint64(5, self.refresh)?;
        }
        if self.discarded != 0 {
            os.write_uint64(6, self.discarded)?;
        }
        if self.total != 0 {
            os.write_uint64(7, self.total)?;
        }
        if self.withdraw_update != 0 {
            os.write_uint64(8, self.withdraw_update)?;
        }
        if self.withdraw_prefix != 0 {
            os.write_uint64(9, self.withdraw_prefix)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Message {
        Message::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "notification",
                    |m: &Message| { &m.notification },
                    |m: &mut Message| { &mut m.notification },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "update",
                    |m: &Message| { &m.update },
                    |m: &mut Message| { &mut m.update },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "open",
                    |m: &Message| { &m.open },
                    |m: &mut Message| { &mut m.open },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "keepalive",
                    |m: &Message| { &m.keepalive },
                    |m: &mut Message| { &mut m.keepalive },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "refresh",
                    |m: &Message| { &m.refresh },
                    |m: &mut Message| { &mut m.refresh },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "discarded",
                    |m: &Message| { &m.discarded },
                    |m: &mut Message| { &mut m.discarded },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "total",
                    |m: &Message| { &m.total },
                    |m: &mut Message| { &mut m.total },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "withdraw_update",
                    |m: &Message| { &m.withdraw_update },
                    |m: &mut Message| { &mut m.withdraw_update },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "withdraw_prefix",
                    |m: &Message| { &m.withdraw_prefix },
                    |m: &mut Message| { &mut m.withdraw_prefix },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Message>(
                    "Message",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Message {
        static mut instance: ::protobuf::lazy::Lazy<Message> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Message,
        };
        unsafe {
            instance.get(Message::new)
        }
    }
}

impl ::protobuf::Clear for Message {
    fn clear(&mut self) {
        self.notification = 0;
        self.update = 0;
        self.open = 0;
        self.keepalive = 0;
        self.refresh = 0;
        self.discarded = 0;
        self.total = 0;
        self.withdraw_update = 0;
        self.withdraw_prefix = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Message {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Message {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Queues {
    // message fields
    pub input: u32,
    pub output: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Queues {
    fn default() -> &'a Queues {
        <Queues as ::protobuf::Message>::default_instance()
    }
}

impl Queues {
    pub fn new() -> Queues {
        ::std::default::Default::default()
    }

    // uint32 input = 1;


    pub fn get_input(&self) -> u32 {
        self.input
    }
    pub fn clear_input(&mut self) {
        self.input = 0;
    }

    // Param is passed by value, moved
    pub fn set_input(&mut self, v: u32) {
        self.input = v;
    }

    // uint32 output = 2;


    pub fn get_output(&self) -> u32 {
        self.output
    }
    pub fn clear_output(&mut self) {
        self.output = 0;
    }

    // Param is passed by value, moved
    pub fn set_output(&mut self, v: u32) {
        self.output = v;
    }
}

impl ::protobuf::Message for Queues {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.input = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.output = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.input != 0 {
            my_size += ::protobuf::rt::value_size(1, self.input, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.output != 0 {
            my_size += ::protobuf::rt::value_size(2, self.output, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.input != 0 {
            os.write_uint32(1, self.input)?;
        }
        if self.output != 0 {
            os.write_uint32(2, self.output)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Queues {
        Queues::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "input",
                    |m: &Queues| { &m.input },
                    |m: &mut Queues| { &mut m.input },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "output",
                    |m: &Queues| { &m.output },
                    |m: &mut Queues| { &mut m.output },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Queues>(
                    "Queues",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Queues {
        static mut instance: ::protobuf::lazy::Lazy<Queues> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Queues,
        };
        unsafe {
            instance.get(Queues::new)
        }
    }
}

impl ::protobuf::Clear for Queues {
    fn clear(&mut self) {
        self.input = 0;
        self.output = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Queues {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Queues {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Timers {
    // message fields
    pub config: ::protobuf::SingularPtrField<TimersConfig>,
    pub state: ::protobuf::SingularPtrField<TimersState>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Timers {
    fn default() -> &'a Timers {
        <Timers as ::protobuf::Message>::default_instance()
    }
}

impl Timers {
    pub fn new() -> Timers {
        ::std::default::Default::default()
    }

    // .gobgpapi.TimersConfig config = 1;


    pub fn get_config(&self) -> &TimersConfig {
        self.config.as_ref().unwrap_or_else(|| TimersConfig::default_instance())
    }
    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    pub fn has_config(&self) -> bool {
        self.config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: TimersConfig) {
        self.config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config(&mut self) -> &mut TimersConfig {
        if self.config.is_none() {
            self.config.set_default();
        }
        self.config.as_mut().unwrap()
    }

    // Take field
    pub fn take_config(&mut self) -> TimersConfig {
        self.config.take().unwrap_or_else(|| TimersConfig::new())
    }

    // .gobgpapi.TimersState state = 2;


    pub fn get_state(&self) -> &TimersState {
        self.state.as_ref().unwrap_or_else(|| TimersState::default_instance())
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: TimersState) {
        self.state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut TimersState {
        if self.state.is_none() {
            self.state.set_default();
        }
        self.state.as_mut().unwrap()
    }

    // Take field
    pub fn take_state(&mut self) -> TimersState {
        self.state.take().unwrap_or_else(|| TimersState::new())
    }
}

impl ::protobuf::Message for Timers {
    fn is_initialized(&self) -> bool {
        for v in &self.config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.state {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.config)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.state)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.config.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.state.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Timers {
        Timers::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TimersConfig>>(
                    "config",
                    |m: &Timers| { &m.config },
                    |m: &mut Timers| { &mut m.config },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TimersState>>(
                    "state",
                    |m: &Timers| { &m.state },
                    |m: &mut Timers| { &mut m.state },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Timers>(
                    "Timers",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Timers {
        static mut instance: ::protobuf::lazy::Lazy<Timers> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Timers,
        };
        unsafe {
            instance.get(Timers::new)
        }
    }
}

impl ::protobuf::Clear for Timers {
    fn clear(&mut self) {
        self.config.clear();
        self.state.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Timers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Timers {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TimersConfig {
    // message fields
    pub connect_retry: u64,
    pub hold_time: u64,
    pub keepalive_interval: u64,
    pub minimum_advertisement_interval: u64,
    pub idle_hold_time_after_reset: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TimersConfig {
    fn default() -> &'a TimersConfig {
        <TimersConfig as ::protobuf::Message>::default_instance()
    }
}

impl TimersConfig {
    pub fn new() -> TimersConfig {
        ::std::default::Default::default()
    }

    // uint64 connect_retry = 1;


    pub fn get_connect_retry(&self) -> u64 {
        self.connect_retry
    }
    pub fn clear_connect_retry(&mut self) {
        self.connect_retry = 0;
    }

    // Param is passed by value, moved
    pub fn set_connect_retry(&mut self, v: u64) {
        self.connect_retry = v;
    }

    // uint64 hold_time = 2;


    pub fn get_hold_time(&self) -> u64 {
        self.hold_time
    }
    pub fn clear_hold_time(&mut self) {
        self.hold_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_hold_time(&mut self, v: u64) {
        self.hold_time = v;
    }

    // uint64 keepalive_interval = 3;


    pub fn get_keepalive_interval(&self) -> u64 {
        self.keepalive_interval
    }
    pub fn clear_keepalive_interval(&mut self) {
        self.keepalive_interval = 0;
    }

    // Param is passed by value, moved
    pub fn set_keepalive_interval(&mut self, v: u64) {
        self.keepalive_interval = v;
    }

    // uint64 minimum_advertisement_interval = 4;


    pub fn get_minimum_advertisement_interval(&self) -> u64 {
        self.minimum_advertisement_interval
    }
    pub fn clear_minimum_advertisement_interval(&mut self) {
        self.minimum_advertisement_interval = 0;
    }

    // Param is passed by value, moved
    pub fn set_minimum_advertisement_interval(&mut self, v: u64) {
        self.minimum_advertisement_interval = v;
    }

    // uint64 idle_hold_time_after_reset = 5;


    pub fn get_idle_hold_time_after_reset(&self) -> u64 {
        self.idle_hold_time_after_reset
    }
    pub fn clear_idle_hold_time_after_reset(&mut self) {
        self.idle_hold_time_after_reset = 0;
    }

    // Param is passed by value, moved
    pub fn set_idle_hold_time_after_reset(&mut self, v: u64) {
        self.idle_hold_time_after_reset = v;
    }
}

impl ::protobuf::Message for TimersConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.connect_retry = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.hold_time = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.keepalive_interval = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.minimum_advertisement_interval = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.idle_hold_time_after_reset = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.connect_retry != 0 {
            my_size += ::protobuf::rt::value_size(1, self.connect_retry, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.hold_time != 0 {
            my_size += ::protobuf::rt::value_size(2, self.hold_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.keepalive_interval != 0 {
            my_size += ::protobuf::rt::value_size(3, self.keepalive_interval, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.minimum_advertisement_interval != 0 {
            my_size += ::protobuf::rt::value_size(4, self.minimum_advertisement_interval, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.idle_hold_time_after_reset != 0 {
            my_size += ::protobuf::rt::value_size(5, self.idle_hold_time_after_reset, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.connect_retry != 0 {
            os.write_uint64(1, self.connect_retry)?;
        }
        if self.hold_time != 0 {
            os.write_uint64(2, self.hold_time)?;
        }
        if self.keepalive_interval != 0 {
            os.write_uint64(3, self.keepalive_interval)?;
        }
        if self.minimum_advertisement_interval != 0 {
            os.write_uint64(4, self.minimum_advertisement_interval)?;
        }
        if self.idle_hold_time_after_reset != 0 {
            os.write_uint64(5, self.idle_hold_time_after_reset)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TimersConfig {
        TimersConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "connect_retry",
                    |m: &TimersConfig| { &m.connect_retry },
                    |m: &mut TimersConfig| { &mut m.connect_retry },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "hold_time",
                    |m: &TimersConfig| { &m.hold_time },
                    |m: &mut TimersConfig| { &mut m.hold_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "keepalive_interval",
                    |m: &TimersConfig| { &m.keepalive_interval },
                    |m: &mut TimersConfig| { &mut m.keepalive_interval },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "minimum_advertisement_interval",
                    |m: &TimersConfig| { &m.minimum_advertisement_interval },
                    |m: &mut TimersConfig| { &mut m.minimum_advertisement_interval },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "idle_hold_time_after_reset",
                    |m: &TimersConfig| { &m.idle_hold_time_after_reset },
                    |m: &mut TimersConfig| { &mut m.idle_hold_time_after_reset },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TimersConfig>(
                    "TimersConfig",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TimersConfig {
        static mut instance: ::protobuf::lazy::Lazy<TimersConfig> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TimersConfig,
        };
        unsafe {
            instance.get(TimersConfig::new)
        }
    }
}

impl ::protobuf::Clear for TimersConfig {
    fn clear(&mut self) {
        self.connect_retry = 0;
        self.hold_time = 0;
        self.keepalive_interval = 0;
        self.minimum_advertisement_interval = 0;
        self.idle_hold_time_after_reset = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TimersConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TimersConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TimersState {
    // message fields
    pub connect_retry: u64,
    pub hold_time: u64,
    pub keepalive_interval: u64,
    pub minimum_advertisement_interval: u64,
    pub negotiated_hold_time: u64,
    pub uptime: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub downtime: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TimersState {
    fn default() -> &'a TimersState {
        <TimersState as ::protobuf::Message>::default_instance()
    }
}

impl TimersState {
    pub fn new() -> TimersState {
        ::std::default::Default::default()
    }

    // uint64 connect_retry = 1;


    pub fn get_connect_retry(&self) -> u64 {
        self.connect_retry
    }
    pub fn clear_connect_retry(&mut self) {
        self.connect_retry = 0;
    }

    // Param is passed by value, moved
    pub fn set_connect_retry(&mut self, v: u64) {
        self.connect_retry = v;
    }

    // uint64 hold_time = 2;


    pub fn get_hold_time(&self) -> u64 {
        self.hold_time
    }
    pub fn clear_hold_time(&mut self) {
        self.hold_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_hold_time(&mut self, v: u64) {
        self.hold_time = v;
    }

    // uint64 keepalive_interval = 3;


    pub fn get_keepalive_interval(&self) -> u64 {
        self.keepalive_interval
    }
    pub fn clear_keepalive_interval(&mut self) {
        self.keepalive_interval = 0;
    }

    // Param is passed by value, moved
    pub fn set_keepalive_interval(&mut self, v: u64) {
        self.keepalive_interval = v;
    }

    // uint64 minimum_advertisement_interval = 4;


    pub fn get_minimum_advertisement_interval(&self) -> u64 {
        self.minimum_advertisement_interval
    }
    pub fn clear_minimum_advertisement_interval(&mut self) {
        self.minimum_advertisement_interval = 0;
    }

    // Param is passed by value, moved
    pub fn set_minimum_advertisement_interval(&mut self, v: u64) {
        self.minimum_advertisement_interval = v;
    }

    // uint64 negotiated_hold_time = 5;


    pub fn get_negotiated_hold_time(&self) -> u64 {
        self.negotiated_hold_time
    }
    pub fn clear_negotiated_hold_time(&mut self) {
        self.negotiated_hold_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_negotiated_hold_time(&mut self, v: u64) {
        self.negotiated_hold_time = v;
    }

    // .google.protobuf.Timestamp uptime = 6;


    pub fn get_uptime(&self) -> &::protobuf::well_known_types::Timestamp {
        self.uptime.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
    pub fn clear_uptime(&mut self) {
        self.uptime.clear();
    }

    pub fn has_uptime(&self) -> bool {
        self.uptime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uptime(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.uptime = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uptime(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.uptime.is_none() {
            self.uptime.set_default();
        }
        self.uptime.as_mut().unwrap()
    }

    // Take field
    pub fn take_uptime(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.uptime.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp downtime = 7;


    pub fn get_downtime(&self) -> &::protobuf::well_known_types::Timestamp {
        self.downtime.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
    pub fn clear_downtime(&mut self) {
        self.downtime.clear();
    }

    pub fn has_downtime(&self) -> bool {
        self.downtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_downtime(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.downtime = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_downtime(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.downtime.is_none() {
            self.downtime.set_default();
        }
        self.downtime.as_mut().unwrap()
    }

    // Take field
    pub fn take_downtime(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.downtime.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for TimersState {
    fn is_initialized(&self) -> bool {
        for v in &self.uptime {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.downtime {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.connect_retry = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.hold_time = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.keepalive_interval = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.minimum_advertisement_interval = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.negotiated_hold_time = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.uptime)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.downtime)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.connect_retry != 0 {
            my_size += ::protobuf::rt::value_size(1, self.connect_retry, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.hold_time != 0 {
            my_size += ::protobuf::rt::value_size(2, self.hold_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.keepalive_interval != 0 {
            my_size += ::protobuf::rt::value_size(3, self.keepalive_interval, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.minimum_advertisement_interval != 0 {
            my_size += ::protobuf::rt::value_size(4, self.minimum_advertisement_interval, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.negotiated_hold_time != 0 {
            my_size += ::protobuf::rt::value_size(5, self.negotiated_hold_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.uptime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.downtime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.connect_retry != 0 {
            os.write_uint64(1, self.connect_retry)?;
        }
        if self.hold_time != 0 {
            os.write_uint64(2, self.hold_time)?;
        }
        if self.keepalive_interval != 0 {
            os.write_uint64(3, self.keepalive_interval)?;
        }
        if self.minimum_advertisement_interval != 0 {
            os.write_uint64(4, self.minimum_advertisement_interval)?;
        }
        if self.negotiated_hold_time != 0 {
            os.write_uint64(5, self.negotiated_hold_time)?;
        }
        if let Some(ref v) = self.uptime.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.downtime.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TimersState {
        TimersState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "connect_retry",
                    |m: &TimersState| { &m.connect_retry },
                    |m: &mut TimersState| { &mut m.connect_retry },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "hold_time",
                    |m: &TimersState| { &m.hold_time },
                    |m: &mut TimersState| { &mut m.hold_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "keepalive_interval",
                    |m: &TimersState| { &m.keepalive_interval },
                    |m: &mut TimersState| { &mut m.keepalive_interval },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "minimum_advertisement_interval",
                    |m: &TimersState| { &m.minimum_advertisement_interval },
                    |m: &mut TimersState| { &mut m.minimum_advertisement_interval },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "negotiated_hold_time",
                    |m: &TimersState| { &m.negotiated_hold_time },
                    |m: &mut TimersState| { &mut m.negotiated_hold_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "uptime",
                    |m: &TimersState| { &m.uptime },
                    |m: &mut TimersState| { &mut m.uptime },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "downtime",
                    |m: &TimersState| { &m.downtime },
                    |m: &mut TimersState| { &mut m.downtime },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TimersState>(
                    "TimersState",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TimersState {
        static mut instance: ::protobuf::lazy::Lazy<TimersState> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TimersState,
        };
        unsafe {
            instance.get(TimersState::new)
        }
    }
}

impl ::protobuf::Clear for TimersState {
    fn clear(&mut self) {
        self.connect_retry = 0;
        self.hold_time = 0;
        self.keepalive_interval = 0;
        self.minimum_advertisement_interval = 0;
        self.negotiated_hold_time = 0;
        self.uptime.clear();
        self.downtime.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TimersState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TimersState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Transport {
    // message fields
    pub local_address: ::std::string::String,
    pub local_port: u32,
    pub mtu_discovery: bool,
    pub passive_mode: bool,
    pub remote_address: ::std::string::String,
    pub remote_port: u32,
    pub tcp_mss: u32,
    pub bind_interface: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Transport {
    fn default() -> &'a Transport {
        <Transport as ::protobuf::Message>::default_instance()
    }
}

impl Transport {
    pub fn new() -> Transport {
        ::std::default::Default::default()
    }

    // string local_address = 1;


    pub fn get_local_address(&self) -> &str {
        &self.local_address
    }
    pub fn clear_local_address(&mut self) {
        self.local_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_local_address(&mut self, v: ::std::string::String) {
        self.local_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_local_address(&mut self) -> &mut ::std::string::String {
        &mut self.local_address
    }

    // Take field
    pub fn take_local_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.local_address, ::std::string::String::new())
    }

    // uint32 local_port = 2;


    pub fn get_local_port(&self) -> u32 {
        self.local_port
    }
    pub fn clear_local_port(&mut self) {
        self.local_port = 0;
    }

    // Param is passed by value, moved
    pub fn set_local_port(&mut self, v: u32) {
        self.local_port = v;
    }

    // bool mtu_discovery = 3;


    pub fn get_mtu_discovery(&self) -> bool {
        self.mtu_discovery
    }
    pub fn clear_mtu_discovery(&mut self) {
        self.mtu_discovery = false;
    }

    // Param is passed by value, moved
    pub fn set_mtu_discovery(&mut self, v: bool) {
        self.mtu_discovery = v;
    }

    // bool passive_mode = 4;


    pub fn get_passive_mode(&self) -> bool {
        self.passive_mode
    }
    pub fn clear_passive_mode(&mut self) {
        self.passive_mode = false;
    }

    // Param is passed by value, moved
    pub fn set_passive_mode(&mut self, v: bool) {
        self.passive_mode = v;
    }

    // string remote_address = 5;


    pub fn get_remote_address(&self) -> &str {
        &self.remote_address
    }
    pub fn clear_remote_address(&mut self) {
        self.remote_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_remote_address(&mut self, v: ::std::string::String) {
        self.remote_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remote_address(&mut self) -> &mut ::std::string::String {
        &mut self.remote_address
    }

    // Take field
    pub fn take_remote_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.remote_address, ::std::string::String::new())
    }

    // uint32 remote_port = 6;


    pub fn get_remote_port(&self) -> u32 {
        self.remote_port
    }
    pub fn clear_remote_port(&mut self) {
        self.remote_port = 0;
    }

    // Param is passed by value, moved
    pub fn set_remote_port(&mut self, v: u32) {
        self.remote_port = v;
    }

    // uint32 tcp_mss = 7;


    pub fn get_tcp_mss(&self) -> u32 {
        self.tcp_mss
    }
    pub fn clear_tcp_mss(&mut self) {
        self.tcp_mss = 0;
    }

    // Param is passed by value, moved
    pub fn set_tcp_mss(&mut self, v: u32) {
        self.tcp_mss = v;
    }

    // string bind_interface = 8;


    pub fn get_bind_interface(&self) -> &str {
        &self.bind_interface
    }
    pub fn clear_bind_interface(&mut self) {
        self.bind_interface.clear();
    }

    // Param is passed by value, moved
    pub fn set_bind_interface(&mut self, v: ::std::string::String) {
        self.bind_interface = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bind_interface(&mut self) -> &mut ::std::string::String {
        &mut self.bind_interface
    }

    // Take field
    pub fn take_bind_interface(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bind_interface, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Transport {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.local_address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.local_port = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.mtu_discovery = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.passive_mode = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.remote_address)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.remote_port = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.tcp_mss = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bind_interface)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.local_address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.local_address);
        }
        if self.local_port != 0 {
            my_size += ::protobuf::rt::value_size(2, self.local_port, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.mtu_discovery != false {
            my_size += 2;
        }
        if self.passive_mode != false {
            my_size += 2;
        }
        if !self.remote_address.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.remote_address);
        }
        if self.remote_port != 0 {
            my_size += ::protobuf::rt::value_size(6, self.remote_port, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.tcp_mss != 0 {
            my_size += ::protobuf::rt::value_size(7, self.tcp_mss, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.bind_interface.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.bind_interface);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.local_address.is_empty() {
            os.write_string(1, &self.local_address)?;
        }
        if self.local_port != 0 {
            os.write_uint32(2, self.local_port)?;
        }
        if self.mtu_discovery != false {
            os.write_bool(3, self.mtu_discovery)?;
        }
        if self.passive_mode != false {
            os.write_bool(4, self.passive_mode)?;
        }
        if !self.remote_address.is_empty() {
            os.write_string(5, &self.remote_address)?;
        }
        if self.remote_port != 0 {
            os.write_uint32(6, self.remote_port)?;
        }
        if self.tcp_mss != 0 {
            os.write_uint32(7, self.tcp_mss)?;
        }
        if !self.bind_interface.is_empty() {
            os.write_string(8, &self.bind_interface)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Transport {
        Transport::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "local_address",
                    |m: &Transport| { &m.local_address },
                    |m: &mut Transport| { &mut m.local_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "local_port",
                    |m: &Transport| { &m.local_port },
                    |m: &mut Transport| { &mut m.local_port },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "mtu_discovery",
                    |m: &Transport| { &m.mtu_discovery },
                    |m: &mut Transport| { &mut m.mtu_discovery },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "passive_mode",
                    |m: &Transport| { &m.passive_mode },
                    |m: &mut Transport| { &mut m.passive_mode },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "remote_address",
                    |m: &Transport| { &m.remote_address },
                    |m: &mut Transport| { &mut m.remote_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "remote_port",
                    |m: &Transport| { &m.remote_port },
                    |m: &mut Transport| { &mut m.remote_port },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "tcp_mss",
                    |m: &Transport| { &m.tcp_mss },
                    |m: &mut Transport| { &mut m.tcp_mss },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bind_interface",
                    |m: &Transport| { &m.bind_interface },
                    |m: &mut Transport| { &mut m.bind_interface },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Transport>(
                    "Transport",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Transport {
        static mut instance: ::protobuf::lazy::Lazy<Transport> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Transport,
        };
        unsafe {
            instance.get(Transport::new)
        }
    }
}

impl ::protobuf::Clear for Transport {
    fn clear(&mut self) {
        self.local_address.clear();
        self.local_port = 0;
        self.mtu_discovery = false;
        self.passive_mode = false;
        self.remote_address.clear();
        self.remote_port = 0;
        self.tcp_mss = 0;
        self.bind_interface.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Transport {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transport {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RouteServer {
    // message fields
    pub route_server_client: bool,
    pub secondary_route: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RouteServer {
    fn default() -> &'a RouteServer {
        <RouteServer as ::protobuf::Message>::default_instance()
    }
}

impl RouteServer {
    pub fn new() -> RouteServer {
        ::std::default::Default::default()
    }

    // bool route_server_client = 1;


    pub fn get_route_server_client(&self) -> bool {
        self.route_server_client
    }
    pub fn clear_route_server_client(&mut self) {
        self.route_server_client = false;
    }

    // Param is passed by value, moved
    pub fn set_route_server_client(&mut self, v: bool) {
        self.route_server_client = v;
    }

    // bool secondary_route = 2;


    pub fn get_secondary_route(&self) -> bool {
        self.secondary_route
    }
    pub fn clear_secondary_route(&mut self) {
        self.secondary_route = false;
    }

    // Param is passed by value, moved
    pub fn set_secondary_route(&mut self, v: bool) {
        self.secondary_route = v;
    }
}

impl ::protobuf::Message for RouteServer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.route_server_client = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.secondary_route = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.route_server_client != false {
            my_size += 2;
        }
        if self.secondary_route != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.route_server_client != false {
            os.write_bool(1, self.route_server_client)?;
        }
        if self.secondary_route != false {
            os.write_bool(2, self.secondary_route)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouteServer {
        RouteServer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "route_server_client",
                    |m: &RouteServer| { &m.route_server_client },
                    |m: &mut RouteServer| { &mut m.route_server_client },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "secondary_route",
                    |m: &RouteServer| { &m.secondary_route },
                    |m: &mut RouteServer| { &mut m.secondary_route },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RouteServer>(
                    "RouteServer",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RouteServer {
        static mut instance: ::protobuf::lazy::Lazy<RouteServer> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RouteServer,
        };
        unsafe {
            instance.get(RouteServer::new)
        }
    }
}

impl ::protobuf::Clear for RouteServer {
    fn clear(&mut self) {
        self.route_server_client = false;
        self.secondary_route = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouteServer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteServer {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GracefulRestart {
    // message fields
    pub enabled: bool,
    pub restart_time: u32,
    pub helper_only: bool,
    pub deferral_time: u32,
    pub notification_enabled: bool,
    pub longlived_enabled: bool,
    pub stale_routes_time: u32,
    pub peer_restart_time: u32,
    pub peer_restarting: bool,
    pub local_restarting: bool,
    pub mode: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GracefulRestart {
    fn default() -> &'a GracefulRestart {
        <GracefulRestart as ::protobuf::Message>::default_instance()
    }
}

impl GracefulRestart {
    pub fn new() -> GracefulRestart {
        ::std::default::Default::default()
    }

    // bool enabled = 1;


    pub fn get_enabled(&self) -> bool {
        self.enabled
    }
    pub fn clear_enabled(&mut self) {
        self.enabled = false;
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: bool) {
        self.enabled = v;
    }

    // uint32 restart_time = 2;


    pub fn get_restart_time(&self) -> u32 {
        self.restart_time
    }
    pub fn clear_restart_time(&mut self) {
        self.restart_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_restart_time(&mut self, v: u32) {
        self.restart_time = v;
    }

    // bool helper_only = 3;


    pub fn get_helper_only(&self) -> bool {
        self.helper_only
    }
    pub fn clear_helper_only(&mut self) {
        self.helper_only = false;
    }

    // Param is passed by value, moved
    pub fn set_helper_only(&mut self, v: bool) {
        self.helper_only = v;
    }

    // uint32 deferral_time = 4;


    pub fn get_deferral_time(&self) -> u32 {
        self.deferral_time
    }
    pub fn clear_deferral_time(&mut self) {
        self.deferral_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_deferral_time(&mut self, v: u32) {
        self.deferral_time = v;
    }

    // bool notification_enabled = 5;


    pub fn get_notification_enabled(&self) -> bool {
        self.notification_enabled
    }
    pub fn clear_notification_enabled(&mut self) {
        self.notification_enabled = false;
    }

    // Param is passed by value, moved
    pub fn set_notification_enabled(&mut self, v: bool) {
        self.notification_enabled = v;
    }

    // bool longlived_enabled = 6;


    pub fn get_longlived_enabled(&self) -> bool {
        self.longlived_enabled
    }
    pub fn clear_longlived_enabled(&mut self) {
        self.longlived_enabled = false;
    }

    // Param is passed by value, moved
    pub fn set_longlived_enabled(&mut self, v: bool) {
        self.longlived_enabled = v;
    }

    // uint32 stale_routes_time = 7;


    pub fn get_stale_routes_time(&self) -> u32 {
        self.stale_routes_time
    }
    pub fn clear_stale_routes_time(&mut self) {
        self.stale_routes_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_stale_routes_time(&mut self, v: u32) {
        self.stale_routes_time = v;
    }

    // uint32 peer_restart_time = 8;


    pub fn get_peer_restart_time(&self) -> u32 {
        self.peer_restart_time
    }
    pub fn clear_peer_restart_time(&mut self) {
        self.peer_restart_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_peer_restart_time(&mut self, v: u32) {
        self.peer_restart_time = v;
    }

    // bool peer_restarting = 9;


    pub fn get_peer_restarting(&self) -> bool {
        self.peer_restarting
    }
    pub fn clear_peer_restarting(&mut self) {
        self.peer_restarting = false;
    }

    // Param is passed by value, moved
    pub fn set_peer_restarting(&mut self, v: bool) {
        self.peer_restarting = v;
    }

    // bool local_restarting = 10;


    pub fn get_local_restarting(&self) -> bool {
        self.local_restarting
    }
    pub fn clear_local_restarting(&mut self) {
        self.local_restarting = false;
    }

    // Param is passed by value, moved
    pub fn set_local_restarting(&mut self, v: bool) {
        self.local_restarting = v;
    }

    // string mode = 11;


    pub fn get_mode(&self) -> &str {
        &self.mode
    }
    pub fn clear_mode(&mut self) {
        self.mode.clear();
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: ::std::string::String) {
        self.mode = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mode(&mut self) -> &mut ::std::string::String {
        &mut self.mode
    }

    // Take field
    pub fn take_mode(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mode, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GracefulRestart {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enabled = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.restart_time = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.helper_only = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.deferral_time = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.notification_enabled = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.longlived_enabled = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.stale_routes_time = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.peer_restart_time = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.peer_restarting = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.local_restarting = tmp;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.mode)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.enabled != false {
            my_size += 2;
        }
        if self.restart_time != 0 {
            my_size += ::protobuf::rt::value_size(2, self.restart_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.helper_only != false {
            my_size += 2;
        }
        if self.deferral_time != 0 {
            my_size += ::protobuf::rt::value_size(4, self.deferral_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.notification_enabled != false {
            my_size += 2;
        }
        if self.longlived_enabled != false {
            my_size += 2;
        }
        if self.stale_routes_time != 0 {
            my_size += ::protobuf::rt::value_size(7, self.stale_routes_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.peer_restart_time != 0 {
            my_size += ::protobuf::rt::value_size(8, self.peer_restart_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.peer_restarting != false {
            my_size += 2;
        }
        if self.local_restarting != false {
            my_size += 2;
        }
        if !self.mode.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.mode);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.enabled != false {
            os.write_bool(1, self.enabled)?;
        }
        if self.restart_time != 0 {
            os.write_uint32(2, self.restart_time)?;
        }
        if self.helper_only != false {
            os.write_bool(3, self.helper_only)?;
        }
        if self.deferral_time != 0 {
            os.write_uint32(4, self.deferral_time)?;
        }
        if self.notification_enabled != false {
            os.write_bool(5, self.notification_enabled)?;
        }
        if self.longlived_enabled != false {
            os.write_bool(6, self.longlived_enabled)?;
        }
        if self.stale_routes_time != 0 {
            os.write_uint32(7, self.stale_routes_time)?;
        }
        if self.peer_restart_time != 0 {
            os.write_uint32(8, self.peer_restart_time)?;
        }
        if self.peer_restarting != false {
            os.write_bool(9, self.peer_restarting)?;
        }
        if self.local_restarting != false {
            os.write_bool(10, self.local_restarting)?;
        }
        if !self.mode.is_empty() {
            os.write_string(11, &self.mode)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GracefulRestart {
        GracefulRestart::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "enabled",
                    |m: &GracefulRestart| { &m.enabled },
                    |m: &mut GracefulRestart| { &mut m.enabled },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "restart_time",
                    |m: &GracefulRestart| { &m.restart_time },
                    |m: &mut GracefulRestart| { &mut m.restart_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "helper_only",
                    |m: &GracefulRestart| { &m.helper_only },
                    |m: &mut GracefulRestart| { &mut m.helper_only },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "deferral_time",
                    |m: &GracefulRestart| { &m.deferral_time },
                    |m: &mut GracefulRestart| { &mut m.deferral_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "notification_enabled",
                    |m: &GracefulRestart| { &m.notification_enabled },
                    |m: &mut GracefulRestart| { &mut m.notification_enabled },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "longlived_enabled",
                    |m: &GracefulRestart| { &m.longlived_enabled },
                    |m: &mut GracefulRestart| { &mut m.longlived_enabled },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "stale_routes_time",
                    |m: &GracefulRestart| { &m.stale_routes_time },
                    |m: &mut GracefulRestart| { &mut m.stale_routes_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "peer_restart_time",
                    |m: &GracefulRestart| { &m.peer_restart_time },
                    |m: &mut GracefulRestart| { &mut m.peer_restart_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "peer_restarting",
                    |m: &GracefulRestart| { &m.peer_restarting },
                    |m: &mut GracefulRestart| { &mut m.peer_restarting },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "local_restarting",
                    |m: &GracefulRestart| { &m.local_restarting },
                    |m: &mut GracefulRestart| { &mut m.local_restarting },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "mode",
                    |m: &GracefulRestart| { &m.mode },
                    |m: &mut GracefulRestart| { &mut m.mode },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GracefulRestart>(
                    "GracefulRestart",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GracefulRestart {
        static mut instance: ::protobuf::lazy::Lazy<GracefulRestart> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GracefulRestart,
        };
        unsafe {
            instance.get(GracefulRestart::new)
        }
    }
}

impl ::protobuf::Clear for GracefulRestart {
    fn clear(&mut self) {
        self.enabled = false;
        self.restart_time = 0;
        self.helper_only = false;
        self.deferral_time = 0;
        self.notification_enabled = false;
        self.longlived_enabled = false;
        self.stale_routes_time = 0;
        self.peer_restart_time = 0;
        self.peer_restarting = false;
        self.local_restarting = false;
        self.mode.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GracefulRestart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GracefulRestart {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MpGracefulRestartConfig {
    // message fields
    pub enabled: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MpGracefulRestartConfig {
    fn default() -> &'a MpGracefulRestartConfig {
        <MpGracefulRestartConfig as ::protobuf::Message>::default_instance()
    }
}

impl MpGracefulRestartConfig {
    pub fn new() -> MpGracefulRestartConfig {
        ::std::default::Default::default()
    }

    // bool enabled = 1;


    pub fn get_enabled(&self) -> bool {
        self.enabled
    }
    pub fn clear_enabled(&mut self) {
        self.enabled = false;
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: bool) {
        self.enabled = v;
    }
}

impl ::protobuf::Message for MpGracefulRestartConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enabled = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.enabled != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.enabled != false {
            os.write_bool(1, self.enabled)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MpGracefulRestartConfig {
        MpGracefulRestartConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "enabled",
                    |m: &MpGracefulRestartConfig| { &m.enabled },
                    |m: &mut MpGracefulRestartConfig| { &mut m.enabled },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MpGracefulRestartConfig>(
                    "MpGracefulRestartConfig",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MpGracefulRestartConfig {
        static mut instance: ::protobuf::lazy::Lazy<MpGracefulRestartConfig> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MpGracefulRestartConfig,
        };
        unsafe {
            instance.get(MpGracefulRestartConfig::new)
        }
    }
}

impl ::protobuf::Clear for MpGracefulRestartConfig {
    fn clear(&mut self) {
        self.enabled = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MpGracefulRestartConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MpGracefulRestartConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MpGracefulRestartState {
    // message fields
    pub enabled: bool,
    pub received: bool,
    pub advertised: bool,
    pub end_of_rib_received: bool,
    pub end_of_rib_sent: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MpGracefulRestartState {
    fn default() -> &'a MpGracefulRestartState {
        <MpGracefulRestartState as ::protobuf::Message>::default_instance()
    }
}

impl MpGracefulRestartState {
    pub fn new() -> MpGracefulRestartState {
        ::std::default::Default::default()
    }

    // bool enabled = 1;


    pub fn get_enabled(&self) -> bool {
        self.enabled
    }
    pub fn clear_enabled(&mut self) {
        self.enabled = false;
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: bool) {
        self.enabled = v;
    }

    // bool received = 2;


    pub fn get_received(&self) -> bool {
        self.received
    }
    pub fn clear_received(&mut self) {
        self.received = false;
    }

    // Param is passed by value, moved
    pub fn set_received(&mut self, v: bool) {
        self.received = v;
    }

    // bool advertised = 3;


    pub fn get_advertised(&self) -> bool {
        self.advertised
    }
    pub fn clear_advertised(&mut self) {
        self.advertised = false;
    }

    // Param is passed by value, moved
    pub fn set_advertised(&mut self, v: bool) {
        self.advertised = v;
    }

    // bool end_of_rib_received = 4;


    pub fn get_end_of_rib_received(&self) -> bool {
        self.end_of_rib_received
    }
    pub fn clear_end_of_rib_received(&mut self) {
        self.end_of_rib_received = false;
    }

    // Param is passed by value, moved
    pub fn set_end_of_rib_received(&mut self, v: bool) {
        self.end_of_rib_received = v;
    }

    // bool end_of_rib_sent = 5;


    pub fn get_end_of_rib_sent(&self) -> bool {
        self.end_of_rib_sent
    }
    pub fn clear_end_of_rib_sent(&mut self) {
        self.end_of_rib_sent = false;
    }

    // Param is passed by value, moved
    pub fn set_end_of_rib_sent(&mut self, v: bool) {
        self.end_of_rib_sent = v;
    }
}

impl ::protobuf::Message for MpGracefulRestartState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enabled = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.received = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.advertised = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.end_of_rib_received = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.end_of_rib_sent = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.enabled != false {
            my_size += 2;
        }
        if self.received != false {
            my_size += 2;
        }
        if self.advertised != false {
            my_size += 2;
        }
        if self.end_of_rib_received != false {
            my_size += 2;
        }
        if self.end_of_rib_sent != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.enabled != false {
            os.write_bool(1, self.enabled)?;
        }
        if self.received != false {
            os.write_bool(2, self.received)?;
        }
        if self.advertised != false {
            os.write_bool(3, self.advertised)?;
        }
        if self.end_of_rib_received != false {
            os.write_bool(4, self.end_of_rib_received)?;
        }
        if self.end_of_rib_sent != false {
            os.write_bool(5, self.end_of_rib_sent)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MpGracefulRestartState {
        MpGracefulRestartState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "enabled",
                    |m: &MpGracefulRestartState| { &m.enabled },
                    |m: &mut MpGracefulRestartState| { &mut m.enabled },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "received",
                    |m: &MpGracefulRestartState| { &m.received },
                    |m: &mut MpGracefulRestartState| { &mut m.received },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "advertised",
                    |m: &MpGracefulRestartState| { &m.advertised },
                    |m: &mut MpGracefulRestartState| { &mut m.advertised },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "end_of_rib_received",
                    |m: &MpGracefulRestartState| { &m.end_of_rib_received },
                    |m: &mut MpGracefulRestartState| { &mut m.end_of_rib_received },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "end_of_rib_sent",
                    |m: &MpGracefulRestartState| { &m.end_of_rib_sent },
                    |m: &mut MpGracefulRestartState| { &mut m.end_of_rib_sent },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MpGracefulRestartState>(
                    "MpGracefulRestartState",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MpGracefulRestartState {
        static mut instance: ::protobuf::lazy::Lazy<MpGracefulRestartState> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MpGracefulRestartState,
        };
        unsafe {
            instance.get(MpGracefulRestartState::new)
        }
    }
}

impl ::protobuf::Clear for MpGracefulRestartState {
    fn clear(&mut self) {
        self.enabled = false;
        self.received = false;
        self.advertised = false;
        self.end_of_rib_received = false;
        self.end_of_rib_sent = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MpGracefulRestartState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MpGracefulRestartState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MpGracefulRestart {
    // message fields
    pub config: ::protobuf::SingularPtrField<MpGracefulRestartConfig>,
    pub state: ::protobuf::SingularPtrField<MpGracefulRestartState>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MpGracefulRestart {
    fn default() -> &'a MpGracefulRestart {
        <MpGracefulRestart as ::protobuf::Message>::default_instance()
    }
}

impl MpGracefulRestart {
    pub fn new() -> MpGracefulRestart {
        ::std::default::Default::default()
    }

    // .gobgpapi.MpGracefulRestartConfig config = 1;


    pub fn get_config(&self) -> &MpGracefulRestartConfig {
        self.config.as_ref().unwrap_or_else(|| MpGracefulRestartConfig::default_instance())
    }
    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    pub fn has_config(&self) -> bool {
        self.config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: MpGracefulRestartConfig) {
        self.config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config(&mut self) -> &mut MpGracefulRestartConfig {
        if self.config.is_none() {
            self.config.set_default();
        }
        self.config.as_mut().unwrap()
    }

    // Take field
    pub fn take_config(&mut self) -> MpGracefulRestartConfig {
        self.config.take().unwrap_or_else(|| MpGracefulRestartConfig::new())
    }

    // .gobgpapi.MpGracefulRestartState state = 2;


    pub fn get_state(&self) -> &MpGracefulRestartState {
        self.state.as_ref().unwrap_or_else(|| MpGracefulRestartState::default_instance())
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: MpGracefulRestartState) {
        self.state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut MpGracefulRestartState {
        if self.state.is_none() {
            self.state.set_default();
        }
        self.state.as_mut().unwrap()
    }

    // Take field
    pub fn take_state(&mut self) -> MpGracefulRestartState {
        self.state.take().unwrap_or_else(|| MpGracefulRestartState::new())
    }
}

impl ::protobuf::Message for MpGracefulRestart {
    fn is_initialized(&self) -> bool {
        for v in &self.config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.state {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.config)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.state)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.config.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.state.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MpGracefulRestart {
        MpGracefulRestart::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MpGracefulRestartConfig>>(
                    "config",
                    |m: &MpGracefulRestart| { &m.config },
                    |m: &mut MpGracefulRestart| { &mut m.config },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MpGracefulRestartState>>(
                    "state",
                    |m: &MpGracefulRestart| { &m.state },
                    |m: &mut MpGracefulRestart| { &mut m.state },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MpGracefulRestart>(
                    "MpGracefulRestart",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MpGracefulRestart {
        static mut instance: ::protobuf::lazy::Lazy<MpGracefulRestart> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MpGracefulRestart,
        };
        unsafe {
            instance.get(MpGracefulRestart::new)
        }
    }
}

impl ::protobuf::Clear for MpGracefulRestart {
    fn clear(&mut self) {
        self.config.clear();
        self.state.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MpGracefulRestart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MpGracefulRestart {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AfiSafiConfig {
    // message fields
    pub family: ::protobuf::SingularPtrField<Family>,
    pub enabled: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AfiSafiConfig {
    fn default() -> &'a AfiSafiConfig {
        <AfiSafiConfig as ::protobuf::Message>::default_instance()
    }
}

impl AfiSafiConfig {
    pub fn new() -> AfiSafiConfig {
        ::std::default::Default::default()
    }

    // .gobgpapi.Family family = 1;


    pub fn get_family(&self) -> &Family {
        self.family.as_ref().unwrap_or_else(|| Family::default_instance())
    }
    pub fn clear_family(&mut self) {
        self.family.clear();
    }

    pub fn has_family(&self) -> bool {
        self.family.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family(&mut self, v: Family) {
        self.family = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_family(&mut self) -> &mut Family {
        if self.family.is_none() {
            self.family.set_default();
        }
        self.family.as_mut().unwrap()
    }

    // Take field
    pub fn take_family(&mut self) -> Family {
        self.family.take().unwrap_or_else(|| Family::new())
    }

    // bool enabled = 2;


    pub fn get_enabled(&self) -> bool {
        self.enabled
    }
    pub fn clear_enabled(&mut self) {
        self.enabled = false;
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: bool) {
        self.enabled = v;
    }
}

impl ::protobuf::Message for AfiSafiConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.family {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.family)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enabled = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.family.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.enabled != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.family.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.enabled != false {
            os.write_bool(2, self.enabled)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AfiSafiConfig {
        AfiSafiConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Family>>(
                    "family",
                    |m: &AfiSafiConfig| { &m.family },
                    |m: &mut AfiSafiConfig| { &mut m.family },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "enabled",
                    |m: &AfiSafiConfig| { &m.enabled },
                    |m: &mut AfiSafiConfig| { &mut m.enabled },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AfiSafiConfig>(
                    "AfiSafiConfig",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AfiSafiConfig {
        static mut instance: ::protobuf::lazy::Lazy<AfiSafiConfig> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AfiSafiConfig,
        };
        unsafe {
            instance.get(AfiSafiConfig::new)
        }
    }
}

impl ::protobuf::Clear for AfiSafiConfig {
    fn clear(&mut self) {
        self.family.clear();
        self.enabled = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AfiSafiConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AfiSafiConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AfiSafiState {
    // message fields
    pub family: ::protobuf::SingularPtrField<Family>,
    pub enabled: bool,
    pub received: u64,
    pub accepted: u64,
    pub advertised: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AfiSafiState {
    fn default() -> &'a AfiSafiState {
        <AfiSafiState as ::protobuf::Message>::default_instance()
    }
}

impl AfiSafiState {
    pub fn new() -> AfiSafiState {
        ::std::default::Default::default()
    }

    // .gobgpapi.Family family = 1;


    pub fn get_family(&self) -> &Family {
        self.family.as_ref().unwrap_or_else(|| Family::default_instance())
    }
    pub fn clear_family(&mut self) {
        self.family.clear();
    }

    pub fn has_family(&self) -> bool {
        self.family.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family(&mut self, v: Family) {
        self.family = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_family(&mut self) -> &mut Family {
        if self.family.is_none() {
            self.family.set_default();
        }
        self.family.as_mut().unwrap()
    }

    // Take field
    pub fn take_family(&mut self) -> Family {
        self.family.take().unwrap_or_else(|| Family::new())
    }

    // bool enabled = 2;


    pub fn get_enabled(&self) -> bool {
        self.enabled
    }
    pub fn clear_enabled(&mut self) {
        self.enabled = false;
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: bool) {
        self.enabled = v;
    }

    // uint64 received = 3;


    pub fn get_received(&self) -> u64 {
        self.received
    }
    pub fn clear_received(&mut self) {
        self.received = 0;
    }

    // Param is passed by value, moved
    pub fn set_received(&mut self, v: u64) {
        self.received = v;
    }

    // uint64 accepted = 4;


    pub fn get_accepted(&self) -> u64 {
        self.accepted
    }
    pub fn clear_accepted(&mut self) {
        self.accepted = 0;
    }

    // Param is passed by value, moved
    pub fn set_accepted(&mut self, v: u64) {
        self.accepted = v;
    }

    // uint64 advertised = 5;


    pub fn get_advertised(&self) -> u64 {
        self.advertised
    }
    pub fn clear_advertised(&mut self) {
        self.advertised = 0;
    }

    // Param is passed by value, moved
    pub fn set_advertised(&mut self, v: u64) {
        self.advertised = v;
    }
}

impl ::protobuf::Message for AfiSafiState {
    fn is_initialized(&self) -> bool {
        for v in &self.family {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.family)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enabled = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.received = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.accepted = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.advertised = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.family.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.enabled != false {
            my_size += 2;
        }
        if self.received != 0 {
            my_size += ::protobuf::rt::value_size(3, self.received, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.accepted != 0 {
            my_size += ::protobuf::rt::value_size(4, self.accepted, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.advertised != 0 {
            my_size += ::protobuf::rt::value_size(5, self.advertised, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.family.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.enabled != false {
            os.write_bool(2, self.enabled)?;
        }
        if self.received != 0 {
            os.write_uint64(3, self.received)?;
        }
        if self.accepted != 0 {
            os.write_uint64(4, self.accepted)?;
        }
        if self.advertised != 0 {
            os.write_uint64(5, self.advertised)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AfiSafiState {
        AfiSafiState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Family>>(
                    "family",
                    |m: &AfiSafiState| { &m.family },
                    |m: &mut AfiSafiState| { &mut m.family },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "enabled",
                    |m: &AfiSafiState| { &m.enabled },
                    |m: &mut AfiSafiState| { &mut m.enabled },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "received",
                    |m: &AfiSafiState| { &m.received },
                    |m: &mut AfiSafiState| { &mut m.received },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "accepted",
                    |m: &AfiSafiState| { &m.accepted },
                    |m: &mut AfiSafiState| { &mut m.accepted },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "advertised",
                    |m: &AfiSafiState| { &m.advertised },
                    |m: &mut AfiSafiState| { &mut m.advertised },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AfiSafiState>(
                    "AfiSafiState",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AfiSafiState {
        static mut instance: ::protobuf::lazy::Lazy<AfiSafiState> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AfiSafiState,
        };
        unsafe {
            instance.get(AfiSafiState::new)
        }
    }
}

impl ::protobuf::Clear for AfiSafiState {
    fn clear(&mut self) {
        self.family.clear();
        self.enabled = false;
        self.received = 0;
        self.accepted = 0;
        self.advertised = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AfiSafiState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AfiSafiState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RouteSelectionOptionsConfig {
    // message fields
    pub always_compare_med: bool,
    pub ignore_as_path_length: bool,
    pub external_compare_router_id: bool,
    pub advertise_inactive_routes: bool,
    pub enable_aigp: bool,
    pub ignore_next_hop_igp_metric: bool,
    pub disable_best_path_selection: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RouteSelectionOptionsConfig {
    fn default() -> &'a RouteSelectionOptionsConfig {
        <RouteSelectionOptionsConfig as ::protobuf::Message>::default_instance()
    }
}

impl RouteSelectionOptionsConfig {
    pub fn new() -> RouteSelectionOptionsConfig {
        ::std::default::Default::default()
    }

    // bool always_compare_med = 1;


    pub fn get_always_compare_med(&self) -> bool {
        self.always_compare_med
    }
    pub fn clear_always_compare_med(&mut self) {
        self.always_compare_med = false;
    }

    // Param is passed by value, moved
    pub fn set_always_compare_med(&mut self, v: bool) {
        self.always_compare_med = v;
    }

    // bool ignore_as_path_length = 2;


    pub fn get_ignore_as_path_length(&self) -> bool {
        self.ignore_as_path_length
    }
    pub fn clear_ignore_as_path_length(&mut self) {
        self.ignore_as_path_length = false;
    }

    // Param is passed by value, moved
    pub fn set_ignore_as_path_length(&mut self, v: bool) {
        self.ignore_as_path_length = v;
    }

    // bool external_compare_router_id = 3;


    pub fn get_external_compare_router_id(&self) -> bool {
        self.external_compare_router_id
    }
    pub fn clear_external_compare_router_id(&mut self) {
        self.external_compare_router_id = false;
    }

    // Param is passed by value, moved
    pub fn set_external_compare_router_id(&mut self, v: bool) {
        self.external_compare_router_id = v;
    }

    // bool advertise_inactive_routes = 4;


    pub fn get_advertise_inactive_routes(&self) -> bool {
        self.advertise_inactive_routes
    }
    pub fn clear_advertise_inactive_routes(&mut self) {
        self.advertise_inactive_routes = false;
    }

    // Param is passed by value, moved
    pub fn set_advertise_inactive_routes(&mut self, v: bool) {
        self.advertise_inactive_routes = v;
    }

    // bool enable_aigp = 5;


    pub fn get_enable_aigp(&self) -> bool {
        self.enable_aigp
    }
    pub fn clear_enable_aigp(&mut self) {
        self.enable_aigp = false;
    }

    // Param is passed by value, moved
    pub fn set_enable_aigp(&mut self, v: bool) {
        self.enable_aigp = v;
    }

    // bool ignore_next_hop_igp_metric = 6;


    pub fn get_ignore_next_hop_igp_metric(&self) -> bool {
        self.ignore_next_hop_igp_metric
    }
    pub fn clear_ignore_next_hop_igp_metric(&mut self) {
        self.ignore_next_hop_igp_metric = false;
    }

    // Param is passed by value, moved
    pub fn set_ignore_next_hop_igp_metric(&mut self, v: bool) {
        self.ignore_next_hop_igp_metric = v;
    }

    // bool disable_best_path_selection = 7;


    pub fn get_disable_best_path_selection(&self) -> bool {
        self.disable_best_path_selection
    }
    pub fn clear_disable_best_path_selection(&mut self) {
        self.disable_best_path_selection = false;
    }

    // Param is passed by value, moved
    pub fn set_disable_best_path_selection(&mut self, v: bool) {
        self.disable_best_path_selection = v;
    }
}

impl ::protobuf::Message for RouteSelectionOptionsConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.always_compare_med = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ignore_as_path_length = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.external_compare_router_id = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.advertise_inactive_routes = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_aigp = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ignore_next_hop_igp_metric = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disable_best_path_selection = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.always_compare_med != false {
            my_size += 2;
        }
        if self.ignore_as_path_length != false {
            my_size += 2;
        }
        if self.external_compare_router_id != false {
            my_size += 2;
        }
        if self.advertise_inactive_routes != false {
            my_size += 2;
        }
        if self.enable_aigp != false {
            my_size += 2;
        }
        if self.ignore_next_hop_igp_metric != false {
            my_size += 2;
        }
        if self.disable_best_path_selection != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.always_compare_med != false {
            os.write_bool(1, self.always_compare_med)?;
        }
        if self.ignore_as_path_length != false {
            os.write_bool(2, self.ignore_as_path_length)?;
        }
        if self.external_compare_router_id != false {
            os.write_bool(3, self.external_compare_router_id)?;
        }
        if self.advertise_inactive_routes != false {
            os.write_bool(4, self.advertise_inactive_routes)?;
        }
        if self.enable_aigp != false {
            os.write_bool(5, self.enable_aigp)?;
        }
        if self.ignore_next_hop_igp_metric != false {
            os.write_bool(6, self.ignore_next_hop_igp_metric)?;
        }
        if self.disable_best_path_selection != false {
            os.write_bool(7, self.disable_best_path_selection)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouteSelectionOptionsConfig {
        RouteSelectionOptionsConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "always_compare_med",
                    |m: &RouteSelectionOptionsConfig| { &m.always_compare_med },
                    |m: &mut RouteSelectionOptionsConfig| { &mut m.always_compare_med },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "ignore_as_path_length",
                    |m: &RouteSelectionOptionsConfig| { &m.ignore_as_path_length },
                    |m: &mut RouteSelectionOptionsConfig| { &mut m.ignore_as_path_length },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "external_compare_router_id",
                    |m: &RouteSelectionOptionsConfig| { &m.external_compare_router_id },
                    |m: &mut RouteSelectionOptionsConfig| { &mut m.external_compare_router_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "advertise_inactive_routes",
                    |m: &RouteSelectionOptionsConfig| { &m.advertise_inactive_routes },
                    |m: &mut RouteSelectionOptionsConfig| { &mut m.advertise_inactive_routes },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "enable_aigp",
                    |m: &RouteSelectionOptionsConfig| { &m.enable_aigp },
                    |m: &mut RouteSelectionOptionsConfig| { &mut m.enable_aigp },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "ignore_next_hop_igp_metric",
                    |m: &RouteSelectionOptionsConfig| { &m.ignore_next_hop_igp_metric },
                    |m: &mut RouteSelectionOptionsConfig| { &mut m.ignore_next_hop_igp_metric },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "disable_best_path_selection",
                    |m: &RouteSelectionOptionsConfig| { &m.disable_best_path_selection },
                    |m: &mut RouteSelectionOptionsConfig| { &mut m.disable_best_path_selection },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RouteSelectionOptionsConfig>(
                    "RouteSelectionOptionsConfig",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RouteSelectionOptionsConfig {
        static mut instance: ::protobuf::lazy::Lazy<RouteSelectionOptionsConfig> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RouteSelectionOptionsConfig,
        };
        unsafe {
            instance.get(RouteSelectionOptionsConfig::new)
        }
    }
}

impl ::protobuf::Clear for RouteSelectionOptionsConfig {
    fn clear(&mut self) {
        self.always_compare_med = false;
        self.ignore_as_path_length = false;
        self.external_compare_router_id = false;
        self.advertise_inactive_routes = false;
        self.enable_aigp = false;
        self.ignore_next_hop_igp_metric = false;
        self.disable_best_path_selection = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouteSelectionOptionsConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteSelectionOptionsConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RouteSelectionOptionsState {
    // message fields
    pub always_compare_med: bool,
    pub ignore_as_path_length: bool,
    pub external_compare_router_id: bool,
    pub advertise_inactive_routes: bool,
    pub enable_aigp: bool,
    pub ignore_next_hop_igp_metric: bool,
    pub disable_best_path_selection: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RouteSelectionOptionsState {
    fn default() -> &'a RouteSelectionOptionsState {
        <RouteSelectionOptionsState as ::protobuf::Message>::default_instance()
    }
}

impl RouteSelectionOptionsState {
    pub fn new() -> RouteSelectionOptionsState {
        ::std::default::Default::default()
    }

    // bool always_compare_med = 1;


    pub fn get_always_compare_med(&self) -> bool {
        self.always_compare_med
    }
    pub fn clear_always_compare_med(&mut self) {
        self.always_compare_med = false;
    }

    // Param is passed by value, moved
    pub fn set_always_compare_med(&mut self, v: bool) {
        self.always_compare_med = v;
    }

    // bool ignore_as_path_length = 2;


    pub fn get_ignore_as_path_length(&self) -> bool {
        self.ignore_as_path_length
    }
    pub fn clear_ignore_as_path_length(&mut self) {
        self.ignore_as_path_length = false;
    }

    // Param is passed by value, moved
    pub fn set_ignore_as_path_length(&mut self, v: bool) {
        self.ignore_as_path_length = v;
    }

    // bool external_compare_router_id = 3;


    pub fn get_external_compare_router_id(&self) -> bool {
        self.external_compare_router_id
    }
    pub fn clear_external_compare_router_id(&mut self) {
        self.external_compare_router_id = false;
    }

    // Param is passed by value, moved
    pub fn set_external_compare_router_id(&mut self, v: bool) {
        self.external_compare_router_id = v;
    }

    // bool advertise_inactive_routes = 4;


    pub fn get_advertise_inactive_routes(&self) -> bool {
        self.advertise_inactive_routes
    }
    pub fn clear_advertise_inactive_routes(&mut self) {
        self.advertise_inactive_routes = false;
    }

    // Param is passed by value, moved
    pub fn set_advertise_inactive_routes(&mut self, v: bool) {
        self.advertise_inactive_routes = v;
    }

    // bool enable_aigp = 5;


    pub fn get_enable_aigp(&self) -> bool {
        self.enable_aigp
    }
    pub fn clear_enable_aigp(&mut self) {
        self.enable_aigp = false;
    }

    // Param is passed by value, moved
    pub fn set_enable_aigp(&mut self, v: bool) {
        self.enable_aigp = v;
    }

    // bool ignore_next_hop_igp_metric = 6;


    pub fn get_ignore_next_hop_igp_metric(&self) -> bool {
        self.ignore_next_hop_igp_metric
    }
    pub fn clear_ignore_next_hop_igp_metric(&mut self) {
        self.ignore_next_hop_igp_metric = false;
    }

    // Param is passed by value, moved
    pub fn set_ignore_next_hop_igp_metric(&mut self, v: bool) {
        self.ignore_next_hop_igp_metric = v;
    }

    // bool disable_best_path_selection = 7;


    pub fn get_disable_best_path_selection(&self) -> bool {
        self.disable_best_path_selection
    }
    pub fn clear_disable_best_path_selection(&mut self) {
        self.disable_best_path_selection = false;
    }

    // Param is passed by value, moved
    pub fn set_disable_best_path_selection(&mut self, v: bool) {
        self.disable_best_path_selection = v;
    }
}

impl ::protobuf::Message for RouteSelectionOptionsState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.always_compare_med = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ignore_as_path_length = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.external_compare_router_id = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.advertise_inactive_routes = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_aigp = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ignore_next_hop_igp_metric = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disable_best_path_selection = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.always_compare_med != false {
            my_size += 2;
        }
        if self.ignore_as_path_length != false {
            my_size += 2;
        }
        if self.external_compare_router_id != false {
            my_size += 2;
        }
        if self.advertise_inactive_routes != false {
            my_size += 2;
        }
        if self.enable_aigp != false {
            my_size += 2;
        }
        if self.ignore_next_hop_igp_metric != false {
            my_size += 2;
        }
        if self.disable_best_path_selection != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.always_compare_med != false {
            os.write_bool(1, self.always_compare_med)?;
        }
        if self.ignore_as_path_length != false {
            os.write_bool(2, self.ignore_as_path_length)?;
        }
        if self.external_compare_router_id != false {
            os.write_bool(3, self.external_compare_router_id)?;
        }
        if self.advertise_inactive_routes != false {
            os.write_bool(4, self.advertise_inactive_routes)?;
        }
        if self.enable_aigp != false {
            os.write_bool(5, self.enable_aigp)?;
        }
        if self.ignore_next_hop_igp_metric != false {
            os.write_bool(6, self.ignore_next_hop_igp_metric)?;
        }
        if self.disable_best_path_selection != false {
            os.write_bool(7, self.disable_best_path_selection)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouteSelectionOptionsState {
        RouteSelectionOptionsState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "always_compare_med",
                    |m: &RouteSelectionOptionsState| { &m.always_compare_med },
                    |m: &mut RouteSelectionOptionsState| { &mut m.always_compare_med },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "ignore_as_path_length",
                    |m: &RouteSelectionOptionsState| { &m.ignore_as_path_length },
                    |m: &mut RouteSelectionOptionsState| { &mut m.ignore_as_path_length },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "external_compare_router_id",
                    |m: &RouteSelectionOptionsState| { &m.external_compare_router_id },
                    |m: &mut RouteSelectionOptionsState| { &mut m.external_compare_router_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "advertise_inactive_routes",
                    |m: &RouteSelectionOptionsState| { &m.advertise_inactive_routes },
                    |m: &mut RouteSelectionOptionsState| { &mut m.advertise_inactive_routes },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "enable_aigp",
                    |m: &RouteSelectionOptionsState| { &m.enable_aigp },
                    |m: &mut RouteSelectionOptionsState| { &mut m.enable_aigp },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "ignore_next_hop_igp_metric",
                    |m: &RouteSelectionOptionsState| { &m.ignore_next_hop_igp_metric },
                    |m: &mut RouteSelectionOptionsState| { &mut m.ignore_next_hop_igp_metric },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "disable_best_path_selection",
                    |m: &RouteSelectionOptionsState| { &m.disable_best_path_selection },
                    |m: &mut RouteSelectionOptionsState| { &mut m.disable_best_path_selection },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RouteSelectionOptionsState>(
                    "RouteSelectionOptionsState",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RouteSelectionOptionsState {
        static mut instance: ::protobuf::lazy::Lazy<RouteSelectionOptionsState> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RouteSelectionOptionsState,
        };
        unsafe {
            instance.get(RouteSelectionOptionsState::new)
        }
    }
}

impl ::protobuf::Clear for RouteSelectionOptionsState {
    fn clear(&mut self) {
        self.always_compare_med = false;
        self.ignore_as_path_length = false;
        self.external_compare_router_id = false;
        self.advertise_inactive_routes = false;
        self.enable_aigp = false;
        self.ignore_next_hop_igp_metric = false;
        self.disable_best_path_selection = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouteSelectionOptionsState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteSelectionOptionsState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RouteSelectionOptions {
    // message fields
    pub config: ::protobuf::SingularPtrField<RouteSelectionOptionsConfig>,
    pub state: ::protobuf::SingularPtrField<RouteSelectionOptionsState>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RouteSelectionOptions {
    fn default() -> &'a RouteSelectionOptions {
        <RouteSelectionOptions as ::protobuf::Message>::default_instance()
    }
}

impl RouteSelectionOptions {
    pub fn new() -> RouteSelectionOptions {
        ::std::default::Default::default()
    }

    // .gobgpapi.RouteSelectionOptionsConfig config = 1;


    pub fn get_config(&self) -> &RouteSelectionOptionsConfig {
        self.config.as_ref().unwrap_or_else(|| RouteSelectionOptionsConfig::default_instance())
    }
    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    pub fn has_config(&self) -> bool {
        self.config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: RouteSelectionOptionsConfig) {
        self.config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config(&mut self) -> &mut RouteSelectionOptionsConfig {
        if self.config.is_none() {
            self.config.set_default();
        }
        self.config.as_mut().unwrap()
    }

    // Take field
    pub fn take_config(&mut self) -> RouteSelectionOptionsConfig {
        self.config.take().unwrap_or_else(|| RouteSelectionOptionsConfig::new())
    }

    // .gobgpapi.RouteSelectionOptionsState state = 2;


    pub fn get_state(&self) -> &RouteSelectionOptionsState {
        self.state.as_ref().unwrap_or_else(|| RouteSelectionOptionsState::default_instance())
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: RouteSelectionOptionsState) {
        self.state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut RouteSelectionOptionsState {
        if self.state.is_none() {
            self.state.set_default();
        }
        self.state.as_mut().unwrap()
    }

    // Take field
    pub fn take_state(&mut self) -> RouteSelectionOptionsState {
        self.state.take().unwrap_or_else(|| RouteSelectionOptionsState::new())
    }
}

impl ::protobuf::Message for RouteSelectionOptions {
    fn is_initialized(&self) -> bool {
        for v in &self.config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.state {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.config)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.state)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.config.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.state.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouteSelectionOptions {
        RouteSelectionOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RouteSelectionOptionsConfig>>(
                    "config",
                    |m: &RouteSelectionOptions| { &m.config },
                    |m: &mut RouteSelectionOptions| { &mut m.config },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RouteSelectionOptionsState>>(
                    "state",
                    |m: &RouteSelectionOptions| { &m.state },
                    |m: &mut RouteSelectionOptions| { &mut m.state },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RouteSelectionOptions>(
                    "RouteSelectionOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RouteSelectionOptions {
        static mut instance: ::protobuf::lazy::Lazy<RouteSelectionOptions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RouteSelectionOptions,
        };
        unsafe {
            instance.get(RouteSelectionOptions::new)
        }
    }
}

impl ::protobuf::Clear for RouteSelectionOptions {
    fn clear(&mut self) {
        self.config.clear();
        self.state.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouteSelectionOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteSelectionOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UseMultiplePathsConfig {
    // message fields
    pub enabled: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UseMultiplePathsConfig {
    fn default() -> &'a UseMultiplePathsConfig {
        <UseMultiplePathsConfig as ::protobuf::Message>::default_instance()
    }
}

impl UseMultiplePathsConfig {
    pub fn new() -> UseMultiplePathsConfig {
        ::std::default::Default::default()
    }

    // bool enabled = 1;


    pub fn get_enabled(&self) -> bool {
        self.enabled
    }
    pub fn clear_enabled(&mut self) {
        self.enabled = false;
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: bool) {
        self.enabled = v;
    }
}

impl ::protobuf::Message for UseMultiplePathsConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enabled = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.enabled != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.enabled != false {
            os.write_bool(1, self.enabled)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UseMultiplePathsConfig {
        UseMultiplePathsConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "enabled",
                    |m: &UseMultiplePathsConfig| { &m.enabled },
                    |m: &mut UseMultiplePathsConfig| { &mut m.enabled },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UseMultiplePathsConfig>(
                    "UseMultiplePathsConfig",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UseMultiplePathsConfig {
        static mut instance: ::protobuf::lazy::Lazy<UseMultiplePathsConfig> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UseMultiplePathsConfig,
        };
        unsafe {
            instance.get(UseMultiplePathsConfig::new)
        }
    }
}

impl ::protobuf::Clear for UseMultiplePathsConfig {
    fn clear(&mut self) {
        self.enabled = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UseMultiplePathsConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UseMultiplePathsConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UseMultiplePathsState {
    // message fields
    pub enabled: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UseMultiplePathsState {
    fn default() -> &'a UseMultiplePathsState {
        <UseMultiplePathsState as ::protobuf::Message>::default_instance()
    }
}

impl UseMultiplePathsState {
    pub fn new() -> UseMultiplePathsState {
        ::std::default::Default::default()
    }

    // bool enabled = 1;


    pub fn get_enabled(&self) -> bool {
        self.enabled
    }
    pub fn clear_enabled(&mut self) {
        self.enabled = false;
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: bool) {
        self.enabled = v;
    }
}

impl ::protobuf::Message for UseMultiplePathsState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enabled = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.enabled != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.enabled != false {
            os.write_bool(1, self.enabled)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UseMultiplePathsState {
        UseMultiplePathsState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "enabled",
                    |m: &UseMultiplePathsState| { &m.enabled },
                    |m: &mut UseMultiplePathsState| { &mut m.enabled },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UseMultiplePathsState>(
                    "UseMultiplePathsState",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UseMultiplePathsState {
        static mut instance: ::protobuf::lazy::Lazy<UseMultiplePathsState> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UseMultiplePathsState,
        };
        unsafe {
            instance.get(UseMultiplePathsState::new)
        }
    }
}

impl ::protobuf::Clear for UseMultiplePathsState {
    fn clear(&mut self) {
        self.enabled = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UseMultiplePathsState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UseMultiplePathsState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EbgpConfig {
    // message fields
    pub allow_multiple_as: bool,
    pub maximum_paths: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EbgpConfig {
    fn default() -> &'a EbgpConfig {
        <EbgpConfig as ::protobuf::Message>::default_instance()
    }
}

impl EbgpConfig {
    pub fn new() -> EbgpConfig {
        ::std::default::Default::default()
    }

    // bool allow_multiple_as = 1;


    pub fn get_allow_multiple_as(&self) -> bool {
        self.allow_multiple_as
    }
    pub fn clear_allow_multiple_as(&mut self) {
        self.allow_multiple_as = false;
    }

    // Param is passed by value, moved
    pub fn set_allow_multiple_as(&mut self, v: bool) {
        self.allow_multiple_as = v;
    }

    // uint32 maximum_paths = 2;


    pub fn get_maximum_paths(&self) -> u32 {
        self.maximum_paths
    }
    pub fn clear_maximum_paths(&mut self) {
        self.maximum_paths = 0;
    }

    // Param is passed by value, moved
    pub fn set_maximum_paths(&mut self, v: u32) {
        self.maximum_paths = v;
    }
}

impl ::protobuf::Message for EbgpConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.allow_multiple_as = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.maximum_paths = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.allow_multiple_as != false {
            my_size += 2;
        }
        if self.maximum_paths != 0 {
            my_size += ::protobuf::rt::value_size(2, self.maximum_paths, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.allow_multiple_as != false {
            os.write_bool(1, self.allow_multiple_as)?;
        }
        if self.maximum_paths != 0 {
            os.write_uint32(2, self.maximum_paths)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EbgpConfig {
        EbgpConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "allow_multiple_as",
                    |m: &EbgpConfig| { &m.allow_multiple_as },
                    |m: &mut EbgpConfig| { &mut m.allow_multiple_as },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "maximum_paths",
                    |m: &EbgpConfig| { &m.maximum_paths },
                    |m: &mut EbgpConfig| { &mut m.maximum_paths },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EbgpConfig>(
                    "EbgpConfig",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EbgpConfig {
        static mut instance: ::protobuf::lazy::Lazy<EbgpConfig> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EbgpConfig,
        };
        unsafe {
            instance.get(EbgpConfig::new)
        }
    }
}

impl ::protobuf::Clear for EbgpConfig {
    fn clear(&mut self) {
        self.allow_multiple_as = false;
        self.maximum_paths = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EbgpConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EbgpConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EbgpState {
    // message fields
    pub allow_multiple_as: bool,
    pub maximum_paths: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EbgpState {
    fn default() -> &'a EbgpState {
        <EbgpState as ::protobuf::Message>::default_instance()
    }
}

impl EbgpState {
    pub fn new() -> EbgpState {
        ::std::default::Default::default()
    }

    // bool allow_multiple_as = 1;


    pub fn get_allow_multiple_as(&self) -> bool {
        self.allow_multiple_as
    }
    pub fn clear_allow_multiple_as(&mut self) {
        self.allow_multiple_as = false;
    }

    // Param is passed by value, moved
    pub fn set_allow_multiple_as(&mut self, v: bool) {
        self.allow_multiple_as = v;
    }

    // uint32 maximum_paths = 2;


    pub fn get_maximum_paths(&self) -> u32 {
        self.maximum_paths
    }
    pub fn clear_maximum_paths(&mut self) {
        self.maximum_paths = 0;
    }

    // Param is passed by value, moved
    pub fn set_maximum_paths(&mut self, v: u32) {
        self.maximum_paths = v;
    }
}

impl ::protobuf::Message for EbgpState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.allow_multiple_as = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.maximum_paths = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.allow_multiple_as != false {
            my_size += 2;
        }
        if self.maximum_paths != 0 {
            my_size += ::protobuf::rt::value_size(2, self.maximum_paths, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.allow_multiple_as != false {
            os.write_bool(1, self.allow_multiple_as)?;
        }
        if self.maximum_paths != 0 {
            os.write_uint32(2, self.maximum_paths)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EbgpState {
        EbgpState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "allow_multiple_as",
                    |m: &EbgpState| { &m.allow_multiple_as },
                    |m: &mut EbgpState| { &mut m.allow_multiple_as },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "maximum_paths",
                    |m: &EbgpState| { &m.maximum_paths },
                    |m: &mut EbgpState| { &mut m.maximum_paths },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EbgpState>(
                    "EbgpState",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EbgpState {
        static mut instance: ::protobuf::lazy::Lazy<EbgpState> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EbgpState,
        };
        unsafe {
            instance.get(EbgpState::new)
        }
    }
}

impl ::protobuf::Clear for EbgpState {
    fn clear(&mut self) {
        self.allow_multiple_as = false;
        self.maximum_paths = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EbgpState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EbgpState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Ebgp {
    // message fields
    pub config: ::protobuf::SingularPtrField<EbgpConfig>,
    pub state: ::protobuf::SingularPtrField<EbgpState>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Ebgp {
    fn default() -> &'a Ebgp {
        <Ebgp as ::protobuf::Message>::default_instance()
    }
}

impl Ebgp {
    pub fn new() -> Ebgp {
        ::std::default::Default::default()
    }

    // .gobgpapi.EbgpConfig config = 1;


    pub fn get_config(&self) -> &EbgpConfig {
        self.config.as_ref().unwrap_or_else(|| EbgpConfig::default_instance())
    }
    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    pub fn has_config(&self) -> bool {
        self.config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: EbgpConfig) {
        self.config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config(&mut self) -> &mut EbgpConfig {
        if self.config.is_none() {
            self.config.set_default();
        }
        self.config.as_mut().unwrap()
    }

    // Take field
    pub fn take_config(&mut self) -> EbgpConfig {
        self.config.take().unwrap_or_else(|| EbgpConfig::new())
    }

    // .gobgpapi.EbgpState state = 2;


    pub fn get_state(&self) -> &EbgpState {
        self.state.as_ref().unwrap_or_else(|| EbgpState::default_instance())
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: EbgpState) {
        self.state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut EbgpState {
        if self.state.is_none() {
            self.state.set_default();
        }
        self.state.as_mut().unwrap()
    }

    // Take field
    pub fn take_state(&mut self) -> EbgpState {
        self.state.take().unwrap_or_else(|| EbgpState::new())
    }
}

impl ::protobuf::Message for Ebgp {
    fn is_initialized(&self) -> bool {
        for v in &self.config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.state {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.config)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.state)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.config.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.state.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Ebgp {
        Ebgp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EbgpConfig>>(
                    "config",
                    |m: &Ebgp| { &m.config },
                    |m: &mut Ebgp| { &mut m.config },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EbgpState>>(
                    "state",
                    |m: &Ebgp| { &m.state },
                    |m: &mut Ebgp| { &mut m.state },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Ebgp>(
                    "Ebgp",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Ebgp {
        static mut instance: ::protobuf::lazy::Lazy<Ebgp> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Ebgp,
        };
        unsafe {
            instance.get(Ebgp::new)
        }
    }
}

impl ::protobuf::Clear for Ebgp {
    fn clear(&mut self) {
        self.config.clear();
        self.state.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Ebgp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Ebgp {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IbgpConfig {
    // message fields
    pub maximum_paths: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IbgpConfig {
    fn default() -> &'a IbgpConfig {
        <IbgpConfig as ::protobuf::Message>::default_instance()
    }
}

impl IbgpConfig {
    pub fn new() -> IbgpConfig {
        ::std::default::Default::default()
    }

    // uint32 maximum_paths = 1;


    pub fn get_maximum_paths(&self) -> u32 {
        self.maximum_paths
    }
    pub fn clear_maximum_paths(&mut self) {
        self.maximum_paths = 0;
    }

    // Param is passed by value, moved
    pub fn set_maximum_paths(&mut self, v: u32) {
        self.maximum_paths = v;
    }
}

impl ::protobuf::Message for IbgpConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.maximum_paths = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.maximum_paths != 0 {
            my_size += ::protobuf::rt::value_size(1, self.maximum_paths, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.maximum_paths != 0 {
            os.write_uint32(1, self.maximum_paths)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IbgpConfig {
        IbgpConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "maximum_paths",
                    |m: &IbgpConfig| { &m.maximum_paths },
                    |m: &mut IbgpConfig| { &mut m.maximum_paths },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<IbgpConfig>(
                    "IbgpConfig",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static IbgpConfig {
        static mut instance: ::protobuf::lazy::Lazy<IbgpConfig> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IbgpConfig,
        };
        unsafe {
            instance.get(IbgpConfig::new)
        }
    }
}

impl ::protobuf::Clear for IbgpConfig {
    fn clear(&mut self) {
        self.maximum_paths = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IbgpConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IbgpConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IbgpState {
    // message fields
    pub maximum_paths: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IbgpState {
    fn default() -> &'a IbgpState {
        <IbgpState as ::protobuf::Message>::default_instance()
    }
}

impl IbgpState {
    pub fn new() -> IbgpState {
        ::std::default::Default::default()
    }

    // uint32 maximum_paths = 1;


    pub fn get_maximum_paths(&self) -> u32 {
        self.maximum_paths
    }
    pub fn clear_maximum_paths(&mut self) {
        self.maximum_paths = 0;
    }

    // Param is passed by value, moved
    pub fn set_maximum_paths(&mut self, v: u32) {
        self.maximum_paths = v;
    }
}

impl ::protobuf::Message for IbgpState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.maximum_paths = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.maximum_paths != 0 {
            my_size += ::protobuf::rt::value_size(1, self.maximum_paths, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.maximum_paths != 0 {
            os.write_uint32(1, self.maximum_paths)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IbgpState {
        IbgpState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "maximum_paths",
                    |m: &IbgpState| { &m.maximum_paths },
                    |m: &mut IbgpState| { &mut m.maximum_paths },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<IbgpState>(
                    "IbgpState",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static IbgpState {
        static mut instance: ::protobuf::lazy::Lazy<IbgpState> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IbgpState,
        };
        unsafe {
            instance.get(IbgpState::new)
        }
    }
}

impl ::protobuf::Clear for IbgpState {
    fn clear(&mut self) {
        self.maximum_paths = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IbgpState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IbgpState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Ibgp {
    // message fields
    pub config: ::protobuf::SingularPtrField<IbgpConfig>,
    pub state: ::protobuf::SingularPtrField<IbgpState>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Ibgp {
    fn default() -> &'a Ibgp {
        <Ibgp as ::protobuf::Message>::default_instance()
    }
}

impl Ibgp {
    pub fn new() -> Ibgp {
        ::std::default::Default::default()
    }

    // .gobgpapi.IbgpConfig config = 1;


    pub fn get_config(&self) -> &IbgpConfig {
        self.config.as_ref().unwrap_or_else(|| IbgpConfig::default_instance())
    }
    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    pub fn has_config(&self) -> bool {
        self.config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: IbgpConfig) {
        self.config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config(&mut self) -> &mut IbgpConfig {
        if self.config.is_none() {
            self.config.set_default();
        }
        self.config.as_mut().unwrap()
    }

    // Take field
    pub fn take_config(&mut self) -> IbgpConfig {
        self.config.take().unwrap_or_else(|| IbgpConfig::new())
    }

    // .gobgpapi.IbgpState state = 2;


    pub fn get_state(&self) -> &IbgpState {
        self.state.as_ref().unwrap_or_else(|| IbgpState::default_instance())
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: IbgpState) {
        self.state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut IbgpState {
        if self.state.is_none() {
            self.state.set_default();
        }
        self.state.as_mut().unwrap()
    }

    // Take field
    pub fn take_state(&mut self) -> IbgpState {
        self.state.take().unwrap_or_else(|| IbgpState::new())
    }
}

impl ::protobuf::Message for Ibgp {
    fn is_initialized(&self) -> bool {
        for v in &self.config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.state {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.config)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.state)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.config.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.state.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Ibgp {
        Ibgp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IbgpConfig>>(
                    "config",
                    |m: &Ibgp| { &m.config },
                    |m: &mut Ibgp| { &mut m.config },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IbgpState>>(
                    "state",
                    |m: &Ibgp| { &m.state },
                    |m: &mut Ibgp| { &mut m.state },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Ibgp>(
                    "Ibgp",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Ibgp {
        static mut instance: ::protobuf::lazy::Lazy<Ibgp> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Ibgp,
        };
        unsafe {
            instance.get(Ibgp::new)
        }
    }
}

impl ::protobuf::Clear for Ibgp {
    fn clear(&mut self) {
        self.config.clear();
        self.state.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Ibgp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Ibgp {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UseMultiplePaths {
    // message fields
    pub config: ::protobuf::SingularPtrField<UseMultiplePathsConfig>,
    pub state: ::protobuf::SingularPtrField<UseMultiplePathsState>,
    pub ebgp: ::protobuf::SingularPtrField<Ebgp>,
    pub ibgp: ::protobuf::SingularPtrField<Ibgp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UseMultiplePaths {
    fn default() -> &'a UseMultiplePaths {
        <UseMultiplePaths as ::protobuf::Message>::default_instance()
    }
}

impl UseMultiplePaths {
    pub fn new() -> UseMultiplePaths {
        ::std::default::Default::default()
    }

    // .gobgpapi.UseMultiplePathsConfig config = 1;


    pub fn get_config(&self) -> &UseMultiplePathsConfig {
        self.config.as_ref().unwrap_or_else(|| UseMultiplePathsConfig::default_instance())
    }
    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    pub fn has_config(&self) -> bool {
        self.config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: UseMultiplePathsConfig) {
        self.config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config(&mut self) -> &mut UseMultiplePathsConfig {
        if self.config.is_none() {
            self.config.set_default();
        }
        self.config.as_mut().unwrap()
    }

    // Take field
    pub fn take_config(&mut self) -> UseMultiplePathsConfig {
        self.config.take().unwrap_or_else(|| UseMultiplePathsConfig::new())
    }

    // .gobgpapi.UseMultiplePathsState state = 2;


    pub fn get_state(&self) -> &UseMultiplePathsState {
        self.state.as_ref().unwrap_or_else(|| UseMultiplePathsState::default_instance())
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: UseMultiplePathsState) {
        self.state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut UseMultiplePathsState {
        if self.state.is_none() {
            self.state.set_default();
        }
        self.state.as_mut().unwrap()
    }

    // Take field
    pub fn take_state(&mut self) -> UseMultiplePathsState {
        self.state.take().unwrap_or_else(|| UseMultiplePathsState::new())
    }

    // .gobgpapi.Ebgp ebgp = 3;


    pub fn get_ebgp(&self) -> &Ebgp {
        self.ebgp.as_ref().unwrap_or_else(|| Ebgp::default_instance())
    }
    pub fn clear_ebgp(&mut self) {
        self.ebgp.clear();
    }

    pub fn has_ebgp(&self) -> bool {
        self.ebgp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ebgp(&mut self, v: Ebgp) {
        self.ebgp = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ebgp(&mut self) -> &mut Ebgp {
        if self.ebgp.is_none() {
            self.ebgp.set_default();
        }
        self.ebgp.as_mut().unwrap()
    }

    // Take field
    pub fn take_ebgp(&mut self) -> Ebgp {
        self.ebgp.take().unwrap_or_else(|| Ebgp::new())
    }

    // .gobgpapi.Ibgp ibgp = 4;


    pub fn get_ibgp(&self) -> &Ibgp {
        self.ibgp.as_ref().unwrap_or_else(|| Ibgp::default_instance())
    }
    pub fn clear_ibgp(&mut self) {
        self.ibgp.clear();
    }

    pub fn has_ibgp(&self) -> bool {
        self.ibgp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ibgp(&mut self, v: Ibgp) {
        self.ibgp = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ibgp(&mut self) -> &mut Ibgp {
        if self.ibgp.is_none() {
            self.ibgp.set_default();
        }
        self.ibgp.as_mut().unwrap()
    }

    // Take field
    pub fn take_ibgp(&mut self) -> Ibgp {
        self.ibgp.take().unwrap_or_else(|| Ibgp::new())
    }
}

impl ::protobuf::Message for UseMultiplePaths {
    fn is_initialized(&self) -> bool {
        for v in &self.config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.state {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ebgp {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ibgp {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.config)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.state)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ebgp)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ibgp)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ebgp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ibgp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.config.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.state.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ebgp.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ibgp.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UseMultiplePaths {
        UseMultiplePaths::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UseMultiplePathsConfig>>(
                    "config",
                    |m: &UseMultiplePaths| { &m.config },
                    |m: &mut UseMultiplePaths| { &mut m.config },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UseMultiplePathsState>>(
                    "state",
                    |m: &UseMultiplePaths| { &m.state },
                    |m: &mut UseMultiplePaths| { &mut m.state },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Ebgp>>(
                    "ebgp",
                    |m: &UseMultiplePaths| { &m.ebgp },
                    |m: &mut UseMultiplePaths| { &mut m.ebgp },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Ibgp>>(
                    "ibgp",
                    |m: &UseMultiplePaths| { &m.ibgp },
                    |m: &mut UseMultiplePaths| { &mut m.ibgp },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UseMultiplePaths>(
                    "UseMultiplePaths",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UseMultiplePaths {
        static mut instance: ::protobuf::lazy::Lazy<UseMultiplePaths> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UseMultiplePaths,
        };
        unsafe {
            instance.get(UseMultiplePaths::new)
        }
    }
}

impl ::protobuf::Clear for UseMultiplePaths {
    fn clear(&mut self) {
        self.config.clear();
        self.state.clear();
        self.ebgp.clear();
        self.ibgp.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UseMultiplePaths {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UseMultiplePaths {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RouteTargetMembershipConfig {
    // message fields
    pub deferral_time: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RouteTargetMembershipConfig {
    fn default() -> &'a RouteTargetMembershipConfig {
        <RouteTargetMembershipConfig as ::protobuf::Message>::default_instance()
    }
}

impl RouteTargetMembershipConfig {
    pub fn new() -> RouteTargetMembershipConfig {
        ::std::default::Default::default()
    }

    // uint32 deferral_time = 1;


    pub fn get_deferral_time(&self) -> u32 {
        self.deferral_time
    }
    pub fn clear_deferral_time(&mut self) {
        self.deferral_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_deferral_time(&mut self, v: u32) {
        self.deferral_time = v;
    }
}

impl ::protobuf::Message for RouteTargetMembershipConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.deferral_time = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.deferral_time != 0 {
            my_size += ::protobuf::rt::value_size(1, self.deferral_time, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.deferral_time != 0 {
            os.write_uint32(1, self.deferral_time)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouteTargetMembershipConfig {
        RouteTargetMembershipConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "deferral_time",
                    |m: &RouteTargetMembershipConfig| { &m.deferral_time },
                    |m: &mut RouteTargetMembershipConfig| { &mut m.deferral_time },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RouteTargetMembershipConfig>(
                    "RouteTargetMembershipConfig",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RouteTargetMembershipConfig {
        static mut instance: ::protobuf::lazy::Lazy<RouteTargetMembershipConfig> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RouteTargetMembershipConfig,
        };
        unsafe {
            instance.get(RouteTargetMembershipConfig::new)
        }
    }
}

impl ::protobuf::Clear for RouteTargetMembershipConfig {
    fn clear(&mut self) {
        self.deferral_time = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouteTargetMembershipConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteTargetMembershipConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RouteTargetMembershipState {
    // message fields
    pub deferral_time: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RouteTargetMembershipState {
    fn default() -> &'a RouteTargetMembershipState {
        <RouteTargetMembershipState as ::protobuf::Message>::default_instance()
    }
}

impl RouteTargetMembershipState {
    pub fn new() -> RouteTargetMembershipState {
        ::std::default::Default::default()
    }

    // uint32 deferral_time = 1;


    pub fn get_deferral_time(&self) -> u32 {
        self.deferral_time
    }
    pub fn clear_deferral_time(&mut self) {
        self.deferral_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_deferral_time(&mut self, v: u32) {
        self.deferral_time = v;
    }
}

impl ::protobuf::Message for RouteTargetMembershipState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.deferral_time = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.deferral_time != 0 {
            my_size += ::protobuf::rt::value_size(1, self.deferral_time, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.deferral_time != 0 {
            os.write_uint32(1, self.deferral_time)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouteTargetMembershipState {
        RouteTargetMembershipState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "deferral_time",
                    |m: &RouteTargetMembershipState| { &m.deferral_time },
                    |m: &mut RouteTargetMembershipState| { &mut m.deferral_time },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RouteTargetMembershipState>(
                    "RouteTargetMembershipState",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RouteTargetMembershipState {
        static mut instance: ::protobuf::lazy::Lazy<RouteTargetMembershipState> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RouteTargetMembershipState,
        };
        unsafe {
            instance.get(RouteTargetMembershipState::new)
        }
    }
}

impl ::protobuf::Clear for RouteTargetMembershipState {
    fn clear(&mut self) {
        self.deferral_time = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouteTargetMembershipState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteTargetMembershipState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RouteTargetMembership {
    // message fields
    pub config: ::protobuf::SingularPtrField<RouteTargetMembershipConfig>,
    pub state: ::protobuf::SingularPtrField<RouteTargetMembershipState>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RouteTargetMembership {
    fn default() -> &'a RouteTargetMembership {
        <RouteTargetMembership as ::protobuf::Message>::default_instance()
    }
}

impl RouteTargetMembership {
    pub fn new() -> RouteTargetMembership {
        ::std::default::Default::default()
    }

    // .gobgpapi.RouteTargetMembershipConfig config = 1;


    pub fn get_config(&self) -> &RouteTargetMembershipConfig {
        self.config.as_ref().unwrap_or_else(|| RouteTargetMembershipConfig::default_instance())
    }
    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    pub fn has_config(&self) -> bool {
        self.config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: RouteTargetMembershipConfig) {
        self.config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config(&mut self) -> &mut RouteTargetMembershipConfig {
        if self.config.is_none() {
            self.config.set_default();
        }
        self.config.as_mut().unwrap()
    }

    // Take field
    pub fn take_config(&mut self) -> RouteTargetMembershipConfig {
        self.config.take().unwrap_or_else(|| RouteTargetMembershipConfig::new())
    }

    // .gobgpapi.RouteTargetMembershipState state = 2;


    pub fn get_state(&self) -> &RouteTargetMembershipState {
        self.state.as_ref().unwrap_or_else(|| RouteTargetMembershipState::default_instance())
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: RouteTargetMembershipState) {
        self.state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut RouteTargetMembershipState {
        if self.state.is_none() {
            self.state.set_default();
        }
        self.state.as_mut().unwrap()
    }

    // Take field
    pub fn take_state(&mut self) -> RouteTargetMembershipState {
        self.state.take().unwrap_or_else(|| RouteTargetMembershipState::new())
    }
}

impl ::protobuf::Message for RouteTargetMembership {
    fn is_initialized(&self) -> bool {
        for v in &self.config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.state {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.config)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.state)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.config.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.state.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouteTargetMembership {
        RouteTargetMembership::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RouteTargetMembershipConfig>>(
                    "config",
                    |m: &RouteTargetMembership| { &m.config },
                    |m: &mut RouteTargetMembership| { &mut m.config },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RouteTargetMembershipState>>(
                    "state",
                    |m: &RouteTargetMembership| { &m.state },
                    |m: &mut RouteTargetMembership| { &mut m.state },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RouteTargetMembership>(
                    "RouteTargetMembership",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RouteTargetMembership {
        static mut instance: ::protobuf::lazy::Lazy<RouteTargetMembership> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RouteTargetMembership,
        };
        unsafe {
            instance.get(RouteTargetMembership::new)
        }
    }
}

impl ::protobuf::Clear for RouteTargetMembership {
    fn clear(&mut self) {
        self.config.clear();
        self.state.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouteTargetMembership {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteTargetMembership {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LongLivedGracefulRestartConfig {
    // message fields
    pub enabled: bool,
    pub restart_time: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LongLivedGracefulRestartConfig {
    fn default() -> &'a LongLivedGracefulRestartConfig {
        <LongLivedGracefulRestartConfig as ::protobuf::Message>::default_instance()
    }
}

impl LongLivedGracefulRestartConfig {
    pub fn new() -> LongLivedGracefulRestartConfig {
        ::std::default::Default::default()
    }

    // bool enabled = 1;


    pub fn get_enabled(&self) -> bool {
        self.enabled
    }
    pub fn clear_enabled(&mut self) {
        self.enabled = false;
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: bool) {
        self.enabled = v;
    }

    // uint32 restart_time = 2;


    pub fn get_restart_time(&self) -> u32 {
        self.restart_time
    }
    pub fn clear_restart_time(&mut self) {
        self.restart_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_restart_time(&mut self, v: u32) {
        self.restart_time = v;
    }
}

impl ::protobuf::Message for LongLivedGracefulRestartConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enabled = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.restart_time = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.enabled != false {
            my_size += 2;
        }
        if self.restart_time != 0 {
            my_size += ::protobuf::rt::value_size(2, self.restart_time, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.enabled != false {
            os.write_bool(1, self.enabled)?;
        }
        if self.restart_time != 0 {
            os.write_uint32(2, self.restart_time)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LongLivedGracefulRestartConfig {
        LongLivedGracefulRestartConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "enabled",
                    |m: &LongLivedGracefulRestartConfig| { &m.enabled },
                    |m: &mut LongLivedGracefulRestartConfig| { &mut m.enabled },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "restart_time",
                    |m: &LongLivedGracefulRestartConfig| { &m.restart_time },
                    |m: &mut LongLivedGracefulRestartConfig| { &mut m.restart_time },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LongLivedGracefulRestartConfig>(
                    "LongLivedGracefulRestartConfig",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LongLivedGracefulRestartConfig {
        static mut instance: ::protobuf::lazy::Lazy<LongLivedGracefulRestartConfig> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LongLivedGracefulRestartConfig,
        };
        unsafe {
            instance.get(LongLivedGracefulRestartConfig::new)
        }
    }
}

impl ::protobuf::Clear for LongLivedGracefulRestartConfig {
    fn clear(&mut self) {
        self.enabled = false;
        self.restart_time = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LongLivedGracefulRestartConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LongLivedGracefulRestartConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LongLivedGracefulRestartState {
    // message fields
    pub enabled: bool,
    pub received: bool,
    pub advertised: bool,
    pub peer_restart_time: u32,
    pub peer_restart_timer_expired: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LongLivedGracefulRestartState {
    fn default() -> &'a LongLivedGracefulRestartState {
        <LongLivedGracefulRestartState as ::protobuf::Message>::default_instance()
    }
}

impl LongLivedGracefulRestartState {
    pub fn new() -> LongLivedGracefulRestartState {
        ::std::default::Default::default()
    }

    // bool enabled = 1;


    pub fn get_enabled(&self) -> bool {
        self.enabled
    }
    pub fn clear_enabled(&mut self) {
        self.enabled = false;
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: bool) {
        self.enabled = v;
    }

    // bool received = 2;


    pub fn get_received(&self) -> bool {
        self.received
    }
    pub fn clear_received(&mut self) {
        self.received = false;
    }

    // Param is passed by value, moved
    pub fn set_received(&mut self, v: bool) {
        self.received = v;
    }

    // bool advertised = 3;


    pub fn get_advertised(&self) -> bool {
        self.advertised
    }
    pub fn clear_advertised(&mut self) {
        self.advertised = false;
    }

    // Param is passed by value, moved
    pub fn set_advertised(&mut self, v: bool) {
        self.advertised = v;
    }

    // uint32 peer_restart_time = 4;


    pub fn get_peer_restart_time(&self) -> u32 {
        self.peer_restart_time
    }
    pub fn clear_peer_restart_time(&mut self) {
        self.peer_restart_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_peer_restart_time(&mut self, v: u32) {
        self.peer_restart_time = v;
    }

    // bool peer_restart_timer_expired = 5;


    pub fn get_peer_restart_timer_expired(&self) -> bool {
        self.peer_restart_timer_expired
    }
    pub fn clear_peer_restart_timer_expired(&mut self) {
        self.peer_restart_timer_expired = false;
    }

    // Param is passed by value, moved
    pub fn set_peer_restart_timer_expired(&mut self, v: bool) {
        self.peer_restart_timer_expired = v;
    }
}

impl ::protobuf::Message for LongLivedGracefulRestartState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enabled = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.received = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.advertised = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.peer_restart_time = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.peer_restart_timer_expired = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.enabled != false {
            my_size += 2;
        }
        if self.received != false {
            my_size += 2;
        }
        if self.advertised != false {
            my_size += 2;
        }
        if self.peer_restart_time != 0 {
            my_size += ::protobuf::rt::value_size(4, self.peer_restart_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.peer_restart_timer_expired != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.enabled != false {
            os.write_bool(1, self.enabled)?;
        }
        if self.received != false {
            os.write_bool(2, self.received)?;
        }
        if self.advertised != false {
            os.write_bool(3, self.advertised)?;
        }
        if self.peer_restart_time != 0 {
            os.write_uint32(4, self.peer_restart_time)?;
        }
        if self.peer_restart_timer_expired != false {
            os.write_bool(5, self.peer_restart_timer_expired)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LongLivedGracefulRestartState {
        LongLivedGracefulRestartState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "enabled",
                    |m: &LongLivedGracefulRestartState| { &m.enabled },
                    |m: &mut LongLivedGracefulRestartState| { &mut m.enabled },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "received",
                    |m: &LongLivedGracefulRestartState| { &m.received },
                    |m: &mut LongLivedGracefulRestartState| { &mut m.received },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "advertised",
                    |m: &LongLivedGracefulRestartState| { &m.advertised },
                    |m: &mut LongLivedGracefulRestartState| { &mut m.advertised },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "peer_restart_time",
                    |m: &LongLivedGracefulRestartState| { &m.peer_restart_time },
                    |m: &mut LongLivedGracefulRestartState| { &mut m.peer_restart_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "peer_restart_timer_expired",
                    |m: &LongLivedGracefulRestartState| { &m.peer_restart_timer_expired },
                    |m: &mut LongLivedGracefulRestartState| { &mut m.peer_restart_timer_expired },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LongLivedGracefulRestartState>(
                    "LongLivedGracefulRestartState",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LongLivedGracefulRestartState {
        static mut instance: ::protobuf::lazy::Lazy<LongLivedGracefulRestartState> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LongLivedGracefulRestartState,
        };
        unsafe {
            instance.get(LongLivedGracefulRestartState::new)
        }
    }
}

impl ::protobuf::Clear for LongLivedGracefulRestartState {
    fn clear(&mut self) {
        self.enabled = false;
        self.received = false;
        self.advertised = false;
        self.peer_restart_time = 0;
        self.peer_restart_timer_expired = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LongLivedGracefulRestartState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LongLivedGracefulRestartState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LongLivedGracefulRestart {
    // message fields
    pub config: ::protobuf::SingularPtrField<LongLivedGracefulRestartConfig>,
    pub state: ::protobuf::SingularPtrField<LongLivedGracefulRestartState>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LongLivedGracefulRestart {
    fn default() -> &'a LongLivedGracefulRestart {
        <LongLivedGracefulRestart as ::protobuf::Message>::default_instance()
    }
}

impl LongLivedGracefulRestart {
    pub fn new() -> LongLivedGracefulRestart {
        ::std::default::Default::default()
    }

    // .gobgpapi.LongLivedGracefulRestartConfig config = 1;


    pub fn get_config(&self) -> &LongLivedGracefulRestartConfig {
        self.config.as_ref().unwrap_or_else(|| LongLivedGracefulRestartConfig::default_instance())
    }
    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    pub fn has_config(&self) -> bool {
        self.config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: LongLivedGracefulRestartConfig) {
        self.config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config(&mut self) -> &mut LongLivedGracefulRestartConfig {
        if self.config.is_none() {
            self.config.set_default();
        }
        self.config.as_mut().unwrap()
    }

    // Take field
    pub fn take_config(&mut self) -> LongLivedGracefulRestartConfig {
        self.config.take().unwrap_or_else(|| LongLivedGracefulRestartConfig::new())
    }

    // .gobgpapi.LongLivedGracefulRestartState state = 2;


    pub fn get_state(&self) -> &LongLivedGracefulRestartState {
        self.state.as_ref().unwrap_or_else(|| LongLivedGracefulRestartState::default_instance())
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: LongLivedGracefulRestartState) {
        self.state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut LongLivedGracefulRestartState {
        if self.state.is_none() {
            self.state.set_default();
        }
        self.state.as_mut().unwrap()
    }

    // Take field
    pub fn take_state(&mut self) -> LongLivedGracefulRestartState {
        self.state.take().unwrap_or_else(|| LongLivedGracefulRestartState::new())
    }
}

impl ::protobuf::Message for LongLivedGracefulRestart {
    fn is_initialized(&self) -> bool {
        for v in &self.config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.state {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.config)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.state)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.config.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.state.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LongLivedGracefulRestart {
        LongLivedGracefulRestart::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LongLivedGracefulRestartConfig>>(
                    "config",
                    |m: &LongLivedGracefulRestart| { &m.config },
                    |m: &mut LongLivedGracefulRestart| { &mut m.config },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LongLivedGracefulRestartState>>(
                    "state",
                    |m: &LongLivedGracefulRestart| { &m.state },
                    |m: &mut LongLivedGracefulRestart| { &mut m.state },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LongLivedGracefulRestart>(
                    "LongLivedGracefulRestart",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LongLivedGracefulRestart {
        static mut instance: ::protobuf::lazy::Lazy<LongLivedGracefulRestart> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LongLivedGracefulRestart,
        };
        unsafe {
            instance.get(LongLivedGracefulRestart::new)
        }
    }
}

impl ::protobuf::Clear for LongLivedGracefulRestart {
    fn clear(&mut self) {
        self.config.clear();
        self.state.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LongLivedGracefulRestart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LongLivedGracefulRestart {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AfiSafi {
    // message fields
    pub mp_graceful_restart: ::protobuf::SingularPtrField<MpGracefulRestart>,
    pub config: ::protobuf::SingularPtrField<AfiSafiConfig>,
    pub state: ::protobuf::SingularPtrField<AfiSafiState>,
    pub apply_policy: ::protobuf::SingularPtrField<ApplyPolicy>,
    pub route_selection_options: ::protobuf::SingularPtrField<RouteSelectionOptions>,
    pub use_multiple_paths: ::protobuf::SingularPtrField<UseMultiplePaths>,
    pub prefix_limits: ::protobuf::SingularPtrField<PrefixLimit>,
    pub route_target_membership: ::protobuf::SingularPtrField<RouteTargetMembership>,
    pub long_lived_graceful_restart: ::protobuf::SingularPtrField<LongLivedGracefulRestart>,
    pub add_paths: ::protobuf::SingularPtrField<AddPaths>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AfiSafi {
    fn default() -> &'a AfiSafi {
        <AfiSafi as ::protobuf::Message>::default_instance()
    }
}

impl AfiSafi {
    pub fn new() -> AfiSafi {
        ::std::default::Default::default()
    }

    // .gobgpapi.MpGracefulRestart mp_graceful_restart = 1;


    pub fn get_mp_graceful_restart(&self) -> &MpGracefulRestart {
        self.mp_graceful_restart.as_ref().unwrap_or_else(|| MpGracefulRestart::default_instance())
    }
    pub fn clear_mp_graceful_restart(&mut self) {
        self.mp_graceful_restart.clear();
    }

    pub fn has_mp_graceful_restart(&self) -> bool {
        self.mp_graceful_restart.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mp_graceful_restart(&mut self, v: MpGracefulRestart) {
        self.mp_graceful_restart = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mp_graceful_restart(&mut self) -> &mut MpGracefulRestart {
        if self.mp_graceful_restart.is_none() {
            self.mp_graceful_restart.set_default();
        }
        self.mp_graceful_restart.as_mut().unwrap()
    }

    // Take field
    pub fn take_mp_graceful_restart(&mut self) -> MpGracefulRestart {
        self.mp_graceful_restart.take().unwrap_or_else(|| MpGracefulRestart::new())
    }

    // .gobgpapi.AfiSafiConfig config = 2;


    pub fn get_config(&self) -> &AfiSafiConfig {
        self.config.as_ref().unwrap_or_else(|| AfiSafiConfig::default_instance())
    }
    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    pub fn has_config(&self) -> bool {
        self.config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: AfiSafiConfig) {
        self.config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config(&mut self) -> &mut AfiSafiConfig {
        if self.config.is_none() {
            self.config.set_default();
        }
        self.config.as_mut().unwrap()
    }

    // Take field
    pub fn take_config(&mut self) -> AfiSafiConfig {
        self.config.take().unwrap_or_else(|| AfiSafiConfig::new())
    }

    // .gobgpapi.AfiSafiState state = 3;


    pub fn get_state(&self) -> &AfiSafiState {
        self.state.as_ref().unwrap_or_else(|| AfiSafiState::default_instance())
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: AfiSafiState) {
        self.state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut AfiSafiState {
        if self.state.is_none() {
            self.state.set_default();
        }
        self.state.as_mut().unwrap()
    }

    // Take field
    pub fn take_state(&mut self) -> AfiSafiState {
        self.state.take().unwrap_or_else(|| AfiSafiState::new())
    }

    // .gobgpapi.ApplyPolicy apply_policy = 4;


    pub fn get_apply_policy(&self) -> &ApplyPolicy {
        self.apply_policy.as_ref().unwrap_or_else(|| ApplyPolicy::default_instance())
    }
    pub fn clear_apply_policy(&mut self) {
        self.apply_policy.clear();
    }

    pub fn has_apply_policy(&self) -> bool {
        self.apply_policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apply_policy(&mut self, v: ApplyPolicy) {
        self.apply_policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_apply_policy(&mut self) -> &mut ApplyPolicy {
        if self.apply_policy.is_none() {
            self.apply_policy.set_default();
        }
        self.apply_policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_apply_policy(&mut self) -> ApplyPolicy {
        self.apply_policy.take().unwrap_or_else(|| ApplyPolicy::new())
    }

    // .gobgpapi.RouteSelectionOptions route_selection_options = 5;


    pub fn get_route_selection_options(&self) -> &RouteSelectionOptions {
        self.route_selection_options.as_ref().unwrap_or_else(|| RouteSelectionOptions::default_instance())
    }
    pub fn clear_route_selection_options(&mut self) {
        self.route_selection_options.clear();
    }

    pub fn has_route_selection_options(&self) -> bool {
        self.route_selection_options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_route_selection_options(&mut self, v: RouteSelectionOptions) {
        self.route_selection_options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_route_selection_options(&mut self) -> &mut RouteSelectionOptions {
        if self.route_selection_options.is_none() {
            self.route_selection_options.set_default();
        }
        self.route_selection_options.as_mut().unwrap()
    }

    // Take field
    pub fn take_route_selection_options(&mut self) -> RouteSelectionOptions {
        self.route_selection_options.take().unwrap_or_else(|| RouteSelectionOptions::new())
    }

    // .gobgpapi.UseMultiplePaths use_multiple_paths = 6;


    pub fn get_use_multiple_paths(&self) -> &UseMultiplePaths {
        self.use_multiple_paths.as_ref().unwrap_or_else(|| UseMultiplePaths::default_instance())
    }
    pub fn clear_use_multiple_paths(&mut self) {
        self.use_multiple_paths.clear();
    }

    pub fn has_use_multiple_paths(&self) -> bool {
        self.use_multiple_paths.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_multiple_paths(&mut self, v: UseMultiplePaths) {
        self.use_multiple_paths = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_use_multiple_paths(&mut self) -> &mut UseMultiplePaths {
        if self.use_multiple_paths.is_none() {
            self.use_multiple_paths.set_default();
        }
        self.use_multiple_paths.as_mut().unwrap()
    }

    // Take field
    pub fn take_use_multiple_paths(&mut self) -> UseMultiplePaths {
        self.use_multiple_paths.take().unwrap_or_else(|| UseMultiplePaths::new())
    }

    // .gobgpapi.PrefixLimit prefix_limits = 7;


    pub fn get_prefix_limits(&self) -> &PrefixLimit {
        self.prefix_limits.as_ref().unwrap_or_else(|| PrefixLimit::default_instance())
    }
    pub fn clear_prefix_limits(&mut self) {
        self.prefix_limits.clear();
    }

    pub fn has_prefix_limits(&self) -> bool {
        self.prefix_limits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prefix_limits(&mut self, v: PrefixLimit) {
        self.prefix_limits = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prefix_limits(&mut self) -> &mut PrefixLimit {
        if self.prefix_limits.is_none() {
            self.prefix_limits.set_default();
        }
        self.prefix_limits.as_mut().unwrap()
    }

    // Take field
    pub fn take_prefix_limits(&mut self) -> PrefixLimit {
        self.prefix_limits.take().unwrap_or_else(|| PrefixLimit::new())
    }

    // .gobgpapi.RouteTargetMembership route_target_membership = 8;


    pub fn get_route_target_membership(&self) -> &RouteTargetMembership {
        self.route_target_membership.as_ref().unwrap_or_else(|| RouteTargetMembership::default_instance())
    }
    pub fn clear_route_target_membership(&mut self) {
        self.route_target_membership.clear();
    }

    pub fn has_route_target_membership(&self) -> bool {
        self.route_target_membership.is_some()
    }

    // Param is passed by value, moved
    pub fn set_route_target_membership(&mut self, v: RouteTargetMembership) {
        self.route_target_membership = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_route_target_membership(&mut self) -> &mut RouteTargetMembership {
        if self.route_target_membership.is_none() {
            self.route_target_membership.set_default();
        }
        self.route_target_membership.as_mut().unwrap()
    }

    // Take field
    pub fn take_route_target_membership(&mut self) -> RouteTargetMembership {
        self.route_target_membership.take().unwrap_or_else(|| RouteTargetMembership::new())
    }

    // .gobgpapi.LongLivedGracefulRestart long_lived_graceful_restart = 9;


    pub fn get_long_lived_graceful_restart(&self) -> &LongLivedGracefulRestart {
        self.long_lived_graceful_restart.as_ref().unwrap_or_else(|| LongLivedGracefulRestart::default_instance())
    }
    pub fn clear_long_lived_graceful_restart(&mut self) {
        self.long_lived_graceful_restart.clear();
    }

    pub fn has_long_lived_graceful_restart(&self) -> bool {
        self.long_lived_graceful_restart.is_some()
    }

    // Param is passed by value, moved
    pub fn set_long_lived_graceful_restart(&mut self, v: LongLivedGracefulRestart) {
        self.long_lived_graceful_restart = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_long_lived_graceful_restart(&mut self) -> &mut LongLivedGracefulRestart {
        if self.long_lived_graceful_restart.is_none() {
            self.long_lived_graceful_restart.set_default();
        }
        self.long_lived_graceful_restart.as_mut().unwrap()
    }

    // Take field
    pub fn take_long_lived_graceful_restart(&mut self) -> LongLivedGracefulRestart {
        self.long_lived_graceful_restart.take().unwrap_or_else(|| LongLivedGracefulRestart::new())
    }

    // .gobgpapi.AddPaths add_paths = 10;


    pub fn get_add_paths(&self) -> &AddPaths {
        self.add_paths.as_ref().unwrap_or_else(|| AddPaths::default_instance())
    }
    pub fn clear_add_paths(&mut self) {
        self.add_paths.clear();
    }

    pub fn has_add_paths(&self) -> bool {
        self.add_paths.is_some()
    }

    // Param is passed by value, moved
    pub fn set_add_paths(&mut self, v: AddPaths) {
        self.add_paths = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_add_paths(&mut self) -> &mut AddPaths {
        if self.add_paths.is_none() {
            self.add_paths.set_default();
        }
        self.add_paths.as_mut().unwrap()
    }

    // Take field
    pub fn take_add_paths(&mut self) -> AddPaths {
        self.add_paths.take().unwrap_or_else(|| AddPaths::new())
    }
}

impl ::protobuf::Message for AfiSafi {
    fn is_initialized(&self) -> bool {
        for v in &self.mp_graceful_restart {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.state {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.apply_policy {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.route_selection_options {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.use_multiple_paths {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.prefix_limits {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.route_target_membership {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.long_lived_graceful_restart {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.add_paths {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mp_graceful_restart)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.config)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.state)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.apply_policy)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.route_selection_options)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.use_multiple_paths)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.prefix_limits)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.route_target_membership)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.long_lived_graceful_restart)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.add_paths)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.mp_graceful_restart.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.apply_policy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.route_selection_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.use_multiple_paths.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.prefix_limits.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.route_target_membership.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.long_lived_graceful_restart.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.add_paths.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.mp_graceful_restart.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.config.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.state.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.apply_policy.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.route_selection_options.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.use_multiple_paths.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.prefix_limits.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.route_target_membership.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.long_lived_graceful_restart.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.add_paths.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AfiSafi {
        AfiSafi::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MpGracefulRestart>>(
                    "mp_graceful_restart",
                    |m: &AfiSafi| { &m.mp_graceful_restart },
                    |m: &mut AfiSafi| { &mut m.mp_graceful_restart },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AfiSafiConfig>>(
                    "config",
                    |m: &AfiSafi| { &m.config },
                    |m: &mut AfiSafi| { &mut m.config },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AfiSafiState>>(
                    "state",
                    |m: &AfiSafi| { &m.state },
                    |m: &mut AfiSafi| { &mut m.state },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ApplyPolicy>>(
                    "apply_policy",
                    |m: &AfiSafi| { &m.apply_policy },
                    |m: &mut AfiSafi| { &mut m.apply_policy },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RouteSelectionOptions>>(
                    "route_selection_options",
                    |m: &AfiSafi| { &m.route_selection_options },
                    |m: &mut AfiSafi| { &mut m.route_selection_options },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UseMultiplePaths>>(
                    "use_multiple_paths",
                    |m: &AfiSafi| { &m.use_multiple_paths },
                    |m: &mut AfiSafi| { &mut m.use_multiple_paths },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PrefixLimit>>(
                    "prefix_limits",
                    |m: &AfiSafi| { &m.prefix_limits },
                    |m: &mut AfiSafi| { &mut m.prefix_limits },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RouteTargetMembership>>(
                    "route_target_membership",
                    |m: &AfiSafi| { &m.route_target_membership },
                    |m: &mut AfiSafi| { &mut m.route_target_membership },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LongLivedGracefulRestart>>(
                    "long_lived_graceful_restart",
                    |m: &AfiSafi| { &m.long_lived_graceful_restart },
                    |m: &mut AfiSafi| { &mut m.long_lived_graceful_restart },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AddPaths>>(
                    "add_paths",
                    |m: &AfiSafi| { &m.add_paths },
                    |m: &mut AfiSafi| { &mut m.add_paths },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AfiSafi>(
                    "AfiSafi",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AfiSafi {
        static mut instance: ::protobuf::lazy::Lazy<AfiSafi> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AfiSafi,
        };
        unsafe {
            instance.get(AfiSafi::new)
        }
    }
}

impl ::protobuf::Clear for AfiSafi {
    fn clear(&mut self) {
        self.mp_graceful_restart.clear();
        self.config.clear();
        self.state.clear();
        self.apply_policy.clear();
        self.route_selection_options.clear();
        self.use_multiple_paths.clear();
        self.prefix_limits.clear();
        self.route_target_membership.clear();
        self.long_lived_graceful_restart.clear();
        self.add_paths.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AfiSafi {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AfiSafi {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddPathsConfig {
    // message fields
    pub receive: bool,
    pub send_max: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddPathsConfig {
    fn default() -> &'a AddPathsConfig {
        <AddPathsConfig as ::protobuf::Message>::default_instance()
    }
}

impl AddPathsConfig {
    pub fn new() -> AddPathsConfig {
        ::std::default::Default::default()
    }

    // bool receive = 1;


    pub fn get_receive(&self) -> bool {
        self.receive
    }
    pub fn clear_receive(&mut self) {
        self.receive = false;
    }

    // Param is passed by value, moved
    pub fn set_receive(&mut self, v: bool) {
        self.receive = v;
    }

    // uint32 send_max = 2;


    pub fn get_send_max(&self) -> u32 {
        self.send_max
    }
    pub fn clear_send_max(&mut self) {
        self.send_max = 0;
    }

    // Param is passed by value, moved
    pub fn set_send_max(&mut self, v: u32) {
        self.send_max = v;
    }
}

impl ::protobuf::Message for AddPathsConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.receive = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.send_max = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.receive != false {
            my_size += 2;
        }
        if self.send_max != 0 {
            my_size += ::protobuf::rt::value_size(2, self.send_max, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.receive != false {
            os.write_bool(1, self.receive)?;
        }
        if self.send_max != 0 {
            os.write_uint32(2, self.send_max)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddPathsConfig {
        AddPathsConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "receive",
                    |m: &AddPathsConfig| { &m.receive },
                    |m: &mut AddPathsConfig| { &mut m.receive },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "send_max",
                    |m: &AddPathsConfig| { &m.send_max },
                    |m: &mut AddPathsConfig| { &mut m.send_max },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddPathsConfig>(
                    "AddPathsConfig",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AddPathsConfig {
        static mut instance: ::protobuf::lazy::Lazy<AddPathsConfig> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddPathsConfig,
        };
        unsafe {
            instance.get(AddPathsConfig::new)
        }
    }
}

impl ::protobuf::Clear for AddPathsConfig {
    fn clear(&mut self) {
        self.receive = false;
        self.send_max = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddPathsConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddPathsConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddPathsState {
    // message fields
    pub receive: bool,
    pub send_max: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddPathsState {
    fn default() -> &'a AddPathsState {
        <AddPathsState as ::protobuf::Message>::default_instance()
    }
}

impl AddPathsState {
    pub fn new() -> AddPathsState {
        ::std::default::Default::default()
    }

    // bool receive = 1;


    pub fn get_receive(&self) -> bool {
        self.receive
    }
    pub fn clear_receive(&mut self) {
        self.receive = false;
    }

    // Param is passed by value, moved
    pub fn set_receive(&mut self, v: bool) {
        self.receive = v;
    }

    // uint32 send_max = 2;


    pub fn get_send_max(&self) -> u32 {
        self.send_max
    }
    pub fn clear_send_max(&mut self) {
        self.send_max = 0;
    }

    // Param is passed by value, moved
    pub fn set_send_max(&mut self, v: u32) {
        self.send_max = v;
    }
}

impl ::protobuf::Message for AddPathsState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.receive = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.send_max = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.receive != false {
            my_size += 2;
        }
        if self.send_max != 0 {
            my_size += ::protobuf::rt::value_size(2, self.send_max, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.receive != false {
            os.write_bool(1, self.receive)?;
        }
        if self.send_max != 0 {
            os.write_uint32(2, self.send_max)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddPathsState {
        AddPathsState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "receive",
                    |m: &AddPathsState| { &m.receive },
                    |m: &mut AddPathsState| { &mut m.receive },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "send_max",
                    |m: &AddPathsState| { &m.send_max },
                    |m: &mut AddPathsState| { &mut m.send_max },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddPathsState>(
                    "AddPathsState",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AddPathsState {
        static mut instance: ::protobuf::lazy::Lazy<AddPathsState> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddPathsState,
        };
        unsafe {
            instance.get(AddPathsState::new)
        }
    }
}

impl ::protobuf::Clear for AddPathsState {
    fn clear(&mut self) {
        self.receive = false;
        self.send_max = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddPathsState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddPathsState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddPaths {
    // message fields
    pub config: ::protobuf::SingularPtrField<AddPathsConfig>,
    pub state: ::protobuf::SingularPtrField<AddPathsState>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddPaths {
    fn default() -> &'a AddPaths {
        <AddPaths as ::protobuf::Message>::default_instance()
    }
}

impl AddPaths {
    pub fn new() -> AddPaths {
        ::std::default::Default::default()
    }

    // .gobgpapi.AddPathsConfig config = 1;


    pub fn get_config(&self) -> &AddPathsConfig {
        self.config.as_ref().unwrap_or_else(|| AddPathsConfig::default_instance())
    }
    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    pub fn has_config(&self) -> bool {
        self.config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: AddPathsConfig) {
        self.config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config(&mut self) -> &mut AddPathsConfig {
        if self.config.is_none() {
            self.config.set_default();
        }
        self.config.as_mut().unwrap()
    }

    // Take field
    pub fn take_config(&mut self) -> AddPathsConfig {
        self.config.take().unwrap_or_else(|| AddPathsConfig::new())
    }

    // .gobgpapi.AddPathsState state = 2;


    pub fn get_state(&self) -> &AddPathsState {
        self.state.as_ref().unwrap_or_else(|| AddPathsState::default_instance())
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: AddPathsState) {
        self.state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut AddPathsState {
        if self.state.is_none() {
            self.state.set_default();
        }
        self.state.as_mut().unwrap()
    }

    // Take field
    pub fn take_state(&mut self) -> AddPathsState {
        self.state.take().unwrap_or_else(|| AddPathsState::new())
    }
}

impl ::protobuf::Message for AddPaths {
    fn is_initialized(&self) -> bool {
        for v in &self.config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.state {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.config)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.state)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.config.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.state.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddPaths {
        AddPaths::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AddPathsConfig>>(
                    "config",
                    |m: &AddPaths| { &m.config },
                    |m: &mut AddPaths| { &mut m.config },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AddPathsState>>(
                    "state",
                    |m: &AddPaths| { &m.state },
                    |m: &mut AddPaths| { &mut m.state },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddPaths>(
                    "AddPaths",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AddPaths {
        static mut instance: ::protobuf::lazy::Lazy<AddPaths> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddPaths,
        };
        unsafe {
            instance.get(AddPaths::new)
        }
    }
}

impl ::protobuf::Clear for AddPaths {
    fn clear(&mut self) {
        self.config.clear();
        self.state.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddPaths {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddPaths {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Prefix {
    // message fields
    pub ip_prefix: ::std::string::String,
    pub mask_length_min: u32,
    pub mask_length_max: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Prefix {
    fn default() -> &'a Prefix {
        <Prefix as ::protobuf::Message>::default_instance()
    }
}

impl Prefix {
    pub fn new() -> Prefix {
        ::std::default::Default::default()
    }

    // string ip_prefix = 1;


    pub fn get_ip_prefix(&self) -> &str {
        &self.ip_prefix
    }
    pub fn clear_ip_prefix(&mut self) {
        self.ip_prefix.clear();
    }

    // Param is passed by value, moved
    pub fn set_ip_prefix(&mut self, v: ::std::string::String) {
        self.ip_prefix = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip_prefix(&mut self) -> &mut ::std::string::String {
        &mut self.ip_prefix
    }

    // Take field
    pub fn take_ip_prefix(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ip_prefix, ::std::string::String::new())
    }

    // uint32 mask_length_min = 2;


    pub fn get_mask_length_min(&self) -> u32 {
        self.mask_length_min
    }
    pub fn clear_mask_length_min(&mut self) {
        self.mask_length_min = 0;
    }

    // Param is passed by value, moved
    pub fn set_mask_length_min(&mut self, v: u32) {
        self.mask_length_min = v;
    }

    // uint32 mask_length_max = 3;


    pub fn get_mask_length_max(&self) -> u32 {
        self.mask_length_max
    }
    pub fn clear_mask_length_max(&mut self) {
        self.mask_length_max = 0;
    }

    // Param is passed by value, moved
    pub fn set_mask_length_max(&mut self, v: u32) {
        self.mask_length_max = v;
    }
}

impl ::protobuf::Message for Prefix {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ip_prefix)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.mask_length_min = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.mask_length_max = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.ip_prefix.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.ip_prefix);
        }
        if self.mask_length_min != 0 {
            my_size += ::protobuf::rt::value_size(2, self.mask_length_min, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.mask_length_max != 0 {
            my_size += ::protobuf::rt::value_size(3, self.mask_length_max, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.ip_prefix.is_empty() {
            os.write_string(1, &self.ip_prefix)?;
        }
        if self.mask_length_min != 0 {
            os.write_uint32(2, self.mask_length_min)?;
        }
        if self.mask_length_max != 0 {
            os.write_uint32(3, self.mask_length_max)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Prefix {
        Prefix::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ip_prefix",
                    |m: &Prefix| { &m.ip_prefix },
                    |m: &mut Prefix| { &mut m.ip_prefix },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "mask_length_min",
                    |m: &Prefix| { &m.mask_length_min },
                    |m: &mut Prefix| { &mut m.mask_length_min },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "mask_length_max",
                    |m: &Prefix| { &m.mask_length_max },
                    |m: &mut Prefix| { &mut m.mask_length_max },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Prefix>(
                    "Prefix",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Prefix {
        static mut instance: ::protobuf::lazy::Lazy<Prefix> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Prefix,
        };
        unsafe {
            instance.get(Prefix::new)
        }
    }
}

impl ::protobuf::Clear for Prefix {
    fn clear(&mut self) {
        self.ip_prefix.clear();
        self.mask_length_min = 0;
        self.mask_length_max = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Prefix {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Prefix {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DefinedSet {
    // message fields
    pub defined_type: DefinedType,
    pub name: ::std::string::String,
    pub list: ::protobuf::RepeatedField<::std::string::String>,
    pub prefixes: ::protobuf::RepeatedField<Prefix>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DefinedSet {
    fn default() -> &'a DefinedSet {
        <DefinedSet as ::protobuf::Message>::default_instance()
    }
}

impl DefinedSet {
    pub fn new() -> DefinedSet {
        ::std::default::Default::default()
    }

    // .gobgpapi.DefinedType defined_type = 1;


    pub fn get_defined_type(&self) -> DefinedType {
        self.defined_type
    }
    pub fn clear_defined_type(&mut self) {
        self.defined_type = DefinedType::PREFIX;
    }

    // Param is passed by value, moved
    pub fn set_defined_type(&mut self, v: DefinedType) {
        self.defined_type = v;
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated string list = 3;


    pub fn get_list(&self) -> &[::std::string::String] {
        &self.list
    }
    pub fn clear_list(&mut self) {
        self.list.clear();
    }

    // Param is passed by value, moved
    pub fn set_list(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_list(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.list
    }

    // Take field
    pub fn take_list(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.list, ::protobuf::RepeatedField::new())
    }

    // repeated .gobgpapi.Prefix prefixes = 4;


    pub fn get_prefixes(&self) -> &[Prefix] {
        &self.prefixes
    }
    pub fn clear_prefixes(&mut self) {
        self.prefixes.clear();
    }

    // Param is passed by value, moved
    pub fn set_prefixes(&mut self, v: ::protobuf::RepeatedField<Prefix>) {
        self.prefixes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_prefixes(&mut self) -> &mut ::protobuf::RepeatedField<Prefix> {
        &mut self.prefixes
    }

    // Take field
    pub fn take_prefixes(&mut self) -> ::protobuf::RepeatedField<Prefix> {
        ::std::mem::replace(&mut self.prefixes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DefinedSet {
    fn is_initialized(&self) -> bool {
        for v in &self.prefixes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.defined_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.list)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.prefixes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.defined_type != DefinedType::PREFIX {
            my_size += ::protobuf::rt::enum_size(1, self.defined_type);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        for value in &self.list {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.prefixes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.defined_type != DefinedType::PREFIX {
            os.write_enum(1, self.defined_type.value())?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        for v in &self.list {
            os.write_string(3, &v)?;
        };
        for v in &self.prefixes {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DefinedSet {
        DefinedSet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DefinedType>>(
                    "defined_type",
                    |m: &DefinedSet| { &m.defined_type },
                    |m: &mut DefinedSet| { &mut m.defined_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &DefinedSet| { &m.name },
                    |m: &mut DefinedSet| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "list",
                    |m: &DefinedSet| { &m.list },
                    |m: &mut DefinedSet| { &mut m.list },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Prefix>>(
                    "prefixes",
                    |m: &DefinedSet| { &m.prefixes },
                    |m: &mut DefinedSet| { &mut m.prefixes },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DefinedSet>(
                    "DefinedSet",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DefinedSet {
        static mut instance: ::protobuf::lazy::Lazy<DefinedSet> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DefinedSet,
        };
        unsafe {
            instance.get(DefinedSet::new)
        }
    }
}

impl ::protobuf::Clear for DefinedSet {
    fn clear(&mut self) {
        self.defined_type = DefinedType::PREFIX;
        self.name.clear();
        self.list.clear();
        self.prefixes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DefinedSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DefinedSet {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MatchSet {
    // message fields
    pub match_type: MatchType,
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MatchSet {
    fn default() -> &'a MatchSet {
        <MatchSet as ::protobuf::Message>::default_instance()
    }
}

impl MatchSet {
    pub fn new() -> MatchSet {
        ::std::default::Default::default()
    }

    // .gobgpapi.MatchType match_type = 1;


    pub fn get_match_type(&self) -> MatchType {
        self.match_type
    }
    pub fn clear_match_type(&mut self) {
        self.match_type = MatchType::ANY;
    }

    // Param is passed by value, moved
    pub fn set_match_type(&mut self, v: MatchType) {
        self.match_type = v;
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MatchSet {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.match_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.match_type != MatchType::ANY {
            my_size += ::protobuf::rt::enum_size(1, self.match_type);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.match_type != MatchType::ANY {
            os.write_enum(1, self.match_type.value())?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MatchSet {
        MatchSet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MatchType>>(
                    "match_type",
                    |m: &MatchSet| { &m.match_type },
                    |m: &mut MatchSet| { &mut m.match_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &MatchSet| { &m.name },
                    |m: &mut MatchSet| { &mut m.name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MatchSet>(
                    "MatchSet",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MatchSet {
        static mut instance: ::protobuf::lazy::Lazy<MatchSet> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MatchSet,
        };
        unsafe {
            instance.get(MatchSet::new)
        }
    }
}

impl ::protobuf::Clear for MatchSet {
    fn clear(&mut self) {
        self.match_type = MatchType::ANY;
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MatchSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MatchSet {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AsPathLength {
    // message fields
    pub length_type: AsPathLengthType,
    pub length: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AsPathLength {
    fn default() -> &'a AsPathLength {
        <AsPathLength as ::protobuf::Message>::default_instance()
    }
}

impl AsPathLength {
    pub fn new() -> AsPathLength {
        ::std::default::Default::default()
    }

    // .gobgpapi.AsPathLengthType length_type = 1;


    pub fn get_length_type(&self) -> AsPathLengthType {
        self.length_type
    }
    pub fn clear_length_type(&mut self) {
        self.length_type = AsPathLengthType::EQ;
    }

    // Param is passed by value, moved
    pub fn set_length_type(&mut self, v: AsPathLengthType) {
        self.length_type = v;
    }

    // uint32 length = 2;


    pub fn get_length(&self) -> u32 {
        self.length
    }
    pub fn clear_length(&mut self) {
        self.length = 0;
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: u32) {
        self.length = v;
    }
}

impl ::protobuf::Message for AsPathLength {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.length_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.length = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.length_type != AsPathLengthType::EQ {
            my_size += ::protobuf::rt::enum_size(1, self.length_type);
        }
        if self.length != 0 {
            my_size += ::protobuf::rt::value_size(2, self.length, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.length_type != AsPathLengthType::EQ {
            os.write_enum(1, self.length_type.value())?;
        }
        if self.length != 0 {
            os.write_uint32(2, self.length)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AsPathLength {
        AsPathLength::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AsPathLengthType>>(
                    "length_type",
                    |m: &AsPathLength| { &m.length_type },
                    |m: &mut AsPathLength| { &mut m.length_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "length",
                    |m: &AsPathLength| { &m.length },
                    |m: &mut AsPathLength| { &mut m.length },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AsPathLength>(
                    "AsPathLength",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AsPathLength {
        static mut instance: ::protobuf::lazy::Lazy<AsPathLength> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AsPathLength,
        };
        unsafe {
            instance.get(AsPathLength::new)
        }
    }
}

impl ::protobuf::Clear for AsPathLength {
    fn clear(&mut self) {
        self.length_type = AsPathLengthType::EQ;
        self.length = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AsPathLength {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AsPathLength {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Conditions {
    // message fields
    pub prefix_set: ::protobuf::SingularPtrField<MatchSet>,
    pub neighbor_set: ::protobuf::SingularPtrField<MatchSet>,
    pub as_path_length: ::protobuf::SingularPtrField<AsPathLength>,
    pub as_path_set: ::protobuf::SingularPtrField<MatchSet>,
    pub community_set: ::protobuf::SingularPtrField<MatchSet>,
    pub ext_community_set: ::protobuf::SingularPtrField<MatchSet>,
    pub rpki_result: i32,
    pub route_type: Conditions_RouteType,
    pub large_community_set: ::protobuf::SingularPtrField<MatchSet>,
    pub next_hop_in_list: ::protobuf::RepeatedField<::std::string::String>,
    pub afi_safi_in: ::protobuf::RepeatedField<Family>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Conditions {
    fn default() -> &'a Conditions {
        <Conditions as ::protobuf::Message>::default_instance()
    }
}

impl Conditions {
    pub fn new() -> Conditions {
        ::std::default::Default::default()
    }

    // .gobgpapi.MatchSet prefix_set = 1;


    pub fn get_prefix_set(&self) -> &MatchSet {
        self.prefix_set.as_ref().unwrap_or_else(|| MatchSet::default_instance())
    }
    pub fn clear_prefix_set(&mut self) {
        self.prefix_set.clear();
    }

    pub fn has_prefix_set(&self) -> bool {
        self.prefix_set.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prefix_set(&mut self, v: MatchSet) {
        self.prefix_set = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prefix_set(&mut self) -> &mut MatchSet {
        if self.prefix_set.is_none() {
            self.prefix_set.set_default();
        }
        self.prefix_set.as_mut().unwrap()
    }

    // Take field
    pub fn take_prefix_set(&mut self) -> MatchSet {
        self.prefix_set.take().unwrap_or_else(|| MatchSet::new())
    }

    // .gobgpapi.MatchSet neighbor_set = 2;


    pub fn get_neighbor_set(&self) -> &MatchSet {
        self.neighbor_set.as_ref().unwrap_or_else(|| MatchSet::default_instance())
    }
    pub fn clear_neighbor_set(&mut self) {
        self.neighbor_set.clear();
    }

    pub fn has_neighbor_set(&self) -> bool {
        self.neighbor_set.is_some()
    }

    // Param is passed by value, moved
    pub fn set_neighbor_set(&mut self, v: MatchSet) {
        self.neighbor_set = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_neighbor_set(&mut self) -> &mut MatchSet {
        if self.neighbor_set.is_none() {
            self.neighbor_set.set_default();
        }
        self.neighbor_set.as_mut().unwrap()
    }

    // Take field
    pub fn take_neighbor_set(&mut self) -> MatchSet {
        self.neighbor_set.take().unwrap_or_else(|| MatchSet::new())
    }

    // .gobgpapi.AsPathLength as_path_length = 3;


    pub fn get_as_path_length(&self) -> &AsPathLength {
        self.as_path_length.as_ref().unwrap_or_else(|| AsPathLength::default_instance())
    }
    pub fn clear_as_path_length(&mut self) {
        self.as_path_length.clear();
    }

    pub fn has_as_path_length(&self) -> bool {
        self.as_path_length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_as_path_length(&mut self, v: AsPathLength) {
        self.as_path_length = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_as_path_length(&mut self) -> &mut AsPathLength {
        if self.as_path_length.is_none() {
            self.as_path_length.set_default();
        }
        self.as_path_length.as_mut().unwrap()
    }

    // Take field
    pub fn take_as_path_length(&mut self) -> AsPathLength {
        self.as_path_length.take().unwrap_or_else(|| AsPathLength::new())
    }

    // .gobgpapi.MatchSet as_path_set = 4;


    pub fn get_as_path_set(&self) -> &MatchSet {
        self.as_path_set.as_ref().unwrap_or_else(|| MatchSet::default_instance())
    }
    pub fn clear_as_path_set(&mut self) {
        self.as_path_set.clear();
    }

    pub fn has_as_path_set(&self) -> bool {
        self.as_path_set.is_some()
    }

    // Param is passed by value, moved
    pub fn set_as_path_set(&mut self, v: MatchSet) {
        self.as_path_set = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_as_path_set(&mut self) -> &mut MatchSet {
        if self.as_path_set.is_none() {
            self.as_path_set.set_default();
        }
        self.as_path_set.as_mut().unwrap()
    }

    // Take field
    pub fn take_as_path_set(&mut self) -> MatchSet {
        self.as_path_set.take().unwrap_or_else(|| MatchSet::new())
    }

    // .gobgpapi.MatchSet community_set = 5;


    pub fn get_community_set(&self) -> &MatchSet {
        self.community_set.as_ref().unwrap_or_else(|| MatchSet::default_instance())
    }
    pub fn clear_community_set(&mut self) {
        self.community_set.clear();
    }

    pub fn has_community_set(&self) -> bool {
        self.community_set.is_some()
    }

    // Param is passed by value, moved
    pub fn set_community_set(&mut self, v: MatchSet) {
        self.community_set = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_community_set(&mut self) -> &mut MatchSet {
        if self.community_set.is_none() {
            self.community_set.set_default();
        }
        self.community_set.as_mut().unwrap()
    }

    // Take field
    pub fn take_community_set(&mut self) -> MatchSet {
        self.community_set.take().unwrap_or_else(|| MatchSet::new())
    }

    // .gobgpapi.MatchSet ext_community_set = 6;


    pub fn get_ext_community_set(&self) -> &MatchSet {
        self.ext_community_set.as_ref().unwrap_or_else(|| MatchSet::default_instance())
    }
    pub fn clear_ext_community_set(&mut self) {
        self.ext_community_set.clear();
    }

    pub fn has_ext_community_set(&self) -> bool {
        self.ext_community_set.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ext_community_set(&mut self, v: MatchSet) {
        self.ext_community_set = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ext_community_set(&mut self) -> &mut MatchSet {
        if self.ext_community_set.is_none() {
            self.ext_community_set.set_default();
        }
        self.ext_community_set.as_mut().unwrap()
    }

    // Take field
    pub fn take_ext_community_set(&mut self) -> MatchSet {
        self.ext_community_set.take().unwrap_or_else(|| MatchSet::new())
    }

    // int32 rpki_result = 7;


    pub fn get_rpki_result(&self) -> i32 {
        self.rpki_result
    }
    pub fn clear_rpki_result(&mut self) {
        self.rpki_result = 0;
    }

    // Param is passed by value, moved
    pub fn set_rpki_result(&mut self, v: i32) {
        self.rpki_result = v;
    }

    // .gobgpapi.Conditions.RouteType route_type = 8;


    pub fn get_route_type(&self) -> Conditions_RouteType {
        self.route_type
    }
    pub fn clear_route_type(&mut self) {
        self.route_type = Conditions_RouteType::ROUTE_TYPE_NONE;
    }

    // Param is passed by value, moved
    pub fn set_route_type(&mut self, v: Conditions_RouteType) {
        self.route_type = v;
    }

    // .gobgpapi.MatchSet large_community_set = 9;


    pub fn get_large_community_set(&self) -> &MatchSet {
        self.large_community_set.as_ref().unwrap_or_else(|| MatchSet::default_instance())
    }
    pub fn clear_large_community_set(&mut self) {
        self.large_community_set.clear();
    }

    pub fn has_large_community_set(&self) -> bool {
        self.large_community_set.is_some()
    }

    // Param is passed by value, moved
    pub fn set_large_community_set(&mut self, v: MatchSet) {
        self.large_community_set = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_large_community_set(&mut self) -> &mut MatchSet {
        if self.large_community_set.is_none() {
            self.large_community_set.set_default();
        }
        self.large_community_set.as_mut().unwrap()
    }

    // Take field
    pub fn take_large_community_set(&mut self) -> MatchSet {
        self.large_community_set.take().unwrap_or_else(|| MatchSet::new())
    }

    // repeated string next_hop_in_list = 10;


    pub fn get_next_hop_in_list(&self) -> &[::std::string::String] {
        &self.next_hop_in_list
    }
    pub fn clear_next_hop_in_list(&mut self) {
        self.next_hop_in_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_hop_in_list(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.next_hop_in_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_next_hop_in_list(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.next_hop_in_list
    }

    // Take field
    pub fn take_next_hop_in_list(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.next_hop_in_list, ::protobuf::RepeatedField::new())
    }

    // repeated .gobgpapi.Family afi_safi_in = 11;


    pub fn get_afi_safi_in(&self) -> &[Family] {
        &self.afi_safi_in
    }
    pub fn clear_afi_safi_in(&mut self) {
        self.afi_safi_in.clear();
    }

    // Param is passed by value, moved
    pub fn set_afi_safi_in(&mut self, v: ::protobuf::RepeatedField<Family>) {
        self.afi_safi_in = v;
    }

    // Mutable pointer to the field.
    pub fn mut_afi_safi_in(&mut self) -> &mut ::protobuf::RepeatedField<Family> {
        &mut self.afi_safi_in
    }

    // Take field
    pub fn take_afi_safi_in(&mut self) -> ::protobuf::RepeatedField<Family> {
        ::std::mem::replace(&mut self.afi_safi_in, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Conditions {
    fn is_initialized(&self) -> bool {
        for v in &self.prefix_set {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.neighbor_set {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.as_path_length {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.as_path_set {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.community_set {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ext_community_set {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.large_community_set {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.afi_safi_in {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.prefix_set)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.neighbor_set)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.as_path_length)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.as_path_set)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.community_set)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ext_community_set)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.rpki_result = tmp;
                },
                8 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.route_type, 8, &mut self.unknown_fields)?
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.large_community_set)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.next_hop_in_list)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.afi_safi_in)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.prefix_set.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.neighbor_set.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.as_path_length.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.as_path_set.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.community_set.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ext_community_set.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.rpki_result != 0 {
            my_size += ::protobuf::rt::value_size(7, self.rpki_result, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.route_type != Conditions_RouteType::ROUTE_TYPE_NONE {
            my_size += ::protobuf::rt::enum_size(8, self.route_type);
        }
        if let Some(ref v) = self.large_community_set.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.next_hop_in_list {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        for value in &self.afi_safi_in {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.prefix_set.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.neighbor_set.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.as_path_length.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.as_path_set.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.community_set.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ext_community_set.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.rpki_result != 0 {
            os.write_int32(7, self.rpki_result)?;
        }
        if self.route_type != Conditions_RouteType::ROUTE_TYPE_NONE {
            os.write_enum(8, self.route_type.value())?;
        }
        if let Some(ref v) = self.large_community_set.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.next_hop_in_list {
            os.write_string(10, &v)?;
        };
        for v in &self.afi_safi_in {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Conditions {
        Conditions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MatchSet>>(
                    "prefix_set",
                    |m: &Conditions| { &m.prefix_set },
                    |m: &mut Conditions| { &mut m.prefix_set },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MatchSet>>(
                    "neighbor_set",
                    |m: &Conditions| { &m.neighbor_set },
                    |m: &mut Conditions| { &mut m.neighbor_set },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AsPathLength>>(
                    "as_path_length",
                    |m: &Conditions| { &m.as_path_length },
                    |m: &mut Conditions| { &mut m.as_path_length },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MatchSet>>(
                    "as_path_set",
                    |m: &Conditions| { &m.as_path_set },
                    |m: &mut Conditions| { &mut m.as_path_set },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MatchSet>>(
                    "community_set",
                    |m: &Conditions| { &m.community_set },
                    |m: &mut Conditions| { &mut m.community_set },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MatchSet>>(
                    "ext_community_set",
                    |m: &Conditions| { &m.ext_community_set },
                    |m: &mut Conditions| { &mut m.ext_community_set },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "rpki_result",
                    |m: &Conditions| { &m.rpki_result },
                    |m: &mut Conditions| { &mut m.rpki_result },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Conditions_RouteType>>(
                    "route_type",
                    |m: &Conditions| { &m.route_type },
                    |m: &mut Conditions| { &mut m.route_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MatchSet>>(
                    "large_community_set",
                    |m: &Conditions| { &m.large_community_set },
                    |m: &mut Conditions| { &mut m.large_community_set },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "next_hop_in_list",
                    |m: &Conditions| { &m.next_hop_in_list },
                    |m: &mut Conditions| { &mut m.next_hop_in_list },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Family>>(
                    "afi_safi_in",
                    |m: &Conditions| { &m.afi_safi_in },
                    |m: &mut Conditions| { &mut m.afi_safi_in },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Conditions>(
                    "Conditions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Conditions {
        static mut instance: ::protobuf::lazy::Lazy<Conditions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Conditions,
        };
        unsafe {
            instance.get(Conditions::new)
        }
    }
}

impl ::protobuf::Clear for Conditions {
    fn clear(&mut self) {
        self.prefix_set.clear();
        self.neighbor_set.clear();
        self.as_path_length.clear();
        self.as_path_set.clear();
        self.community_set.clear();
        self.ext_community_set.clear();
        self.rpki_result = 0;
        self.route_type = Conditions_RouteType::ROUTE_TYPE_NONE;
        self.large_community_set.clear();
        self.next_hop_in_list.clear();
        self.afi_safi_in.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Conditions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Conditions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Conditions_RouteType {
    ROUTE_TYPE_NONE = 0,
    ROUTE_TYPE_INTERNAL = 1,
    ROUTE_TYPE_EXTERNAL = 2,
    ROUTE_TYPE_LOCAL = 3,
}

impl ::protobuf::ProtobufEnum for Conditions_RouteType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Conditions_RouteType> {
        match value {
            0 => ::std::option::Option::Some(Conditions_RouteType::ROUTE_TYPE_NONE),
            1 => ::std::option::Option::Some(Conditions_RouteType::ROUTE_TYPE_INTERNAL),
            2 => ::std::option::Option::Some(Conditions_RouteType::ROUTE_TYPE_EXTERNAL),
            3 => ::std::option::Option::Some(Conditions_RouteType::ROUTE_TYPE_LOCAL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Conditions_RouteType] = &[
            Conditions_RouteType::ROUTE_TYPE_NONE,
            Conditions_RouteType::ROUTE_TYPE_INTERNAL,
            Conditions_RouteType::ROUTE_TYPE_EXTERNAL,
            Conditions_RouteType::ROUTE_TYPE_LOCAL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Conditions_RouteType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Conditions_RouteType {
}

impl ::std::default::Default for Conditions_RouteType {
    fn default() -> Self {
        Conditions_RouteType::ROUTE_TYPE_NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for Conditions_RouteType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommunityAction {
    // message fields
    pub action_type: CommunityActionType,
    pub communities: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommunityAction {
    fn default() -> &'a CommunityAction {
        <CommunityAction as ::protobuf::Message>::default_instance()
    }
}

impl CommunityAction {
    pub fn new() -> CommunityAction {
        ::std::default::Default::default()
    }

    // .gobgpapi.CommunityActionType action_type = 1;


    pub fn get_action_type(&self) -> CommunityActionType {
        self.action_type
    }
    pub fn clear_action_type(&mut self) {
        self.action_type = CommunityActionType::COMMUNITY_ADD;
    }

    // Param is passed by value, moved
    pub fn set_action_type(&mut self, v: CommunityActionType) {
        self.action_type = v;
    }

    // repeated string communities = 2;


    pub fn get_communities(&self) -> &[::std::string::String] {
        &self.communities
    }
    pub fn clear_communities(&mut self) {
        self.communities.clear();
    }

    // Param is passed by value, moved
    pub fn set_communities(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.communities = v;
    }

    // Mutable pointer to the field.
    pub fn mut_communities(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.communities
    }

    // Take field
    pub fn take_communities(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.communities, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CommunityAction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.action_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.communities)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.action_type != CommunityActionType::COMMUNITY_ADD {
            my_size += ::protobuf::rt::enum_size(1, self.action_type);
        }
        for value in &self.communities {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.action_type != CommunityActionType::COMMUNITY_ADD {
            os.write_enum(1, self.action_type.value())?;
        }
        for v in &self.communities {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommunityAction {
        CommunityAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CommunityActionType>>(
                    "action_type",
                    |m: &CommunityAction| { &m.action_type },
                    |m: &mut CommunityAction| { &mut m.action_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "communities",
                    |m: &CommunityAction| { &m.communities },
                    |m: &mut CommunityAction| { &mut m.communities },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CommunityAction>(
                    "CommunityAction",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CommunityAction {
        static mut instance: ::protobuf::lazy::Lazy<CommunityAction> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommunityAction,
        };
        unsafe {
            instance.get(CommunityAction::new)
        }
    }
}

impl ::protobuf::Clear for CommunityAction {
    fn clear(&mut self) {
        self.action_type = CommunityActionType::COMMUNITY_ADD;
        self.communities.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommunityAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommunityAction {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MedAction {
    // message fields
    pub action_type: MedActionType,
    pub value: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MedAction {
    fn default() -> &'a MedAction {
        <MedAction as ::protobuf::Message>::default_instance()
    }
}

impl MedAction {
    pub fn new() -> MedAction {
        ::std::default::Default::default()
    }

    // .gobgpapi.MedActionType action_type = 1;


    pub fn get_action_type(&self) -> MedActionType {
        self.action_type
    }
    pub fn clear_action_type(&mut self) {
        self.action_type = MedActionType::MED_MOD;
    }

    // Param is passed by value, moved
    pub fn set_action_type(&mut self, v: MedActionType) {
        self.action_type = v;
    }

    // int64 value = 2;


    pub fn get_value(&self) -> i64 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i64) {
        self.value = v;
    }
}

impl ::protobuf::Message for MedAction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.action_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.value = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.action_type != MedActionType::MED_MOD {
            my_size += ::protobuf::rt::enum_size(1, self.action_type);
        }
        if self.value != 0 {
            my_size += ::protobuf::rt::value_size(2, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.action_type != MedActionType::MED_MOD {
            os.write_enum(1, self.action_type.value())?;
        }
        if self.value != 0 {
            os.write_int64(2, self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MedAction {
        MedAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MedActionType>>(
                    "action_type",
                    |m: &MedAction| { &m.action_type },
                    |m: &mut MedAction| { &mut m.action_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "value",
                    |m: &MedAction| { &m.value },
                    |m: &mut MedAction| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MedAction>(
                    "MedAction",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MedAction {
        static mut instance: ::protobuf::lazy::Lazy<MedAction> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MedAction,
        };
        unsafe {
            instance.get(MedAction::new)
        }
    }
}

impl ::protobuf::Clear for MedAction {
    fn clear(&mut self) {
        self.action_type = MedActionType::MED_MOD;
        self.value = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MedAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MedAction {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AsPrependAction {
    // message fields
    pub asn: u32,
    pub repeat: u32,
    pub use_left_most: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AsPrependAction {
    fn default() -> &'a AsPrependAction {
        <AsPrependAction as ::protobuf::Message>::default_instance()
    }
}

impl AsPrependAction {
    pub fn new() -> AsPrependAction {
        ::std::default::Default::default()
    }

    // uint32 asn = 1;


    pub fn get_asn(&self) -> u32 {
        self.asn
    }
    pub fn clear_asn(&mut self) {
        self.asn = 0;
    }

    // Param is passed by value, moved
    pub fn set_asn(&mut self, v: u32) {
        self.asn = v;
    }

    // uint32 repeat = 2;


    pub fn get_repeat(&self) -> u32 {
        self.repeat
    }
    pub fn clear_repeat(&mut self) {
        self.repeat = 0;
    }

    // Param is passed by value, moved
    pub fn set_repeat(&mut self, v: u32) {
        self.repeat = v;
    }

    // bool use_left_most = 3;


    pub fn get_use_left_most(&self) -> bool {
        self.use_left_most
    }
    pub fn clear_use_left_most(&mut self) {
        self.use_left_most = false;
    }

    // Param is passed by value, moved
    pub fn set_use_left_most(&mut self, v: bool) {
        self.use_left_most = v;
    }
}

impl ::protobuf::Message for AsPrependAction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.asn = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.repeat = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.use_left_most = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.asn != 0 {
            my_size += ::protobuf::rt::value_size(1, self.asn, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.repeat != 0 {
            my_size += ::protobuf::rt::value_size(2, self.repeat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.use_left_most != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.asn != 0 {
            os.write_uint32(1, self.asn)?;
        }
        if self.repeat != 0 {
            os.write_uint32(2, self.repeat)?;
        }
        if self.use_left_most != false {
            os.write_bool(3, self.use_left_most)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AsPrependAction {
        AsPrependAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "asn",
                    |m: &AsPrependAction| { &m.asn },
                    |m: &mut AsPrependAction| { &mut m.asn },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "repeat",
                    |m: &AsPrependAction| { &m.repeat },
                    |m: &mut AsPrependAction| { &mut m.repeat },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "use_left_most",
                    |m: &AsPrependAction| { &m.use_left_most },
                    |m: &mut AsPrependAction| { &mut m.use_left_most },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AsPrependAction>(
                    "AsPrependAction",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AsPrependAction {
        static mut instance: ::protobuf::lazy::Lazy<AsPrependAction> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AsPrependAction,
        };
        unsafe {
            instance.get(AsPrependAction::new)
        }
    }
}

impl ::protobuf::Clear for AsPrependAction {
    fn clear(&mut self) {
        self.asn = 0;
        self.repeat = 0;
        self.use_left_most = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AsPrependAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AsPrependAction {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NexthopAction {
    // message fields
    pub address: ::std::string::String,
    pub field_self: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NexthopAction {
    fn default() -> &'a NexthopAction {
        <NexthopAction as ::protobuf::Message>::default_instance()
    }
}

impl NexthopAction {
    pub fn new() -> NexthopAction {
        ::std::default::Default::default()
    }

    // string address = 1;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // bool self = 2;


    pub fn get_field_self(&self) -> bool {
        self.field_self
    }
    pub fn clear_field_self(&mut self) {
        self.field_self = false;
    }

    // Param is passed by value, moved
    pub fn set_field_self(&mut self, v: bool) {
        self.field_self = v;
    }
}

impl ::protobuf::Message for NexthopAction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.field_self = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if self.field_self != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if self.field_self != false {
            os.write_bool(2, self.field_self)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NexthopAction {
        NexthopAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "address",
                    |m: &NexthopAction| { &m.address },
                    |m: &mut NexthopAction| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "self",
                    |m: &NexthopAction| { &m.field_self },
                    |m: &mut NexthopAction| { &mut m.field_self },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NexthopAction>(
                    "NexthopAction",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NexthopAction {
        static mut instance: ::protobuf::lazy::Lazy<NexthopAction> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NexthopAction,
        };
        unsafe {
            instance.get(NexthopAction::new)
        }
    }
}

impl ::protobuf::Clear for NexthopAction {
    fn clear(&mut self) {
        self.address.clear();
        self.field_self = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NexthopAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NexthopAction {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LocalPrefAction {
    // message fields
    pub value: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LocalPrefAction {
    fn default() -> &'a LocalPrefAction {
        <LocalPrefAction as ::protobuf::Message>::default_instance()
    }
}

impl LocalPrefAction {
    pub fn new() -> LocalPrefAction {
        ::std::default::Default::default()
    }

    // uint32 value = 1;


    pub fn get_value(&self) -> u32 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u32) {
        self.value = v;
    }
}

impl ::protobuf::Message for LocalPrefAction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.value = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != 0 {
            my_size += ::protobuf::rt::value_size(1, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.value != 0 {
            os.write_uint32(1, self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LocalPrefAction {
        LocalPrefAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "value",
                    |m: &LocalPrefAction| { &m.value },
                    |m: &mut LocalPrefAction| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LocalPrefAction>(
                    "LocalPrefAction",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LocalPrefAction {
        static mut instance: ::protobuf::lazy::Lazy<LocalPrefAction> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LocalPrefAction,
        };
        unsafe {
            instance.get(LocalPrefAction::new)
        }
    }
}

impl ::protobuf::Clear for LocalPrefAction {
    fn clear(&mut self) {
        self.value = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LocalPrefAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LocalPrefAction {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Actions {
    // message fields
    pub route_action: RouteAction,
    pub community: ::protobuf::SingularPtrField<CommunityAction>,
    pub med: ::protobuf::SingularPtrField<MedAction>,
    pub as_prepend: ::protobuf::SingularPtrField<AsPrependAction>,
    pub ext_community: ::protobuf::SingularPtrField<CommunityAction>,
    pub nexthop: ::protobuf::SingularPtrField<NexthopAction>,
    pub local_pref: ::protobuf::SingularPtrField<LocalPrefAction>,
    pub large_community: ::protobuf::SingularPtrField<CommunityAction>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Actions {
    fn default() -> &'a Actions {
        <Actions as ::protobuf::Message>::default_instance()
    }
}

impl Actions {
    pub fn new() -> Actions {
        ::std::default::Default::default()
    }

    // .gobgpapi.RouteAction route_action = 1;


    pub fn get_route_action(&self) -> RouteAction {
        self.route_action
    }
    pub fn clear_route_action(&mut self) {
        self.route_action = RouteAction::NONE;
    }

    // Param is passed by value, moved
    pub fn set_route_action(&mut self, v: RouteAction) {
        self.route_action = v;
    }

    // .gobgpapi.CommunityAction community = 2;


    pub fn get_community(&self) -> &CommunityAction {
        self.community.as_ref().unwrap_or_else(|| CommunityAction::default_instance())
    }
    pub fn clear_community(&mut self) {
        self.community.clear();
    }

    pub fn has_community(&self) -> bool {
        self.community.is_some()
    }

    // Param is passed by value, moved
    pub fn set_community(&mut self, v: CommunityAction) {
        self.community = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_community(&mut self) -> &mut CommunityAction {
        if self.community.is_none() {
            self.community.set_default();
        }
        self.community.as_mut().unwrap()
    }

    // Take field
    pub fn take_community(&mut self) -> CommunityAction {
        self.community.take().unwrap_or_else(|| CommunityAction::new())
    }

    // .gobgpapi.MedAction med = 3;


    pub fn get_med(&self) -> &MedAction {
        self.med.as_ref().unwrap_or_else(|| MedAction::default_instance())
    }
    pub fn clear_med(&mut self) {
        self.med.clear();
    }

    pub fn has_med(&self) -> bool {
        self.med.is_some()
    }

    // Param is passed by value, moved
    pub fn set_med(&mut self, v: MedAction) {
        self.med = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_med(&mut self) -> &mut MedAction {
        if self.med.is_none() {
            self.med.set_default();
        }
        self.med.as_mut().unwrap()
    }

    // Take field
    pub fn take_med(&mut self) -> MedAction {
        self.med.take().unwrap_or_else(|| MedAction::new())
    }

    // .gobgpapi.AsPrependAction as_prepend = 4;


    pub fn get_as_prepend(&self) -> &AsPrependAction {
        self.as_prepend.as_ref().unwrap_or_else(|| AsPrependAction::default_instance())
    }
    pub fn clear_as_prepend(&mut self) {
        self.as_prepend.clear();
    }

    pub fn has_as_prepend(&self) -> bool {
        self.as_prepend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_as_prepend(&mut self, v: AsPrependAction) {
        self.as_prepend = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_as_prepend(&mut self) -> &mut AsPrependAction {
        if self.as_prepend.is_none() {
            self.as_prepend.set_default();
        }
        self.as_prepend.as_mut().unwrap()
    }

    // Take field
    pub fn take_as_prepend(&mut self) -> AsPrependAction {
        self.as_prepend.take().unwrap_or_else(|| AsPrependAction::new())
    }

    // .gobgpapi.CommunityAction ext_community = 5;


    pub fn get_ext_community(&self) -> &CommunityAction {
        self.ext_community.as_ref().unwrap_or_else(|| CommunityAction::default_instance())
    }
    pub fn clear_ext_community(&mut self) {
        self.ext_community.clear();
    }

    pub fn has_ext_community(&self) -> bool {
        self.ext_community.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ext_community(&mut self, v: CommunityAction) {
        self.ext_community = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ext_community(&mut self) -> &mut CommunityAction {
        if self.ext_community.is_none() {
            self.ext_community.set_default();
        }
        self.ext_community.as_mut().unwrap()
    }

    // Take field
    pub fn take_ext_community(&mut self) -> CommunityAction {
        self.ext_community.take().unwrap_or_else(|| CommunityAction::new())
    }

    // .gobgpapi.NexthopAction nexthop = 6;


    pub fn get_nexthop(&self) -> &NexthopAction {
        self.nexthop.as_ref().unwrap_or_else(|| NexthopAction::default_instance())
    }
    pub fn clear_nexthop(&mut self) {
        self.nexthop.clear();
    }

    pub fn has_nexthop(&self) -> bool {
        self.nexthop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nexthop(&mut self, v: NexthopAction) {
        self.nexthop = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nexthop(&mut self) -> &mut NexthopAction {
        if self.nexthop.is_none() {
            self.nexthop.set_default();
        }
        self.nexthop.as_mut().unwrap()
    }

    // Take field
    pub fn take_nexthop(&mut self) -> NexthopAction {
        self.nexthop.take().unwrap_or_else(|| NexthopAction::new())
    }

    // .gobgpapi.LocalPrefAction local_pref = 7;


    pub fn get_local_pref(&self) -> &LocalPrefAction {
        self.local_pref.as_ref().unwrap_or_else(|| LocalPrefAction::default_instance())
    }
    pub fn clear_local_pref(&mut self) {
        self.local_pref.clear();
    }

    pub fn has_local_pref(&self) -> bool {
        self.local_pref.is_some()
    }

    // Param is passed by value, moved
    pub fn set_local_pref(&mut self, v: LocalPrefAction) {
        self.local_pref = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_local_pref(&mut self) -> &mut LocalPrefAction {
        if self.local_pref.is_none() {
            self.local_pref.set_default();
        }
        self.local_pref.as_mut().unwrap()
    }

    // Take field
    pub fn take_local_pref(&mut self) -> LocalPrefAction {
        self.local_pref.take().unwrap_or_else(|| LocalPrefAction::new())
    }

    // .gobgpapi.CommunityAction large_community = 8;


    pub fn get_large_community(&self) -> &CommunityAction {
        self.large_community.as_ref().unwrap_or_else(|| CommunityAction::default_instance())
    }
    pub fn clear_large_community(&mut self) {
        self.large_community.clear();
    }

    pub fn has_large_community(&self) -> bool {
        self.large_community.is_some()
    }

    // Param is passed by value, moved
    pub fn set_large_community(&mut self, v: CommunityAction) {
        self.large_community = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_large_community(&mut self) -> &mut CommunityAction {
        if self.large_community.is_none() {
            self.large_community.set_default();
        }
        self.large_community.as_mut().unwrap()
    }

    // Take field
    pub fn take_large_community(&mut self) -> CommunityAction {
        self.large_community.take().unwrap_or_else(|| CommunityAction::new())
    }
}

impl ::protobuf::Message for Actions {
    fn is_initialized(&self) -> bool {
        for v in &self.community {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.med {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.as_prepend {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ext_community {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.nexthop {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.local_pref {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.large_community {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.route_action, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.community)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.med)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.as_prepend)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ext_community)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.nexthop)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.local_pref)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.large_community)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.route_action != RouteAction::NONE {
            my_size += ::protobuf::rt::enum_size(1, self.route_action);
        }
        if let Some(ref v) = self.community.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.med.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.as_prepend.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ext_community.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.nexthop.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.local_pref.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.large_community.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.route_action != RouteAction::NONE {
            os.write_enum(1, self.route_action.value())?;
        }
        if let Some(ref v) = self.community.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.med.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.as_prepend.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ext_community.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.nexthop.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.local_pref.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.large_community.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Actions {
        Actions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RouteAction>>(
                    "route_action",
                    |m: &Actions| { &m.route_action },
                    |m: &mut Actions| { &mut m.route_action },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommunityAction>>(
                    "community",
                    |m: &Actions| { &m.community },
                    |m: &mut Actions| { &mut m.community },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MedAction>>(
                    "med",
                    |m: &Actions| { &m.med },
                    |m: &mut Actions| { &mut m.med },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AsPrependAction>>(
                    "as_prepend",
                    |m: &Actions| { &m.as_prepend },
                    |m: &mut Actions| { &mut m.as_prepend },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommunityAction>>(
                    "ext_community",
                    |m: &Actions| { &m.ext_community },
                    |m: &mut Actions| { &mut m.ext_community },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NexthopAction>>(
                    "nexthop",
                    |m: &Actions| { &m.nexthop },
                    |m: &mut Actions| { &mut m.nexthop },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LocalPrefAction>>(
                    "local_pref",
                    |m: &Actions| { &m.local_pref },
                    |m: &mut Actions| { &mut m.local_pref },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommunityAction>>(
                    "large_community",
                    |m: &Actions| { &m.large_community },
                    |m: &mut Actions| { &mut m.large_community },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Actions>(
                    "Actions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Actions {
        static mut instance: ::protobuf::lazy::Lazy<Actions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Actions,
        };
        unsafe {
            instance.get(Actions::new)
        }
    }
}

impl ::protobuf::Clear for Actions {
    fn clear(&mut self) {
        self.route_action = RouteAction::NONE;
        self.community.clear();
        self.med.clear();
        self.as_prepend.clear();
        self.ext_community.clear();
        self.nexthop.clear();
        self.local_pref.clear();
        self.large_community.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Actions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Actions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Statement {
    // message fields
    pub name: ::std::string::String,
    pub conditions: ::protobuf::SingularPtrField<Conditions>,
    pub actions: ::protobuf::SingularPtrField<Actions>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Statement {
    fn default() -> &'a Statement {
        <Statement as ::protobuf::Message>::default_instance()
    }
}

impl Statement {
    pub fn new() -> Statement {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .gobgpapi.Conditions conditions = 2;


    pub fn get_conditions(&self) -> &Conditions {
        self.conditions.as_ref().unwrap_or_else(|| Conditions::default_instance())
    }
    pub fn clear_conditions(&mut self) {
        self.conditions.clear();
    }

    pub fn has_conditions(&self) -> bool {
        self.conditions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_conditions(&mut self, v: Conditions) {
        self.conditions = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_conditions(&mut self) -> &mut Conditions {
        if self.conditions.is_none() {
            self.conditions.set_default();
        }
        self.conditions.as_mut().unwrap()
    }

    // Take field
    pub fn take_conditions(&mut self) -> Conditions {
        self.conditions.take().unwrap_or_else(|| Conditions::new())
    }

    // .gobgpapi.Actions actions = 3;


    pub fn get_actions(&self) -> &Actions {
        self.actions.as_ref().unwrap_or_else(|| Actions::default_instance())
    }
    pub fn clear_actions(&mut self) {
        self.actions.clear();
    }

    pub fn has_actions(&self) -> bool {
        self.actions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actions(&mut self, v: Actions) {
        self.actions = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_actions(&mut self) -> &mut Actions {
        if self.actions.is_none() {
            self.actions.set_default();
        }
        self.actions.as_mut().unwrap()
    }

    // Take field
    pub fn take_actions(&mut self) -> Actions {
        self.actions.take().unwrap_or_else(|| Actions::new())
    }
}

impl ::protobuf::Message for Statement {
    fn is_initialized(&self) -> bool {
        for v in &self.conditions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.actions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.conditions)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.actions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let Some(ref v) = self.conditions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.actions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let Some(ref v) = self.conditions.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.actions.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Statement {
        Statement::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &Statement| { &m.name },
                    |m: &mut Statement| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Conditions>>(
                    "conditions",
                    |m: &Statement| { &m.conditions },
                    |m: &mut Statement| { &mut m.conditions },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Actions>>(
                    "actions",
                    |m: &Statement| { &m.actions },
                    |m: &mut Statement| { &mut m.actions },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Statement>(
                    "Statement",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Statement {
        static mut instance: ::protobuf::lazy::Lazy<Statement> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Statement,
        };
        unsafe {
            instance.get(Statement::new)
        }
    }
}

impl ::protobuf::Clear for Statement {
    fn clear(&mut self) {
        self.name.clear();
        self.conditions.clear();
        self.actions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Statement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Statement {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Policy {
    // message fields
    pub name: ::std::string::String,
    pub statements: ::protobuf::RepeatedField<Statement>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Policy {
    fn default() -> &'a Policy {
        <Policy as ::protobuf::Message>::default_instance()
    }
}

impl Policy {
    pub fn new() -> Policy {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated .gobgpapi.Statement statements = 2;


    pub fn get_statements(&self) -> &[Statement] {
        &self.statements
    }
    pub fn clear_statements(&mut self) {
        self.statements.clear();
    }

    // Param is passed by value, moved
    pub fn set_statements(&mut self, v: ::protobuf::RepeatedField<Statement>) {
        self.statements = v;
    }

    // Mutable pointer to the field.
    pub fn mut_statements(&mut self) -> &mut ::protobuf::RepeatedField<Statement> {
        &mut self.statements
    }

    // Take field
    pub fn take_statements(&mut self) -> ::protobuf::RepeatedField<Statement> {
        ::std::mem::replace(&mut self.statements, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Policy {
    fn is_initialized(&self) -> bool {
        for v in &self.statements {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.statements)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        for value in &self.statements {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        for v in &self.statements {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Policy {
        Policy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &Policy| { &m.name },
                    |m: &mut Policy| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Statement>>(
                    "statements",
                    |m: &Policy| { &m.statements },
                    |m: &mut Policy| { &mut m.statements },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Policy>(
                    "Policy",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Policy {
        static mut instance: ::protobuf::lazy::Lazy<Policy> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Policy,
        };
        unsafe {
            instance.get(Policy::new)
        }
    }
}

impl ::protobuf::Clear for Policy {
    fn clear(&mut self) {
        self.name.clear();
        self.statements.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Policy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Policy {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PolicyAssignment {
    // message fields
    pub name: ::std::string::String,
    pub direction: PolicyDirection,
    pub policies: ::protobuf::RepeatedField<Policy>,
    pub default_action: RouteAction,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PolicyAssignment {
    fn default() -> &'a PolicyAssignment {
        <PolicyAssignment as ::protobuf::Message>::default_instance()
    }
}

impl PolicyAssignment {
    pub fn new() -> PolicyAssignment {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .gobgpapi.PolicyDirection direction = 2;


    pub fn get_direction(&self) -> PolicyDirection {
        self.direction
    }
    pub fn clear_direction(&mut self) {
        self.direction = PolicyDirection::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: PolicyDirection) {
        self.direction = v;
    }

    // repeated .gobgpapi.Policy policies = 4;


    pub fn get_policies(&self) -> &[Policy] {
        &self.policies
    }
    pub fn clear_policies(&mut self) {
        self.policies.clear();
    }

    // Param is passed by value, moved
    pub fn set_policies(&mut self, v: ::protobuf::RepeatedField<Policy>) {
        self.policies = v;
    }

    // Mutable pointer to the field.
    pub fn mut_policies(&mut self) -> &mut ::protobuf::RepeatedField<Policy> {
        &mut self.policies
    }

    // Take field
    pub fn take_policies(&mut self) -> ::protobuf::RepeatedField<Policy> {
        ::std::mem::replace(&mut self.policies, ::protobuf::RepeatedField::new())
    }

    // .gobgpapi.RouteAction default_action = 5;


    pub fn get_default_action(&self) -> RouteAction {
        self.default_action
    }
    pub fn clear_default_action(&mut self) {
        self.default_action = RouteAction::NONE;
    }

    // Param is passed by value, moved
    pub fn set_default_action(&mut self, v: RouteAction) {
        self.default_action = v;
    }
}

impl ::protobuf::Message for PolicyAssignment {
    fn is_initialized(&self) -> bool {
        for v in &self.policies {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.direction, 2, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.policies)?;
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.default_action, 5, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.direction != PolicyDirection::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(2, self.direction);
        }
        for value in &self.policies {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.default_action != RouteAction::NONE {
            my_size += ::protobuf::rt::enum_size(5, self.default_action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.direction != PolicyDirection::UNKNOWN {
            os.write_enum(2, self.direction.value())?;
        }
        for v in &self.policies {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.default_action != RouteAction::NONE {
            os.write_enum(5, self.default_action.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PolicyAssignment {
        PolicyAssignment::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &PolicyAssignment| { &m.name },
                    |m: &mut PolicyAssignment| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PolicyDirection>>(
                    "direction",
                    |m: &PolicyAssignment| { &m.direction },
                    |m: &mut PolicyAssignment| { &mut m.direction },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Policy>>(
                    "policies",
                    |m: &PolicyAssignment| { &m.policies },
                    |m: &mut PolicyAssignment| { &mut m.policies },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RouteAction>>(
                    "default_action",
                    |m: &PolicyAssignment| { &m.default_action },
                    |m: &mut PolicyAssignment| { &mut m.default_action },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PolicyAssignment>(
                    "PolicyAssignment",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PolicyAssignment {
        static mut instance: ::protobuf::lazy::Lazy<PolicyAssignment> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PolicyAssignment,
        };
        unsafe {
            instance.get(PolicyAssignment::new)
        }
    }
}

impl ::protobuf::Clear for PolicyAssignment {
    fn clear(&mut self) {
        self.name.clear();
        self.direction = PolicyDirection::UNKNOWN;
        self.policies.clear();
        self.default_action = RouteAction::NONE;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PolicyAssignment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PolicyAssignment {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RoutingPolicy {
    // message fields
    pub defined_sets: ::protobuf::RepeatedField<DefinedSet>,
    pub policies: ::protobuf::RepeatedField<Policy>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RoutingPolicy {
    fn default() -> &'a RoutingPolicy {
        <RoutingPolicy as ::protobuf::Message>::default_instance()
    }
}

impl RoutingPolicy {
    pub fn new() -> RoutingPolicy {
        ::std::default::Default::default()
    }

    // repeated .gobgpapi.DefinedSet defined_sets = 1;


    pub fn get_defined_sets(&self) -> &[DefinedSet] {
        &self.defined_sets
    }
    pub fn clear_defined_sets(&mut self) {
        self.defined_sets.clear();
    }

    // Param is passed by value, moved
    pub fn set_defined_sets(&mut self, v: ::protobuf::RepeatedField<DefinedSet>) {
        self.defined_sets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_defined_sets(&mut self) -> &mut ::protobuf::RepeatedField<DefinedSet> {
        &mut self.defined_sets
    }

    // Take field
    pub fn take_defined_sets(&mut self) -> ::protobuf::RepeatedField<DefinedSet> {
        ::std::mem::replace(&mut self.defined_sets, ::protobuf::RepeatedField::new())
    }

    // repeated .gobgpapi.Policy policies = 2;


    pub fn get_policies(&self) -> &[Policy] {
        &self.policies
    }
    pub fn clear_policies(&mut self) {
        self.policies.clear();
    }

    // Param is passed by value, moved
    pub fn set_policies(&mut self, v: ::protobuf::RepeatedField<Policy>) {
        self.policies = v;
    }

    // Mutable pointer to the field.
    pub fn mut_policies(&mut self) -> &mut ::protobuf::RepeatedField<Policy> {
        &mut self.policies
    }

    // Take field
    pub fn take_policies(&mut self) -> ::protobuf::RepeatedField<Policy> {
        ::std::mem::replace(&mut self.policies, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RoutingPolicy {
    fn is_initialized(&self) -> bool {
        for v in &self.defined_sets {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.policies {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.defined_sets)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.policies)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.defined_sets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.policies {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.defined_sets {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.policies {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RoutingPolicy {
        RoutingPolicy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DefinedSet>>(
                    "defined_sets",
                    |m: &RoutingPolicy| { &m.defined_sets },
                    |m: &mut RoutingPolicy| { &mut m.defined_sets },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Policy>>(
                    "policies",
                    |m: &RoutingPolicy| { &m.policies },
                    |m: &mut RoutingPolicy| { &mut m.policies },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RoutingPolicy>(
                    "RoutingPolicy",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RoutingPolicy {
        static mut instance: ::protobuf::lazy::Lazy<RoutingPolicy> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RoutingPolicy,
        };
        unsafe {
            instance.get(RoutingPolicy::new)
        }
    }
}

impl ::protobuf::Clear for RoutingPolicy {
    fn clear(&mut self) {
        self.defined_sets.clear();
        self.policies.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RoutingPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RoutingPolicy {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Roa {
    // message fields
    pub field_as: u32,
    pub prefixlen: u32,
    pub maxlen: u32,
    pub prefix: ::std::string::String,
    pub conf: ::protobuf::SingularPtrField<RPKIConf>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Roa {
    fn default() -> &'a Roa {
        <Roa as ::protobuf::Message>::default_instance()
    }
}

impl Roa {
    pub fn new() -> Roa {
        ::std::default::Default::default()
    }

    // uint32 as = 1;


    pub fn get_field_as(&self) -> u32 {
        self.field_as
    }
    pub fn clear_field_as(&mut self) {
        self.field_as = 0;
    }

    // Param is passed by value, moved
    pub fn set_field_as(&mut self, v: u32) {
        self.field_as = v;
    }

    // uint32 prefixlen = 2;


    pub fn get_prefixlen(&self) -> u32 {
        self.prefixlen
    }
    pub fn clear_prefixlen(&mut self) {
        self.prefixlen = 0;
    }

    // Param is passed by value, moved
    pub fn set_prefixlen(&mut self, v: u32) {
        self.prefixlen = v;
    }

    // uint32 maxlen = 3;


    pub fn get_maxlen(&self) -> u32 {
        self.maxlen
    }
    pub fn clear_maxlen(&mut self) {
        self.maxlen = 0;
    }

    // Param is passed by value, moved
    pub fn set_maxlen(&mut self, v: u32) {
        self.maxlen = v;
    }

    // string prefix = 4;


    pub fn get_prefix(&self) -> &str {
        &self.prefix
    }
    pub fn clear_prefix(&mut self) {
        self.prefix.clear();
    }

    // Param is passed by value, moved
    pub fn set_prefix(&mut self, v: ::std::string::String) {
        self.prefix = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prefix(&mut self) -> &mut ::std::string::String {
        &mut self.prefix
    }

    // Take field
    pub fn take_prefix(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.prefix, ::std::string::String::new())
    }

    // .gobgpapi.RPKIConf conf = 5;


    pub fn get_conf(&self) -> &RPKIConf {
        self.conf.as_ref().unwrap_or_else(|| RPKIConf::default_instance())
    }
    pub fn clear_conf(&mut self) {
        self.conf.clear();
    }

    pub fn has_conf(&self) -> bool {
        self.conf.is_some()
    }

    // Param is passed by value, moved
    pub fn set_conf(&mut self, v: RPKIConf) {
        self.conf = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_conf(&mut self) -> &mut RPKIConf {
        if self.conf.is_none() {
            self.conf.set_default();
        }
        self.conf.as_mut().unwrap()
    }

    // Take field
    pub fn take_conf(&mut self) -> RPKIConf {
        self.conf.take().unwrap_or_else(|| RPKIConf::new())
    }
}

impl ::protobuf::Message for Roa {
    fn is_initialized(&self) -> bool {
        for v in &self.conf {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.field_as = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.prefixlen = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.maxlen = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.prefix)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.conf)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_as != 0 {
            my_size += ::protobuf::rt::value_size(1, self.field_as, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.prefixlen != 0 {
            my_size += ::protobuf::rt::value_size(2, self.prefixlen, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.maxlen != 0 {
            my_size += ::protobuf::rt::value_size(3, self.maxlen, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.prefix.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.prefix);
        }
        if let Some(ref v) = self.conf.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_as != 0 {
            os.write_uint32(1, self.field_as)?;
        }
        if self.prefixlen != 0 {
            os.write_uint32(2, self.prefixlen)?;
        }
        if self.maxlen != 0 {
            os.write_uint32(3, self.maxlen)?;
        }
        if !self.prefix.is_empty() {
            os.write_string(4, &self.prefix)?;
        }
        if let Some(ref v) = self.conf.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Roa {
        Roa::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "as",
                    |m: &Roa| { &m.field_as },
                    |m: &mut Roa| { &mut m.field_as },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "prefixlen",
                    |m: &Roa| { &m.prefixlen },
                    |m: &mut Roa| { &mut m.prefixlen },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "maxlen",
                    |m: &Roa| { &m.maxlen },
                    |m: &mut Roa| { &mut m.maxlen },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "prefix",
                    |m: &Roa| { &m.prefix },
                    |m: &mut Roa| { &mut m.prefix },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RPKIConf>>(
                    "conf",
                    |m: &Roa| { &m.conf },
                    |m: &mut Roa| { &mut m.conf },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Roa>(
                    "Roa",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Roa {
        static mut instance: ::protobuf::lazy::Lazy<Roa> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Roa,
        };
        unsafe {
            instance.get(Roa::new)
        }
    }
}

impl ::protobuf::Clear for Roa {
    fn clear(&mut self) {
        self.field_as = 0;
        self.prefixlen = 0;
        self.maxlen = 0;
        self.prefix.clear();
        self.conf.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Roa {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Roa {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Vrf {
    // message fields
    pub name: ::std::string::String,
    pub rd: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    pub import_rt: ::protobuf::RepeatedField<::protobuf::well_known_types::Any>,
    pub export_rt: ::protobuf::RepeatedField<::protobuf::well_known_types::Any>,
    pub id: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Vrf {
    fn default() -> &'a Vrf {
        <Vrf as ::protobuf::Message>::default_instance()
    }
}

impl Vrf {
    pub fn new() -> Vrf {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .google.protobuf.Any rd = 2;


    pub fn get_rd(&self) -> &::protobuf::well_known_types::Any {
        self.rd.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Any::default_instance())
    }
    pub fn clear_rd(&mut self) {
        self.rd.clear();
    }

    pub fn has_rd(&self) -> bool {
        self.rd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rd(&mut self, v: ::protobuf::well_known_types::Any) {
        self.rd = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rd(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.rd.is_none() {
            self.rd.set_default();
        }
        self.rd.as_mut().unwrap()
    }

    // Take field
    pub fn take_rd(&mut self) -> ::protobuf::well_known_types::Any {
        self.rd.take().unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }

    // repeated .google.protobuf.Any import_rt = 3;


    pub fn get_import_rt(&self) -> &[::protobuf::well_known_types::Any] {
        &self.import_rt
    }
    pub fn clear_import_rt(&mut self) {
        self.import_rt.clear();
    }

    // Param is passed by value, moved
    pub fn set_import_rt(&mut self, v: ::protobuf::RepeatedField<::protobuf::well_known_types::Any>) {
        self.import_rt = v;
    }

    // Mutable pointer to the field.
    pub fn mut_import_rt(&mut self) -> &mut ::protobuf::RepeatedField<::protobuf::well_known_types::Any> {
        &mut self.import_rt
    }

    // Take field
    pub fn take_import_rt(&mut self) -> ::protobuf::RepeatedField<::protobuf::well_known_types::Any> {
        ::std::mem::replace(&mut self.import_rt, ::protobuf::RepeatedField::new())
    }

    // repeated .google.protobuf.Any export_rt = 4;


    pub fn get_export_rt(&self) -> &[::protobuf::well_known_types::Any] {
        &self.export_rt
    }
    pub fn clear_export_rt(&mut self) {
        self.export_rt.clear();
    }

    // Param is passed by value, moved
    pub fn set_export_rt(&mut self, v: ::protobuf::RepeatedField<::protobuf::well_known_types::Any>) {
        self.export_rt = v;
    }

    // Mutable pointer to the field.
    pub fn mut_export_rt(&mut self) -> &mut ::protobuf::RepeatedField<::protobuf::well_known_types::Any> {
        &mut self.export_rt
    }

    // Take field
    pub fn take_export_rt(&mut self) -> ::protobuf::RepeatedField<::protobuf::well_known_types::Any> {
        ::std::mem::replace(&mut self.export_rt, ::protobuf::RepeatedField::new())
    }

    // uint32 id = 5;


    pub fn get_id(&self) -> u32 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = v;
    }
}

impl ::protobuf::Message for Vrf {
    fn is_initialized(&self) -> bool {
        for v in &self.rd {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.import_rt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.export_rt {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rd)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.import_rt)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.export_rt)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let Some(ref v) = self.rd.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.import_rt {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.export_rt {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(5, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let Some(ref v) = self.rd.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.import_rt {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.export_rt {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.id != 0 {
            os.write_uint32(5, self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Vrf {
        Vrf::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &Vrf| { &m.name },
                    |m: &mut Vrf| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                    "rd",
                    |m: &Vrf| { &m.rd },
                    |m: &mut Vrf| { &mut m.rd },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                    "import_rt",
                    |m: &Vrf| { &m.import_rt },
                    |m: &mut Vrf| { &mut m.import_rt },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                    "export_rt",
                    |m: &Vrf| { &m.export_rt },
                    |m: &mut Vrf| { &mut m.export_rt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "id",
                    |m: &Vrf| { &m.id },
                    |m: &mut Vrf| { &mut m.id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Vrf>(
                    "Vrf",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Vrf {
        static mut instance: ::protobuf::lazy::Lazy<Vrf> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Vrf,
        };
        unsafe {
            instance.get(Vrf::new)
        }
    }
}

impl ::protobuf::Clear for Vrf {
    fn clear(&mut self) {
        self.name.clear();
        self.rd.clear();
        self.import_rt.clear();
        self.export_rt.clear();
        self.id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Vrf {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Vrf {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DefaultRouteDistance {
    // message fields
    pub external_route_distance: u32,
    pub internal_route_distance: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DefaultRouteDistance {
    fn default() -> &'a DefaultRouteDistance {
        <DefaultRouteDistance as ::protobuf::Message>::default_instance()
    }
}

impl DefaultRouteDistance {
    pub fn new() -> DefaultRouteDistance {
        ::std::default::Default::default()
    }

    // uint32 external_route_distance = 1;


    pub fn get_external_route_distance(&self) -> u32 {
        self.external_route_distance
    }
    pub fn clear_external_route_distance(&mut self) {
        self.external_route_distance = 0;
    }

    // Param is passed by value, moved
    pub fn set_external_route_distance(&mut self, v: u32) {
        self.external_route_distance = v;
    }

    // uint32 internal_route_distance = 2;


    pub fn get_internal_route_distance(&self) -> u32 {
        self.internal_route_distance
    }
    pub fn clear_internal_route_distance(&mut self) {
        self.internal_route_distance = 0;
    }

    // Param is passed by value, moved
    pub fn set_internal_route_distance(&mut self, v: u32) {
        self.internal_route_distance = v;
    }
}

impl ::protobuf::Message for DefaultRouteDistance {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.external_route_distance = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.internal_route_distance = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.external_route_distance != 0 {
            my_size += ::protobuf::rt::value_size(1, self.external_route_distance, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.internal_route_distance != 0 {
            my_size += ::protobuf::rt::value_size(2, self.internal_route_distance, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.external_route_distance != 0 {
            os.write_uint32(1, self.external_route_distance)?;
        }
        if self.internal_route_distance != 0 {
            os.write_uint32(2, self.internal_route_distance)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DefaultRouteDistance {
        DefaultRouteDistance::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "external_route_distance",
                    |m: &DefaultRouteDistance| { &m.external_route_distance },
                    |m: &mut DefaultRouteDistance| { &mut m.external_route_distance },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "internal_route_distance",
                    |m: &DefaultRouteDistance| { &m.internal_route_distance },
                    |m: &mut DefaultRouteDistance| { &mut m.internal_route_distance },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DefaultRouteDistance>(
                    "DefaultRouteDistance",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DefaultRouteDistance {
        static mut instance: ::protobuf::lazy::Lazy<DefaultRouteDistance> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DefaultRouteDistance,
        };
        unsafe {
            instance.get(DefaultRouteDistance::new)
        }
    }
}

impl ::protobuf::Clear for DefaultRouteDistance {
    fn clear(&mut self) {
        self.external_route_distance = 0;
        self.internal_route_distance = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DefaultRouteDistance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DefaultRouteDistance {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Global {
    // message fields
    pub field_as: u32,
    pub router_id: ::std::string::String,
    pub listen_port: i32,
    pub listen_addresses: ::protobuf::RepeatedField<::std::string::String>,
    pub families: ::std::vec::Vec<u32>,
    pub use_multiple_paths: bool,
    pub route_selection_options: ::protobuf::SingularPtrField<RouteSelectionOptionsConfig>,
    pub default_route_distance: ::protobuf::SingularPtrField<DefaultRouteDistance>,
    pub confederation: ::protobuf::SingularPtrField<Confederation>,
    pub graceful_restart: ::protobuf::SingularPtrField<GracefulRestart>,
    pub apply_policy: ::protobuf::SingularPtrField<ApplyPolicy>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Global {
    fn default() -> &'a Global {
        <Global as ::protobuf::Message>::default_instance()
    }
}

impl Global {
    pub fn new() -> Global {
        ::std::default::Default::default()
    }

    // uint32 as = 1;


    pub fn get_field_as(&self) -> u32 {
        self.field_as
    }
    pub fn clear_field_as(&mut self) {
        self.field_as = 0;
    }

    // Param is passed by value, moved
    pub fn set_field_as(&mut self, v: u32) {
        self.field_as = v;
    }

    // string router_id = 2;


    pub fn get_router_id(&self) -> &str {
        &self.router_id
    }
    pub fn clear_router_id(&mut self) {
        self.router_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_router_id(&mut self, v: ::std::string::String) {
        self.router_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_router_id(&mut self) -> &mut ::std::string::String {
        &mut self.router_id
    }

    // Take field
    pub fn take_router_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.router_id, ::std::string::String::new())
    }

    // int32 listen_port = 3;


    pub fn get_listen_port(&self) -> i32 {
        self.listen_port
    }
    pub fn clear_listen_port(&mut self) {
        self.listen_port = 0;
    }

    // Param is passed by value, moved
    pub fn set_listen_port(&mut self, v: i32) {
        self.listen_port = v;
    }

    // repeated string listen_addresses = 4;


    pub fn get_listen_addresses(&self) -> &[::std::string::String] {
        &self.listen_addresses
    }
    pub fn clear_listen_addresses(&mut self) {
        self.listen_addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_listen_addresses(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.listen_addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_listen_addresses(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.listen_addresses
    }

    // Take field
    pub fn take_listen_addresses(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.listen_addresses, ::protobuf::RepeatedField::new())
    }

    // repeated uint32 families = 5;


    pub fn get_families(&self) -> &[u32] {
        &self.families
    }
    pub fn clear_families(&mut self) {
        self.families.clear();
    }

    // Param is passed by value, moved
    pub fn set_families(&mut self, v: ::std::vec::Vec<u32>) {
        self.families = v;
    }

    // Mutable pointer to the field.
    pub fn mut_families(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.families
    }

    // Take field
    pub fn take_families(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.families, ::std::vec::Vec::new())
    }

    // bool use_multiple_paths = 6;


    pub fn get_use_multiple_paths(&self) -> bool {
        self.use_multiple_paths
    }
    pub fn clear_use_multiple_paths(&mut self) {
        self.use_multiple_paths = false;
    }

    // Param is passed by value, moved
    pub fn set_use_multiple_paths(&mut self, v: bool) {
        self.use_multiple_paths = v;
    }

    // .gobgpapi.RouteSelectionOptionsConfig route_selection_options = 7;


    pub fn get_route_selection_options(&self) -> &RouteSelectionOptionsConfig {
        self.route_selection_options.as_ref().unwrap_or_else(|| RouteSelectionOptionsConfig::default_instance())
    }
    pub fn clear_route_selection_options(&mut self) {
        self.route_selection_options.clear();
    }

    pub fn has_route_selection_options(&self) -> bool {
        self.route_selection_options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_route_selection_options(&mut self, v: RouteSelectionOptionsConfig) {
        self.route_selection_options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_route_selection_options(&mut self) -> &mut RouteSelectionOptionsConfig {
        if self.route_selection_options.is_none() {
            self.route_selection_options.set_default();
        }
        self.route_selection_options.as_mut().unwrap()
    }

    // Take field
    pub fn take_route_selection_options(&mut self) -> RouteSelectionOptionsConfig {
        self.route_selection_options.take().unwrap_or_else(|| RouteSelectionOptionsConfig::new())
    }

    // .gobgpapi.DefaultRouteDistance default_route_distance = 8;


    pub fn get_default_route_distance(&self) -> &DefaultRouteDistance {
        self.default_route_distance.as_ref().unwrap_or_else(|| DefaultRouteDistance::default_instance())
    }
    pub fn clear_default_route_distance(&mut self) {
        self.default_route_distance.clear();
    }

    pub fn has_default_route_distance(&self) -> bool {
        self.default_route_distance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_route_distance(&mut self, v: DefaultRouteDistance) {
        self.default_route_distance = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_default_route_distance(&mut self) -> &mut DefaultRouteDistance {
        if self.default_route_distance.is_none() {
            self.default_route_distance.set_default();
        }
        self.default_route_distance.as_mut().unwrap()
    }

    // Take field
    pub fn take_default_route_distance(&mut self) -> DefaultRouteDistance {
        self.default_route_distance.take().unwrap_or_else(|| DefaultRouteDistance::new())
    }

    // .gobgpapi.Confederation confederation = 9;


    pub fn get_confederation(&self) -> &Confederation {
        self.confederation.as_ref().unwrap_or_else(|| Confederation::default_instance())
    }
    pub fn clear_confederation(&mut self) {
        self.confederation.clear();
    }

    pub fn has_confederation(&self) -> bool {
        self.confederation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_confederation(&mut self, v: Confederation) {
        self.confederation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_confederation(&mut self) -> &mut Confederation {
        if self.confederation.is_none() {
            self.confederation.set_default();
        }
        self.confederation.as_mut().unwrap()
    }

    // Take field
    pub fn take_confederation(&mut self) -> Confederation {
        self.confederation.take().unwrap_or_else(|| Confederation::new())
    }

    // .gobgpapi.GracefulRestart graceful_restart = 10;


    pub fn get_graceful_restart(&self) -> &GracefulRestart {
        self.graceful_restart.as_ref().unwrap_or_else(|| GracefulRestart::default_instance())
    }
    pub fn clear_graceful_restart(&mut self) {
        self.graceful_restart.clear();
    }

    pub fn has_graceful_restart(&self) -> bool {
        self.graceful_restart.is_some()
    }

    // Param is passed by value, moved
    pub fn set_graceful_restart(&mut self, v: GracefulRestart) {
        self.graceful_restart = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_graceful_restart(&mut self) -> &mut GracefulRestart {
        if self.graceful_restart.is_none() {
            self.graceful_restart.set_default();
        }
        self.graceful_restart.as_mut().unwrap()
    }

    // Take field
    pub fn take_graceful_restart(&mut self) -> GracefulRestart {
        self.graceful_restart.take().unwrap_or_else(|| GracefulRestart::new())
    }

    // .gobgpapi.ApplyPolicy apply_policy = 11;


    pub fn get_apply_policy(&self) -> &ApplyPolicy {
        self.apply_policy.as_ref().unwrap_or_else(|| ApplyPolicy::default_instance())
    }
    pub fn clear_apply_policy(&mut self) {
        self.apply_policy.clear();
    }

    pub fn has_apply_policy(&self) -> bool {
        self.apply_policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apply_policy(&mut self, v: ApplyPolicy) {
        self.apply_policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_apply_policy(&mut self) -> &mut ApplyPolicy {
        if self.apply_policy.is_none() {
            self.apply_policy.set_default();
        }
        self.apply_policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_apply_policy(&mut self) -> ApplyPolicy {
        self.apply_policy.take().unwrap_or_else(|| ApplyPolicy::new())
    }
}

impl ::protobuf::Message for Global {
    fn is_initialized(&self) -> bool {
        for v in &self.route_selection_options {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.default_route_distance {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.confederation {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.graceful_restart {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.apply_policy {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.field_as = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.router_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.listen_port = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.listen_addresses)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.families)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.use_multiple_paths = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.route_selection_options)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.default_route_distance)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.confederation)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.graceful_restart)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.apply_policy)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_as != 0 {
            my_size += ::protobuf::rt::value_size(1, self.field_as, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.router_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.router_id);
        }
        if self.listen_port != 0 {
            my_size += ::protobuf::rt::value_size(3, self.listen_port, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.listen_addresses {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in &self.families {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.use_multiple_paths != false {
            my_size += 2;
        }
        if let Some(ref v) = self.route_selection_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.default_route_distance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.confederation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.graceful_restart.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.apply_policy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_as != 0 {
            os.write_uint32(1, self.field_as)?;
        }
        if !self.router_id.is_empty() {
            os.write_string(2, &self.router_id)?;
        }
        if self.listen_port != 0 {
            os.write_int32(3, self.listen_port)?;
        }
        for v in &self.listen_addresses {
            os.write_string(4, &v)?;
        };
        for v in &self.families {
            os.write_uint32(5, *v)?;
        };
        if self.use_multiple_paths != false {
            os.write_bool(6, self.use_multiple_paths)?;
        }
        if let Some(ref v) = self.route_selection_options.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.default_route_distance.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.confederation.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.graceful_restart.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.apply_policy.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Global {
        Global::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "as",
                    |m: &Global| { &m.field_as },
                    |m: &mut Global| { &mut m.field_as },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "router_id",
                    |m: &Global| { &m.router_id },
                    |m: &mut Global| { &mut m.router_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "listen_port",
                    |m: &Global| { &m.listen_port },
                    |m: &mut Global| { &mut m.listen_port },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "listen_addresses",
                    |m: &Global| { &m.listen_addresses },
                    |m: &mut Global| { &mut m.listen_addresses },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "families",
                    |m: &Global| { &m.families },
                    |m: &mut Global| { &mut m.families },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "use_multiple_paths",
                    |m: &Global| { &m.use_multiple_paths },
                    |m: &mut Global| { &mut m.use_multiple_paths },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RouteSelectionOptionsConfig>>(
                    "route_selection_options",
                    |m: &Global| { &m.route_selection_options },
                    |m: &mut Global| { &mut m.route_selection_options },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DefaultRouteDistance>>(
                    "default_route_distance",
                    |m: &Global| { &m.default_route_distance },
                    |m: &mut Global| { &mut m.default_route_distance },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Confederation>>(
                    "confederation",
                    |m: &Global| { &m.confederation },
                    |m: &mut Global| { &mut m.confederation },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GracefulRestart>>(
                    "graceful_restart",
                    |m: &Global| { &m.graceful_restart },
                    |m: &mut Global| { &mut m.graceful_restart },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ApplyPolicy>>(
                    "apply_policy",
                    |m: &Global| { &m.apply_policy },
                    |m: &mut Global| { &mut m.apply_policy },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Global>(
                    "Global",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Global {
        static mut instance: ::protobuf::lazy::Lazy<Global> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Global,
        };
        unsafe {
            instance.get(Global::new)
        }
    }
}

impl ::protobuf::Clear for Global {
    fn clear(&mut self) {
        self.field_as = 0;
        self.router_id.clear();
        self.listen_port = 0;
        self.listen_addresses.clear();
        self.families.clear();
        self.use_multiple_paths = false;
        self.route_selection_options.clear();
        self.default_route_distance.clear();
        self.confederation.clear();
        self.graceful_restart.clear();
        self.apply_policy.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Global {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Global {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Confederation {
    // message fields
    pub enabled: bool,
    pub identifier: u32,
    pub member_as_list: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Confederation {
    fn default() -> &'a Confederation {
        <Confederation as ::protobuf::Message>::default_instance()
    }
}

impl Confederation {
    pub fn new() -> Confederation {
        ::std::default::Default::default()
    }

    // bool enabled = 1;


    pub fn get_enabled(&self) -> bool {
        self.enabled
    }
    pub fn clear_enabled(&mut self) {
        self.enabled = false;
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: bool) {
        self.enabled = v;
    }

    // uint32 identifier = 2;


    pub fn get_identifier(&self) -> u32 {
        self.identifier
    }
    pub fn clear_identifier(&mut self) {
        self.identifier = 0;
    }

    // Param is passed by value, moved
    pub fn set_identifier(&mut self, v: u32) {
        self.identifier = v;
    }

    // repeated uint32 member_as_list = 3;


    pub fn get_member_as_list(&self) -> &[u32] {
        &self.member_as_list
    }
    pub fn clear_member_as_list(&mut self) {
        self.member_as_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_member_as_list(&mut self, v: ::std::vec::Vec<u32>) {
        self.member_as_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_member_as_list(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.member_as_list
    }

    // Take field
    pub fn take_member_as_list(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.member_as_list, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Confederation {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enabled = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.identifier = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.member_as_list)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.enabled != false {
            my_size += 2;
        }
        if self.identifier != 0 {
            my_size += ::protobuf::rt::value_size(2, self.identifier, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.member_as_list {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.enabled != false {
            os.write_bool(1, self.enabled)?;
        }
        if self.identifier != 0 {
            os.write_uint32(2, self.identifier)?;
        }
        for v in &self.member_as_list {
            os.write_uint32(3, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Confederation {
        Confederation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "enabled",
                    |m: &Confederation| { &m.enabled },
                    |m: &mut Confederation| { &mut m.enabled },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "identifier",
                    |m: &Confederation| { &m.identifier },
                    |m: &mut Confederation| { &mut m.identifier },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "member_as_list",
                    |m: &Confederation| { &m.member_as_list },
                    |m: &mut Confederation| { &mut m.member_as_list },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Confederation>(
                    "Confederation",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Confederation {
        static mut instance: ::protobuf::lazy::Lazy<Confederation> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Confederation,
        };
        unsafe {
            instance.get(Confederation::new)
        }
    }
}

impl ::protobuf::Clear for Confederation {
    fn clear(&mut self) {
        self.enabled = false;
        self.identifier = 0;
        self.member_as_list.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Confederation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Confederation {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RPKIConf {
    // message fields
    pub address: ::std::string::String,
    pub remote_port: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RPKIConf {
    fn default() -> &'a RPKIConf {
        <RPKIConf as ::protobuf::Message>::default_instance()
    }
}

impl RPKIConf {
    pub fn new() -> RPKIConf {
        ::std::default::Default::default()
    }

    // string address = 1;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // uint32 remote_port = 2;


    pub fn get_remote_port(&self) -> u32 {
        self.remote_port
    }
    pub fn clear_remote_port(&mut self) {
        self.remote_port = 0;
    }

    // Param is passed by value, moved
    pub fn set_remote_port(&mut self, v: u32) {
        self.remote_port = v;
    }
}

impl ::protobuf::Message for RPKIConf {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.remote_port = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if self.remote_port != 0 {
            my_size += ::protobuf::rt::value_size(2, self.remote_port, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if self.remote_port != 0 {
            os.write_uint32(2, self.remote_port)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RPKIConf {
        RPKIConf::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "address",
                    |m: &RPKIConf| { &m.address },
                    |m: &mut RPKIConf| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "remote_port",
                    |m: &RPKIConf| { &m.remote_port },
                    |m: &mut RPKIConf| { &mut m.remote_port },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RPKIConf>(
                    "RPKIConf",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RPKIConf {
        static mut instance: ::protobuf::lazy::Lazy<RPKIConf> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RPKIConf,
        };
        unsafe {
            instance.get(RPKIConf::new)
        }
    }
}

impl ::protobuf::Clear for RPKIConf {
    fn clear(&mut self) {
        self.address.clear();
        self.remote_port = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RPKIConf {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RPKIConf {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RPKIState {
    // message fields
    pub uptime: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub downtime: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub up: bool,
    pub record_ipv4: u32,
    pub record_ipv6: u32,
    pub prefix_ipv4: u32,
    pub prefix_ipv6: u32,
    pub serial: u32,
    pub received_ipv4: i64,
    pub received_ipv6: i64,
    pub serial_notify: i64,
    pub cache_reset: i64,
    pub cache_response: i64,
    pub end_of_data: i64,
    pub error: i64,
    pub serial_query: i64,
    pub reset_query: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RPKIState {
    fn default() -> &'a RPKIState {
        <RPKIState as ::protobuf::Message>::default_instance()
    }
}

impl RPKIState {
    pub fn new() -> RPKIState {
        ::std::default::Default::default()
    }

    // .google.protobuf.Timestamp uptime = 1;


    pub fn get_uptime(&self) -> &::protobuf::well_known_types::Timestamp {
        self.uptime.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
    pub fn clear_uptime(&mut self) {
        self.uptime.clear();
    }

    pub fn has_uptime(&self) -> bool {
        self.uptime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uptime(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.uptime = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uptime(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.uptime.is_none() {
            self.uptime.set_default();
        }
        self.uptime.as_mut().unwrap()
    }

    // Take field
    pub fn take_uptime(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.uptime.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp downtime = 2;


    pub fn get_downtime(&self) -> &::protobuf::well_known_types::Timestamp {
        self.downtime.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
    pub fn clear_downtime(&mut self) {
        self.downtime.clear();
    }

    pub fn has_downtime(&self) -> bool {
        self.downtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_downtime(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.downtime = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_downtime(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.downtime.is_none() {
            self.downtime.set_default();
        }
        self.downtime.as_mut().unwrap()
    }

    // Take field
    pub fn take_downtime(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.downtime.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // bool up = 3;


    pub fn get_up(&self) -> bool {
        self.up
    }
    pub fn clear_up(&mut self) {
        self.up = false;
    }

    // Param is passed by value, moved
    pub fn set_up(&mut self, v: bool) {
        self.up = v;
    }

    // uint32 record_ipv4 = 4;


    pub fn get_record_ipv4(&self) -> u32 {
        self.record_ipv4
    }
    pub fn clear_record_ipv4(&mut self) {
        self.record_ipv4 = 0;
    }

    // Param is passed by value, moved
    pub fn set_record_ipv4(&mut self, v: u32) {
        self.record_ipv4 = v;
    }

    // uint32 record_ipv6 = 5;


    pub fn get_record_ipv6(&self) -> u32 {
        self.record_ipv6
    }
    pub fn clear_record_ipv6(&mut self) {
        self.record_ipv6 = 0;
    }

    // Param is passed by value, moved
    pub fn set_record_ipv6(&mut self, v: u32) {
        self.record_ipv6 = v;
    }

    // uint32 prefix_ipv4 = 6;


    pub fn get_prefix_ipv4(&self) -> u32 {
        self.prefix_ipv4
    }
    pub fn clear_prefix_ipv4(&mut self) {
        self.prefix_ipv4 = 0;
    }

    // Param is passed by value, moved
    pub fn set_prefix_ipv4(&mut self, v: u32) {
        self.prefix_ipv4 = v;
    }

    // uint32 prefix_ipv6 = 7;


    pub fn get_prefix_ipv6(&self) -> u32 {
        self.prefix_ipv6
    }
    pub fn clear_prefix_ipv6(&mut self) {
        self.prefix_ipv6 = 0;
    }

    // Param is passed by value, moved
    pub fn set_prefix_ipv6(&mut self, v: u32) {
        self.prefix_ipv6 = v;
    }

    // uint32 serial = 8;


    pub fn get_serial(&self) -> u32 {
        self.serial
    }
    pub fn clear_serial(&mut self) {
        self.serial = 0;
    }

    // Param is passed by value, moved
    pub fn set_serial(&mut self, v: u32) {
        self.serial = v;
    }

    // int64 received_ipv4 = 9;


    pub fn get_received_ipv4(&self) -> i64 {
        self.received_ipv4
    }
    pub fn clear_received_ipv4(&mut self) {
        self.received_ipv4 = 0;
    }

    // Param is passed by value, moved
    pub fn set_received_ipv4(&mut self, v: i64) {
        self.received_ipv4 = v;
    }

    // int64 received_ipv6 = 10;


    pub fn get_received_ipv6(&self) -> i64 {
        self.received_ipv6
    }
    pub fn clear_received_ipv6(&mut self) {
        self.received_ipv6 = 0;
    }

    // Param is passed by value, moved
    pub fn set_received_ipv6(&mut self, v: i64) {
        self.received_ipv6 = v;
    }

    // int64 serial_notify = 11;


    pub fn get_serial_notify(&self) -> i64 {
        self.serial_notify
    }
    pub fn clear_serial_notify(&mut self) {
        self.serial_notify = 0;
    }

    // Param is passed by value, moved
    pub fn set_serial_notify(&mut self, v: i64) {
        self.serial_notify = v;
    }

    // int64 cache_reset = 12;


    pub fn get_cache_reset(&self) -> i64 {
        self.cache_reset
    }
    pub fn clear_cache_reset(&mut self) {
        self.cache_reset = 0;
    }

    // Param is passed by value, moved
    pub fn set_cache_reset(&mut self, v: i64) {
        self.cache_reset = v;
    }

    // int64 cache_response = 13;


    pub fn get_cache_response(&self) -> i64 {
        self.cache_response
    }
    pub fn clear_cache_response(&mut self) {
        self.cache_response = 0;
    }

    // Param is passed by value, moved
    pub fn set_cache_response(&mut self, v: i64) {
        self.cache_response = v;
    }

    // int64 end_of_data = 14;


    pub fn get_end_of_data(&self) -> i64 {
        self.end_of_data
    }
    pub fn clear_end_of_data(&mut self) {
        self.end_of_data = 0;
    }

    // Param is passed by value, moved
    pub fn set_end_of_data(&mut self, v: i64) {
        self.end_of_data = v;
    }

    // int64 error = 15;


    pub fn get_error(&self) -> i64 {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = 0;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: i64) {
        self.error = v;
    }

    // int64 serial_query = 16;


    pub fn get_serial_query(&self) -> i64 {
        self.serial_query
    }
    pub fn clear_serial_query(&mut self) {
        self.serial_query = 0;
    }

    // Param is passed by value, moved
    pub fn set_serial_query(&mut self, v: i64) {
        self.serial_query = v;
    }

    // int64 reset_query = 17;


    pub fn get_reset_query(&self) -> i64 {
        self.reset_query
    }
    pub fn clear_reset_query(&mut self) {
        self.reset_query = 0;
    }

    // Param is passed by value, moved
    pub fn set_reset_query(&mut self, v: i64) {
        self.reset_query = v;
    }
}

impl ::protobuf::Message for RPKIState {
    fn is_initialized(&self) -> bool {
        for v in &self.uptime {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.downtime {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.uptime)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.downtime)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.up = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.record_ipv4 = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.record_ipv6 = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.prefix_ipv4 = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.prefix_ipv6 = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.serial = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.received_ipv4 = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.received_ipv6 = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.serial_notify = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.cache_reset = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.cache_response = tmp;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.end_of_data = tmp;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.error = tmp;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.serial_query = tmp;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.reset_query = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.uptime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.downtime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.up != false {
            my_size += 2;
        }
        if self.record_ipv4 != 0 {
            my_size += ::protobuf::rt::value_size(4, self.record_ipv4, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.record_ipv6 != 0 {
            my_size += ::protobuf::rt::value_size(5, self.record_ipv6, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.prefix_ipv4 != 0 {
            my_size += ::protobuf::rt::value_size(6, self.prefix_ipv4, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.prefix_ipv6 != 0 {
            my_size += ::protobuf::rt::value_size(7, self.prefix_ipv6, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.serial != 0 {
            my_size += ::protobuf::rt::value_size(8, self.serial, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.received_ipv4 != 0 {
            my_size += ::protobuf::rt::value_size(9, self.received_ipv4, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.received_ipv6 != 0 {
            my_size += ::protobuf::rt::value_size(10, self.received_ipv6, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.serial_notify != 0 {
            my_size += ::protobuf::rt::value_size(11, self.serial_notify, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.cache_reset != 0 {
            my_size += ::protobuf::rt::value_size(12, self.cache_reset, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.cache_response != 0 {
            my_size += ::protobuf::rt::value_size(13, self.cache_response, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.end_of_data != 0 {
            my_size += ::protobuf::rt::value_size(14, self.end_of_data, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.error != 0 {
            my_size += ::protobuf::rt::value_size(15, self.error, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.serial_query != 0 {
            my_size += ::protobuf::rt::value_size(16, self.serial_query, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.reset_query != 0 {
            my_size += ::protobuf::rt::value_size(17, self.reset_query, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.uptime.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.downtime.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.up != false {
            os.write_bool(3, self.up)?;
        }
        if self.record_ipv4 != 0 {
            os.write_uint32(4, self.record_ipv4)?;
        }
        if self.record_ipv6 != 0 {
            os.write_uint32(5, self.record_ipv6)?;
        }
        if self.prefix_ipv4 != 0 {
            os.write_uint32(6, self.prefix_ipv4)?;
        }
        if self.prefix_ipv6 != 0 {
            os.write_uint32(7, self.prefix_ipv6)?;
        }
        if self.serial != 0 {
            os.write_uint32(8, self.serial)?;
        }
        if self.received_ipv4 != 0 {
            os.write_int64(9, self.received_ipv4)?;
        }
        if self.received_ipv6 != 0 {
            os.write_int64(10, self.received_ipv6)?;
        }
        if self.serial_notify != 0 {
            os.write_int64(11, self.serial_notify)?;
        }
        if self.cache_reset != 0 {
            os.write_int64(12, self.cache_reset)?;
        }
        if self.cache_response != 0 {
            os.write_int64(13, self.cache_response)?;
        }
        if self.end_of_data != 0 {
            os.write_int64(14, self.end_of_data)?;
        }
        if self.error != 0 {
            os.write_int64(15, self.error)?;
        }
        if self.serial_query != 0 {
            os.write_int64(16, self.serial_query)?;
        }
        if self.reset_query != 0 {
            os.write_int64(17, self.reset_query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RPKIState {
        RPKIState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "uptime",
                    |m: &RPKIState| { &m.uptime },
                    |m: &mut RPKIState| { &mut m.uptime },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "downtime",
                    |m: &RPKIState| { &m.downtime },
                    |m: &mut RPKIState| { &mut m.downtime },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "up",
                    |m: &RPKIState| { &m.up },
                    |m: &mut RPKIState| { &mut m.up },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "record_ipv4",
                    |m: &RPKIState| { &m.record_ipv4 },
                    |m: &mut RPKIState| { &mut m.record_ipv4 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "record_ipv6",
                    |m: &RPKIState| { &m.record_ipv6 },
                    |m: &mut RPKIState| { &mut m.record_ipv6 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "prefix_ipv4",
                    |m: &RPKIState| { &m.prefix_ipv4 },
                    |m: &mut RPKIState| { &mut m.prefix_ipv4 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "prefix_ipv6",
                    |m: &RPKIState| { &m.prefix_ipv6 },
                    |m: &mut RPKIState| { &mut m.prefix_ipv6 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "serial",
                    |m: &RPKIState| { &m.serial },
                    |m: &mut RPKIState| { &mut m.serial },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "received_ipv4",
                    |m: &RPKIState| { &m.received_ipv4 },
                    |m: &mut RPKIState| { &mut m.received_ipv4 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "received_ipv6",
                    |m: &RPKIState| { &m.received_ipv6 },
                    |m: &mut RPKIState| { &mut m.received_ipv6 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "serial_notify",
                    |m: &RPKIState| { &m.serial_notify },
                    |m: &mut RPKIState| { &mut m.serial_notify },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "cache_reset",
                    |m: &RPKIState| { &m.cache_reset },
                    |m: &mut RPKIState| { &mut m.cache_reset },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "cache_response",
                    |m: &RPKIState| { &m.cache_response },
                    |m: &mut RPKIState| { &mut m.cache_response },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "end_of_data",
                    |m: &RPKIState| { &m.end_of_data },
                    |m: &mut RPKIState| { &mut m.end_of_data },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "error",
                    |m: &RPKIState| { &m.error },
                    |m: &mut RPKIState| { &mut m.error },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "serial_query",
                    |m: &RPKIState| { &m.serial_query },
                    |m: &mut RPKIState| { &mut m.serial_query },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "reset_query",
                    |m: &RPKIState| { &m.reset_query },
                    |m: &mut RPKIState| { &mut m.reset_query },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RPKIState>(
                    "RPKIState",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RPKIState {
        static mut instance: ::protobuf::lazy::Lazy<RPKIState> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RPKIState,
        };
        unsafe {
            instance.get(RPKIState::new)
        }
    }
}

impl ::protobuf::Clear for RPKIState {
    fn clear(&mut self) {
        self.uptime.clear();
        self.downtime.clear();
        self.up = false;
        self.record_ipv4 = 0;
        self.record_ipv6 = 0;
        self.prefix_ipv4 = 0;
        self.prefix_ipv6 = 0;
        self.serial = 0;
        self.received_ipv4 = 0;
        self.received_ipv6 = 0;
        self.serial_notify = 0;
        self.cache_reset = 0;
        self.cache_response = 0;
        self.end_of_data = 0;
        self.error = 0;
        self.serial_query = 0;
        self.reset_query = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RPKIState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RPKIState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Rpki {
    // message fields
    pub conf: ::protobuf::SingularPtrField<RPKIConf>,
    pub state: ::protobuf::SingularPtrField<RPKIState>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Rpki {
    fn default() -> &'a Rpki {
        <Rpki as ::protobuf::Message>::default_instance()
    }
}

impl Rpki {
    pub fn new() -> Rpki {
        ::std::default::Default::default()
    }

    // .gobgpapi.RPKIConf conf = 1;


    pub fn get_conf(&self) -> &RPKIConf {
        self.conf.as_ref().unwrap_or_else(|| RPKIConf::default_instance())
    }
    pub fn clear_conf(&mut self) {
        self.conf.clear();
    }

    pub fn has_conf(&self) -> bool {
        self.conf.is_some()
    }

    // Param is passed by value, moved
    pub fn set_conf(&mut self, v: RPKIConf) {
        self.conf = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_conf(&mut self) -> &mut RPKIConf {
        if self.conf.is_none() {
            self.conf.set_default();
        }
        self.conf.as_mut().unwrap()
    }

    // Take field
    pub fn take_conf(&mut self) -> RPKIConf {
        self.conf.take().unwrap_or_else(|| RPKIConf::new())
    }

    // .gobgpapi.RPKIState state = 2;


    pub fn get_state(&self) -> &RPKIState {
        self.state.as_ref().unwrap_or_else(|| RPKIState::default_instance())
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: RPKIState) {
        self.state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut RPKIState {
        if self.state.is_none() {
            self.state.set_default();
        }
        self.state.as_mut().unwrap()
    }

    // Take field
    pub fn take_state(&mut self) -> RPKIState {
        self.state.take().unwrap_or_else(|| RPKIState::new())
    }
}

impl ::protobuf::Message for Rpki {
    fn is_initialized(&self) -> bool {
        for v in &self.conf {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.state {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.conf)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.state)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.conf.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.conf.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.state.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Rpki {
        Rpki::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RPKIConf>>(
                    "conf",
                    |m: &Rpki| { &m.conf },
                    |m: &mut Rpki| { &mut m.conf },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RPKIState>>(
                    "state",
                    |m: &Rpki| { &m.state },
                    |m: &mut Rpki| { &mut m.state },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Rpki>(
                    "Rpki",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Rpki {
        static mut instance: ::protobuf::lazy::Lazy<Rpki> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Rpki,
        };
        unsafe {
            instance.get(Rpki::new)
        }
    }
}

impl ::protobuf::Clear for Rpki {
    fn clear(&mut self) {
        self.conf.clear();
        self.state.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Rpki {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Rpki {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TableType {
    GLOBAL = 0,
    LOCAL = 1,
    ADJ_IN = 2,
    ADJ_OUT = 3,
    VRF = 4,
}

impl ::protobuf::ProtobufEnum for TableType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TableType> {
        match value {
            0 => ::std::option::Option::Some(TableType::GLOBAL),
            1 => ::std::option::Option::Some(TableType::LOCAL),
            2 => ::std::option::Option::Some(TableType::ADJ_IN),
            3 => ::std::option::Option::Some(TableType::ADJ_OUT),
            4 => ::std::option::Option::Some(TableType::VRF),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TableType] = &[
            TableType::GLOBAL,
            TableType::LOCAL,
            TableType::ADJ_IN,
            TableType::ADJ_OUT,
            TableType::VRF,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("TableType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for TableType {
}

impl ::std::default::Default for TableType {
    fn default() -> Self {
        TableType::GLOBAL
    }
}

impl ::protobuf::reflect::ProtobufValue for TableType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TableLookupOption {
    LOOKUP_EXACT = 0,
    LOOKUP_LONGER = 1,
    LOOKUP_SHORTER = 2,
}

impl ::protobuf::ProtobufEnum for TableLookupOption {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TableLookupOption> {
        match value {
            0 => ::std::option::Option::Some(TableLookupOption::LOOKUP_EXACT),
            1 => ::std::option::Option::Some(TableLookupOption::LOOKUP_LONGER),
            2 => ::std::option::Option::Some(TableLookupOption::LOOKUP_SHORTER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TableLookupOption] = &[
            TableLookupOption::LOOKUP_EXACT,
            TableLookupOption::LOOKUP_LONGER,
            TableLookupOption::LOOKUP_SHORTER,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("TableLookupOption", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for TableLookupOption {
}

impl ::std::default::Default for TableLookupOption {
    fn default() -> Self {
        TableLookupOption::LOOKUP_EXACT
    }
}

impl ::protobuf::reflect::ProtobufValue for TableLookupOption {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DefinedType {
    PREFIX = 0,
    NEIGHBOR = 1,
    TAG = 2,
    AS_PATH = 3,
    COMMUNITY = 4,
    EXT_COMMUNITY = 5,
    LARGE_COMMUNITY = 6,
    NEXT_HOP = 7,
}

impl ::protobuf::ProtobufEnum for DefinedType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DefinedType> {
        match value {
            0 => ::std::option::Option::Some(DefinedType::PREFIX),
            1 => ::std::option::Option::Some(DefinedType::NEIGHBOR),
            2 => ::std::option::Option::Some(DefinedType::TAG),
            3 => ::std::option::Option::Some(DefinedType::AS_PATH),
            4 => ::std::option::Option::Some(DefinedType::COMMUNITY),
            5 => ::std::option::Option::Some(DefinedType::EXT_COMMUNITY),
            6 => ::std::option::Option::Some(DefinedType::LARGE_COMMUNITY),
            7 => ::std::option::Option::Some(DefinedType::NEXT_HOP),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DefinedType] = &[
            DefinedType::PREFIX,
            DefinedType::NEIGHBOR,
            DefinedType::TAG,
            DefinedType::AS_PATH,
            DefinedType::COMMUNITY,
            DefinedType::EXT_COMMUNITY,
            DefinedType::LARGE_COMMUNITY,
            DefinedType::NEXT_HOP,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DefinedType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DefinedType {
}

impl ::std::default::Default for DefinedType {
    fn default() -> Self {
        DefinedType::PREFIX
    }
}

impl ::protobuf::reflect::ProtobufValue for DefinedType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MatchType {
    ANY = 0,
    ALL = 1,
    INVERT = 2,
}

impl ::protobuf::ProtobufEnum for MatchType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MatchType> {
        match value {
            0 => ::std::option::Option::Some(MatchType::ANY),
            1 => ::std::option::Option::Some(MatchType::ALL),
            2 => ::std::option::Option::Some(MatchType::INVERT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MatchType] = &[
            MatchType::ANY,
            MatchType::ALL,
            MatchType::INVERT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("MatchType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for MatchType {
}

impl ::std::default::Default for MatchType {
    fn default() -> Self {
        MatchType::ANY
    }
}

impl ::protobuf::reflect::ProtobufValue for MatchType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AsPathLengthType {
    EQ = 0,
    GE = 1,
    LE = 2,
}

impl ::protobuf::ProtobufEnum for AsPathLengthType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AsPathLengthType> {
        match value {
            0 => ::std::option::Option::Some(AsPathLengthType::EQ),
            1 => ::std::option::Option::Some(AsPathLengthType::GE),
            2 => ::std::option::Option::Some(AsPathLengthType::LE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AsPathLengthType] = &[
            AsPathLengthType::EQ,
            AsPathLengthType::GE,
            AsPathLengthType::LE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("AsPathLengthType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for AsPathLengthType {
}

impl ::std::default::Default for AsPathLengthType {
    fn default() -> Self {
        AsPathLengthType::EQ
    }
}

impl ::protobuf::reflect::ProtobufValue for AsPathLengthType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum RouteAction {
    NONE = 0,
    ACCEPT = 1,
    REJECT = 2,
}

impl ::protobuf::ProtobufEnum for RouteAction {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RouteAction> {
        match value {
            0 => ::std::option::Option::Some(RouteAction::NONE),
            1 => ::std::option::Option::Some(RouteAction::ACCEPT),
            2 => ::std::option::Option::Some(RouteAction::REJECT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RouteAction] = &[
            RouteAction::NONE,
            RouteAction::ACCEPT,
            RouteAction::REJECT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("RouteAction", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for RouteAction {
}

impl ::std::default::Default for RouteAction {
    fn default() -> Self {
        RouteAction::NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteAction {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CommunityActionType {
    COMMUNITY_ADD = 0,
    COMMUNITY_REMOVE = 1,
    COMMUNITY_REPLACE = 2,
}

impl ::protobuf::ProtobufEnum for CommunityActionType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CommunityActionType> {
        match value {
            0 => ::std::option::Option::Some(CommunityActionType::COMMUNITY_ADD),
            1 => ::std::option::Option::Some(CommunityActionType::COMMUNITY_REMOVE),
            2 => ::std::option::Option::Some(CommunityActionType::COMMUNITY_REPLACE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CommunityActionType] = &[
            CommunityActionType::COMMUNITY_ADD,
            CommunityActionType::COMMUNITY_REMOVE,
            CommunityActionType::COMMUNITY_REPLACE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CommunityActionType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CommunityActionType {
}

impl ::std::default::Default for CommunityActionType {
    fn default() -> Self {
        CommunityActionType::COMMUNITY_ADD
    }
}

impl ::protobuf::reflect::ProtobufValue for CommunityActionType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MedActionType {
    MED_MOD = 0,
    MED_REPLACE = 1,
}

impl ::protobuf::ProtobufEnum for MedActionType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MedActionType> {
        match value {
            0 => ::std::option::Option::Some(MedActionType::MED_MOD),
            1 => ::std::option::Option::Some(MedActionType::MED_REPLACE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MedActionType] = &[
            MedActionType::MED_MOD,
            MedActionType::MED_REPLACE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("MedActionType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for MedActionType {
}

impl ::std::default::Default for MedActionType {
    fn default() -> Self {
        MedActionType::MED_MOD
    }
}

impl ::protobuf::reflect::ProtobufValue for MedActionType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PolicyDirection {
    UNKNOWN = 0,
    IMPORT = 1,
    EXPORT = 2,
}

impl ::protobuf::ProtobufEnum for PolicyDirection {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PolicyDirection> {
        match value {
            0 => ::std::option::Option::Some(PolicyDirection::UNKNOWN),
            1 => ::std::option::Option::Some(PolicyDirection::IMPORT),
            2 => ::std::option::Option::Some(PolicyDirection::EXPORT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PolicyDirection] = &[
            PolicyDirection::UNKNOWN,
            PolicyDirection::IMPORT,
            PolicyDirection::EXPORT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("PolicyDirection", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for PolicyDirection {
}

impl ::std::default::Default for PolicyDirection {
    fn default() -> Self {
        PolicyDirection::UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for PolicyDirection {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0bgobgp.proto\x12\x08gobgpapi\x1a\x19google/protobuf/any.proto\x1a\
    \x1bgoogle/protobuf/empty.proto\x1a\x1fgoogle/protobuf/timestamp.proto\"\
    ;\n\x0fStartBgpRequest\x12(\n\x06global\x18\x01\x20\x01(\x0b2\x10.gobgpa\
    pi.GlobalR\x06global\"\x10\n\x0eStopBgpRequest\"\x0f\n\rGetBgpRequest\":\
    \n\x0eGetBgpResponse\x12(\n\x06global\x18\x01\x20\x01(\x0b2\x10.gobgpapi\
    .GlobalR\x06global\"4\n\x0eAddPeerRequest\x12\"\n\x04peer\x18\x01\x20\
    \x01(\x0b2\x0e.gobgpapi.PeerR\x04peer\"K\n\x11DeletePeerRequest\x12\x18\
    \n\x07address\x18\x01\x20\x01(\tR\x07address\x12\x1c\n\tinterface\x18\
    \x02\x20\x01(\tR\tinterface\"W\n\x0fListPeerRequest\x12\x18\n\x07address\
    \x18\x01\x20\x01(\tR\x07address\x12*\n\x10enableAdvertised\x18\x02\x20\
    \x01(\x08R\x10enableAdvertised\"6\n\x10ListPeerResponse\x12\"\n\x04peer\
    \x18\x01\x20\x01(\x0b2\x0e.gobgpapi.PeerR\x04peer\"`\n\x11UpdatePeerRequ\
    est\x12\"\n\x04peer\x18\x01\x20\x01(\x0b2\x0e.gobgpapi.PeerR\x04peer\x12\
    '\n\x10do_soft_reset_in\x18\x02\x20\x01(\x08R\rdoSoftResetIn\"C\n\x12Upd\
    atePeerResponse\x12-\n\x13needs_soft_reset_in\x18\x01\x20\x01(\x08R\x10n\
    eedsSoftResetIn\"\xe4\x01\n\x10ResetPeerRequest\x12\x18\n\x07address\x18\
    \x01\x20\x01(\tR\x07address\x12$\n\rcommunication\x18\x02\x20\x01(\tR\rc\
    ommunication\x12\x12\n\x04soft\x18\x03\x20\x01(\x08R\x04soft\x12K\n\tdir\
    ection\x18\x04\x20\x01(\x0e2-.gobgpapi.ResetPeerRequest.SoftResetDirecti\
    onR\tdirection\"/\n\x12SoftResetDirection\x12\x06\n\x02IN\x10\0\x12\x07\
    \n\x03OUT\x10\x01\x12\x08\n\x04BOTH\x10\x02\"U\n\x13ShutdownPeerRequest\
    \x12\x18\n\x07address\x18\x01\x20\x01(\tR\x07address\x12$\n\rcommunicati\
    on\x18\x02\x20\x01(\tR\rcommunication\"-\n\x11EnablePeerRequest\x12\x18\
    \n\x07address\x18\x01\x20\x01(\tR\x07address\"T\n\x12DisablePeerRequest\
    \x12\x18\n\x07address\x18\x01\x20\x01(\tR\x07address\x12$\n\rcommunicati\
    on\x18\x02\x20\x01(\tR\rcommunication\"H\n\x12MonitorPeerRequest\x12\x18\
    \n\x07address\x18\x01\x20\x01(\tR\x07address\x12\x18\n\x07current\x18\
    \x02\x20\x01(\x08R\x07current\"9\n\x13MonitorPeerResponse\x12\"\n\x04pee\
    r\x18\x01\x20\x01(\x0b2\x0e.gobgpapi.PeerR\x04peer\"I\n\x13AddPeerGroupR\
    equest\x122\n\npeer_group\x18\x01\x20\x01(\x0b2\x13.gobgpapi.PeerGroupR\
    \tpeerGroup\",\n\x16DeletePeerGroupRequest\x12\x12\n\x04name\x18\x01\x20\
    \x01(\tR\x04name\"u\n\x16UpdatePeerGroupRequest\x122\n\npeer_group\x18\
    \x01\x20\x01(\x0b2\x13.gobgpapi.PeerGroupR\tpeerGroup\x12'\n\x10do_soft_\
    reset_in\x18\x02\x20\x01(\x08R\rdoSoftResetIn\"H\n\x17UpdatePeerGroupRes\
    ponse\x12-\n\x13needs_soft_reset_in\x18\x01\x20\x01(\x08R\x10needsSoftRe\
    setIn\"a\n\x19AddDynamicNeighborRequest\x12D\n\x10dynamic_neighbor\x18\
    \x01\x20\x01(\x0b2\x19.gobgpapi.DynamicNeighborR\x0fdynamicNeighbor\"\
    \x7f\n\x0eAddPathRequest\x122\n\ntable_type\x18\x01\x20\x01(\x0e2\x13.go\
    bgpapi.TableTypeR\ttableType\x12\x15\n\x06vrf_id\x18\x02\x20\x01(\tR\x05\
    vrfId\x12\"\n\x04path\x18\x03\x20\x01(\x0b2\x0e.gobgpapi.PathR\x04path\"\
    %\n\x0fAddPathResponse\x12\x12\n\x04uuid\x18\x01\x20\x01(\x0cR\x04uuid\"\
    \xc0\x01\n\x11DeletePathRequest\x122\n\ntable_type\x18\x01\x20\x01(\x0e2\
    \x13.gobgpapi.TableTypeR\ttableType\x12\x15\n\x06vrf_id\x18\x02\x20\x01(\
    \tR\x05vrfId\x12(\n\x06family\x18\x03\x20\x01(\x0b2\x10.gobgpapi.FamilyR\
    \x06family\x12\"\n\x04path\x18\x04\x20\x01(\x0b2\x0e.gobgpapi.PathR\x04p\
    ath\x12\x12\n\x04uuid\x18\x05\x20\x01(\x0cR\x04uuid\"\xc8\x02\n\x0fListP\
    athRequest\x122\n\ntable_type\x18\x01\x20\x01(\x0e2\x13.gobgpapi.TableTy\
    peR\ttableType\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12(\n\x06f\
    amily\x18\x03\x20\x01(\x0b2\x10.gobgpapi.FamilyR\x06family\x127\n\x08pre\
    fixes\x18\x04\x20\x03(\x0b2\x1b.gobgpapi.TableLookupPrefixR\x08prefixes\
    \x12?\n\tsort_type\x18\x05\x20\x01(\x0e2\".gobgpapi.ListPathRequest.Sort\
    TypeR\x08sortType\x12'\n\x0fenable_filtered\x18\x06\x20\x01(\x08R\x0eena\
    bleFiltered\"\x20\n\x08SortType\x12\x08\n\x04NONE\x10\0\x12\n\n\x06PREFI\
    X\x10\x01\"K\n\x10ListPathResponse\x127\n\x0bdestination\x18\x01\x20\x01\
    (\x0b2\x15.gobgpapi.DestinationR\x0bdestination\"\x87\x01\n\x14AddPathSt\
    reamRequest\x122\n\ntable_type\x18\x01\x20\x01(\x0e2\x13.gobgpapi.TableT\
    ypeR\ttableType\x12\x15\n\x06vrf_id\x18\x02\x20\x01(\tR\x05vrfId\x12$\n\
    \x05paths\x18\x03\x20\x03(\x0b2\x0e.gobgpapi.PathR\x05paths\"\x83\x01\n\
    \x0fGetTableRequest\x122\n\ntable_type\x18\x01\x20\x01(\x0e2\x13.gobgpap\
    i.TableTypeR\ttableType\x12(\n\x06family\x18\x02\x20\x01(\x0b2\x10.gobgp\
    api.FamilyR\x06family\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\"y\n\
    \x10GetTableResponse\x12'\n\x0fnum_destination\x18\x01\x20\x01(\x04R\x0e\
    numDestination\x12\x19\n\x08num_path\x18\x02\x20\x01(\x04R\x07numPath\
    \x12!\n\x0cnum_accepted\x18\x03\x20\x01(\x04R\x0bnumAccepted\"\xc2\x01\n\
    \x13MonitorTableRequest\x122\n\ntable_type\x18\x01\x20\x01(\x0e2\x13.gob\
    gpapi.TableTypeR\ttableType\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04nam\
    e\x12(\n\x06family\x18\x03\x20\x01(\x0b2\x10.gobgpapi.FamilyR\x06family\
    \x12\x18\n\x07current\x18\x04\x20\x01(\x08R\x07current\x12\x1f\n\x0bpost\
    _policy\x18\x05\x20\x01(\x08R\npostPolicy\":\n\x14MonitorTableResponse\
    \x12\"\n\x04path\x18\x01\x20\x01(\x0b2\x0e.gobgpapi.PathR\x04path\"0\n\r\
    AddVrfRequest\x12\x1f\n\x03vrf\x18\x01\x20\x01(\x0b2\r.gobgpapi.VrfR\x03\
    vrf\"&\n\x10DeleteVrfRequest\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04na\
    me\"$\n\x0eListVrfRequest\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\
    \"2\n\x0fListVrfResponse\x12\x1f\n\x03vrf\x18\x01\x20\x01(\x0b2\r.gobgpa\
    pi.VrfR\x03vrf\"x\n\x10AddPolicyRequest\x12(\n\x06policy\x18\x01\x20\x01\
    (\x0b2\x10.gobgpapi.PolicyR\x06policy\x12:\n\x19refer_existing_statement\
    s\x18\x02\x20\x01(\x08R\x17referExistingStatements\"\x82\x01\n\x13Delete\
    PolicyRequest\x12(\n\x06policy\x18\x01\x20\x01(\x0b2\x10.gobgpapi.Policy\
    R\x06policy\x12/\n\x13preserve_statements\x18\x02\x20\x01(\x08R\x12prese\
    rveStatements\x12\x10\n\x03all\x18\x03\x20\x01(\x08R\x03all\"'\n\x11List\
    PolicyRequest\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\">\n\x12List\
    PolicyResponse\x12(\n\x06policy\x18\x01\x20\x01(\x0b2\x10.gobgpapi.Polic\
    yR\x06policy\"\xb9\x01\n\x12SetPoliciesRequest\x127\n\x0cdefined_sets\
    \x18\x01\x20\x03(\x0b2\x14.gobgpapi.DefinedSetR\x0bdefinedSets\x12,\n\
    \x08policies\x18\x02\x20\x03(\x0b2\x10.gobgpapi.PolicyR\x08policies\x12<\
    \n\x0bassignments\x18\x03\x20\x03(\x0b2\x1a.gobgpapi.PolicyAssignmentR\
    \x0bassignments\"M\n\x14AddDefinedSetRequest\x125\n\x0bdefined_set\x18\
    \x01\x20\x01(\x0b2\x14.gobgpapi.DefinedSetR\ndefinedSet\"b\n\x17DeleteDe\
    finedSetRequest\x125\n\x0bdefined_set\x18\x01\x20\x01(\x0b2\x14.gobgpapi\
    .DefinedSetR\ndefinedSet\x12\x10\n\x03all\x18\x02\x20\x01(\x08R\x03all\"\
    e\n\x15ListDefinedSetRequest\x128\n\x0cdefined_type\x18\x01\x20\x01(\x0e\
    2\x15.gobgpapi.DefinedTypeR\x0bdefinedType\x12\x12\n\x04name\x18\x02\x20\
    \x01(\tR\x04name\"O\n\x16ListDefinedSetResponse\x125\n\x0bdefined_set\
    \x18\x01\x20\x01(\x0b2\x14.gobgpapi.DefinedSetR\ndefinedSet\"H\n\x13AddS\
    tatementRequest\x121\n\tstatement\x18\x01\x20\x01(\x0b2\x13.gobgpapi.Sta\
    tementR\tstatement\"]\n\x16DeleteStatementRequest\x121\n\tstatement\x18\
    \x01\x20\x01(\x0b2\x13.gobgpapi.StatementR\tstatement\x12\x10\n\x03all\
    \x18\x02\x20\x01(\x08R\x03all\"*\n\x14ListStatementRequest\x12\x12\n\x04\
    name\x18\x01\x20\x01(\tR\x04name\"J\n\x15ListStatementResponse\x121\n\ts\
    tatement\x18\x01\x20\x01(\x0b2\x13.gobgpapi.StatementR\tstatement\"X\n\
    \x1aAddPolicyAssignmentRequest\x12:\n\nassignment\x18\x01\x20\x01(\x0b2\
    \x1a.gobgpapi.PolicyAssignmentR\nassignment\"m\n\x1dDeletePolicyAssignme\
    ntRequest\x12:\n\nassignment\x18\x01\x20\x01(\x0b2\x1a.gobgpapi.PolicyAs\
    signmentR\nassignment\x12\x10\n\x03all\x18\x02\x20\x01(\x08R\x03all\"j\n\
    \x1bListPolicyAssignmentRequest\x12\x12\n\x04name\x18\x01\x20\x01(\tR\
    \x04name\x127\n\tdirection\x18\x02\x20\x01(\x0e2\x19.gobgpapi.PolicyDire\
    ctionR\tdirection\"Z\n\x1cListPolicyAssignmentResponse\x12:\n\nassignmen\
    t\x18\x01\x20\x01(\x0b2\x1a.gobgpapi.PolicyAssignmentR\nassignment\"X\n\
    \x1aSetPolicyAssignmentRequest\x12:\n\nassignment\x18\x01\x20\x01(\x0b2\
    \x1a.gobgpapi.PolicyAssignmentR\nassignment\"Z\n\x0eAddRpkiRequest\x12\
    \x18\n\x07address\x18\x01\x20\x01(\tR\x07address\x12\x12\n\x04port\x18\
    \x02\x20\x01(\rR\x04port\x12\x1a\n\x08lifetime\x18\x03\x20\x01(\x03R\x08\
    lifetime\"A\n\x11DeleteRpkiRequest\x12\x18\n\x07address\x18\x01\x20\x01(\
    \tR\x07address\x12\x12\n\x04port\x18\x02\x20\x01(\rR\x04port\";\n\x0fLis\
    tRpkiRequest\x12(\n\x06family\x18\x01\x20\x01(\x0b2\x10.gobgpapi.FamilyR\
    \x06family\":\n\x10ListRpkiResponse\x12&\n\x06server\x18\x01\x20\x01(\
    \x0b2\x0e.gobgpapi.RpkiR\x06server\"A\n\x11EnableRpkiRequest\x12\x18\n\
    \x07address\x18\x01\x20\x01(\tR\x07address\x12\x12\n\x04port\x18\x02\x20\
    \x01(\rR\x04port\"B\n\x12DisableRpkiRequest\x12\x18\n\x07address\x18\x01\
    \x20\x01(\tR\x07address\x12\x12\n\x04port\x18\x02\x20\x01(\rR\x04port\"T\
    \n\x10ResetRpkiRequest\x12\x18\n\x07address\x18\x01\x20\x01(\tR\x07addre\
    ss\x12\x12\n\x04port\x18\x02\x20\x01(\rR\x04port\x12\x12\n\x04soft\x18\
    \x03\x20\x01(\x08R\x04soft\"@\n\x14ListRpkiTableRequest\x12(\n\x06family\
    \x18\x01\x20\x01(\x0b2\x10.gobgpapi.FamilyR\x06family\"8\n\x15ListRpkiTa\
    bleResponse\x12\x1f\n\x03roa\x18\x01\x20\x01(\x0b2\r.gobgpapi.RoaR\x03ro\
    a\"\xa3\x02\n\x12EnableZebraRequest\x12\x10\n\x03url\x18\x01\x20\x01(\tR\
    \x03url\x12\x1f\n\x0broute_types\x18\x02\x20\x03(\tR\nrouteTypes\x12\x18\
    \n\x07version\x18\x03\x20\x01(\rR\x07version\x124\n\x16nexthop_trigger_e\
    nable\x18\x04\x20\x01(\x08R\x14nexthopTriggerEnable\x122\n\x15nexthop_tr\
    igger_delay\x18\x05\x20\x01(\rR\x13nexthopTriggerDelay\x121\n\x15mpls_la\
    bel_range_size\x18\x06\x20\x01(\rR\x12mplsLabelRangeSize\x12#\n\rsoftwar\
    e_name\x18\x07\x20\x01(\tR\x0csoftwareName\"\x9d\x01\n\x10EnableMrtReque\
    st\x12\x1b\n\tdump_type\x18\x01\x20\x01(\x05R\x08dumpType\x12\x1a\n\x08f\
    ilename\x18\x02\x20\x01(\tR\x08filename\x12#\n\rdump_interval\x18\x03\
    \x20\x01(\x04R\x0cdumpInterval\x12+\n\x11rotation_interval\x18\x04\x20\
    \x01(\x04R\x10rotationInterval\"\x13\n\x11DisableMrtRequest\"\xa8\x02\n\
    \rAddBmpRequest\x12\x18\n\x07address\x18\x01\x20\x01(\tR\x07address\x12\
    \x12\n\x04port\x18\x02\x20\x01(\rR\x04port\x12@\n\x06policy\x18\x03\x20\
    \x01(\x0e2(.gobgpapi.AddBmpRequest.MonitoringPolicyR\x06policy\x12,\n\
    \x11StatisticsTimeout\x18\x04\x20\x01(\x05R\x11StatisticsTimeout\x12\x18\
    \n\x07SysName\x18\x05\x20\x01(\tR\x07SysName\x12\x1a\n\x08SysDescr\x18\
    \x06\x20\x01(\tR\x08SysDescr\"C\n\x10MonitoringPolicy\x12\x07\n\x03PRE\
    \x10\0\x12\x08\n\x04POST\x10\x01\x12\x08\n\x04BOTH\x10\x02\x12\t\n\x05LO\
    CAL\x10\x03\x12\x07\n\x03ALL\x10\x04\"@\n\x10DeleteBmpRequest\x12\x18\n\
    \x07address\x18\x01\x20\x01(\tR\x07address\x12\x12\n\x04port\x18\x02\x20\
    \x01(\rR\x04port\"\xf5\x03\n\x06Family\x12&\n\x03afi\x18\x01\x20\x01(\
    \x0e2\x14.gobgpapi.Family.AfiR\x03afi\x12)\n\x04safi\x18\x02\x20\x01(\
    \x0e2\x15.gobgpapi.Family.SafiR\x04safi\"^\n\x03Afi\x12\x0f\n\x0bAFI_UNK\
    NOWN\x10\0\x12\n\n\x06AFI_IP\x10\x01\x12\x0b\n\x07AFI_IP6\x10\x02\x12\r\
    \n\tAFI_L2VPN\x10\x19\x12\x0c\n\x06AFI_LS\x10\x84\x80\x01\x12\x10\n\nAFI\
    _OPAQUE\x10\x8d\x80\x01\"\xb7\x02\n\x04Safi\x12\x10\n\x0cSAFI_UNKNOWN\
    \x10\0\x12\x10\n\x0cSAFI_UNICAST\x10\x01\x12\x12\n\x0eSAFI_MULTICAST\x10\
    \x02\x12\x13\n\x0fSAFI_MPLS_LABEL\x10\x04\x12\x16\n\x12SAFI_ENCAPSULATIO\
    N\x10\x07\x12\r\n\tSAFI_VPLS\x10A\x12\r\n\tSAFI_EVPN\x10F\x12\x0b\n\x07S\
    AFI_LS\x10G\x12\x12\n\rSAFI_MPLS_VPN\x10\x80\x01\x12\x1c\n\x17SAFI_MPLS_\
    VPN_MULTICAST\x10\x81\x01\x12\"\n\x1dSAFI_ROUTE_TARGET_CONSTRAINTS\x10\
    \x84\x01\x12\x1b\n\x16SAFI_FLOW_SPEC_UNICAST\x10\x85\x01\x12\x17\n\x12SA\
    FI_FLOW_SPEC_VPN\x10\x86\x01\x12\x13\n\x0eSAFI_KEY_VALUE\x10\xf1\x01\"\
    \x97\x03\n\nValidation\x120\n\x05state\x18\x01\x20\x01(\x0e2\x1a.gobgpap\
    i.Validation.StateR\x05state\x123\n\x06reason\x18\x02\x20\x01(\x0e2\x1b.\
    gobgpapi.Validation.ReasonR\x06reason\x12'\n\x07matched\x18\x03\x20\x03(\
    \x0b2\r.gobgpapi.RoaR\x07matched\x120\n\x0cunmatched_as\x18\x04\x20\x03(\
    \x0b2\r.gobgpapi.RoaR\x0bunmatchedAs\x128\n\x10unmatched_length\x18\x05\
    \x20\x03(\x0b2\r.gobgpapi.RoaR\x0funmatchedLength\"P\n\x05State\x12\x0e\
    \n\nSTATE_NONE\x10\0\x12\x13\n\x0fSTATE_NOT_FOUND\x10\x01\x12\x0f\n\x0bS\
    TATE_VALID\x10\x02\x12\x11\n\rSTATE_INVALID\x10\x03\";\n\x06Reason\x12\
    \x0f\n\x0bREASOT_NONE\x10\0\x12\r\n\tREASON_AS\x10\x01\x12\x11\n\rREASON\
    _LENGTH\x10\x02\"\xdf\x05\n\x04Path\x12(\n\x04nlri\x18\x01\x20\x01(\x0b2\
    \x14.google.protobuf.AnyR\x04nlri\x12,\n\x06pattrs\x18\x02\x20\x03(\x0b2\
    \x14.google.protobuf.AnyR\x06pattrs\x12,\n\x03age\x18\x03\x20\x01(\x0b2\
    \x1a.google.protobuf.TimestampR\x03age\x12\x12\n\x04best\x18\x04\x20\x01\
    (\x08R\x04best\x12\x1f\n\x0bis_withdraw\x18\x05\x20\x01(\x08R\nisWithdra\
    w\x124\n\nvalidation\x18\x07\x20\x01(\x0b2\x14.gobgpapi.ValidationR\nval\
    idation\x120\n\x14no_implicit_withdraw\x18\x08\x20\x01(\x08R\x12noImplic\
    itWithdraw\x12(\n\x06family\x18\t\x20\x01(\x0b2\x10.gobgpapi.FamilyR\x06\
    family\x12\x1d\n\nsource_asn\x18\n\x20\x01(\rR\tsourceAsn\x12\x1b\n\tsou\
    rce_id\x18\x0b\x20\x01(\tR\x08sourceId\x12\x1a\n\x08filtered\x18\x0c\x20\
    \x01(\x08R\x08filtered\x12\x14\n\x05stale\x18\r\x20\x01(\x08R\x05stale\
    \x12(\n\x10is_from_external\x18\x0e\x20\x01(\x08R\x0eisFromExternal\x12\
    \x1f\n\x0bneighbor_ip\x18\x0f\x20\x01(\tR\nneighborIp\x12\x12\n\x04uuid\
    \x18\x10\x20\x01(\x0cR\x04uuid\x12,\n\x12is_nexthop_invalid\x18\x11\x20\
    \x01(\x08R\x10isNexthopInvalid\x12\x1e\n\nidentifier\x18\x12\x20\x01(\rR\
    \nidentifier\x12)\n\x10local_identifier\x18\x13\x20\x01(\rR\x0flocalIden\
    tifier\x12\x1f\n\x0bnlri_binary\x18\x14\x20\x01(\x0cR\nnlriBinary\x12#\n\
    \rpattrs_binary\x18\x15\x20\x03(\x0cR\x0cpattrsBinary\"K\n\x0bDestinatio\
    n\x12\x16\n\x06prefix\x18\x01\x20\x01(\tR\x06prefix\x12$\n\x05paths\x18\
    \x02\x20\x03(\x0b2\x0e.gobgpapi.PathR\x05paths\"m\n\x11TableLookupPrefix\
    \x12\x16\n\x06prefix\x18\x01\x20\x01(\tR\x06prefix\x12@\n\rlookup_option\
    \x18\x02\x20\x01(\x0e2\x1b.gobgpapi.TableLookupOptionR\x0clookupOption\"\
    \xa0\x04\n\x04Peer\x128\n\x0capply_policy\x18\x01\x20\x01(\x0b2\x15.gobg\
    papi.ApplyPolicyR\x0bapplyPolicy\x12&\n\x04conf\x18\x02\x20\x01(\x0b2\
    \x12.gobgpapi.PeerConfR\x04conf\x12;\n\rebgp_multihop\x18\x03\x20\x01(\
    \x0b2\x16.gobgpapi.EbgpMultihopR\x0cebgpMultihop\x12A\n\x0froute_reflect\
    or\x18\x04\x20\x01(\x0b2\x18.gobgpapi.RouteReflectorR\x0erouteReflector\
    \x12)\n\x05state\x18\x05\x20\x01(\x0b2\x13.gobgpapi.PeerStateR\x05state\
    \x12(\n\x06timers\x18\x06\x20\x01(\x0b2\x10.gobgpapi.TimersR\x06timers\
    \x121\n\ttransport\x18\x07\x20\x01(\x0b2\x13.gobgpapi.TransportR\ttransp\
    ort\x128\n\x0croute_server\x18\x08\x20\x01(\x0b2\x15.gobgpapi.RouteServe\
    rR\x0brouteServer\x12D\n\x10graceful_restart\x18\t\x20\x01(\x0b2\x19.gob\
    gpapi.GracefulRestartR\x0fgracefulRestart\x12.\n\tafi_safis\x18\n\x20\
    \x03(\x0b2\x11.gobgpapi.AfiSafiR\x08afiSafis\"\xad\x04\n\tPeerGroup\x128\
    \n\x0capply_policy\x18\x01\x20\x01(\x0b2\x15.gobgpapi.ApplyPolicyR\x0bap\
    plyPolicy\x12+\n\x04conf\x18\x02\x20\x01(\x0b2\x17.gobgpapi.PeerGroupCon\
    fR\x04conf\x12;\n\rebgp_multihop\x18\x03\x20\x01(\x0b2\x16.gobgpapi.Ebgp\
    MultihopR\x0cebgpMultihop\x12A\n\x0froute_reflector\x18\x04\x20\x01(\x0b\
    2\x18.gobgpapi.RouteReflectorR\x0erouteReflector\x12,\n\x04info\x18\x05\
    \x20\x01(\x0b2\x18.gobgpapi.PeerGroupStateR\x04info\x12(\n\x06timers\x18\
    \x06\x20\x01(\x0b2\x10.gobgpapi.TimersR\x06timers\x121\n\ttransport\x18\
    \x07\x20\x01(\x0b2\x13.gobgpapi.TransportR\ttransport\x128\n\x0croute_se\
    rver\x18\x08\x20\x01(\x0b2\x15.gobgpapi.RouteServerR\x0brouteServer\x12D\
    \n\x10graceful_restart\x18\t\x20\x01(\x0b2\x19.gobgpapi.GracefulRestartR\
    \x0fgracefulRestart\x12.\n\tafi_safis\x18\n\x20\x03(\x0b2\x11.gobgpapi.A\
    fiSafiR\x08afiSafis\"H\n\x0fDynamicNeighbor\x12\x16\n\x06prefix\x18\x01\
    \x20\x01(\tR\x06prefix\x12\x1d\n\npeer_group\x18\x02\x20\x01(\tR\tpeerGr\
    oup\"\xc8\x01\n\x0bApplyPolicy\x127\n\tin_policy\x18\x01\x20\x01(\x0b2\
    \x1a.gobgpapi.PolicyAssignmentR\x08inPolicy\x12?\n\rexport_policy\x18\
    \x02\x20\x01(\x0b2\x1a.gobgpapi.PolicyAssignmentR\x0cexportPolicy\x12?\n\
    \rimport_policy\x18\x03\x20\x01(\x0b2\x1a.gobgpapi.PolicyAssignmentR\x0c\
    importPolicy\"\x90\x01\n\x0bPrefixLimit\x12(\n\x06family\x18\x01\x20\x01\
    (\x0b2\x10.gobgpapi.FamilyR\x06family\x12!\n\x0cmax_prefixes\x18\x02\x20\
    \x01(\rR\x0bmaxPrefixes\x124\n\x16shutdown_threshold_pct\x18\x03\x20\x01\
    (\rR\x14shutdownThresholdPct\"\xee\x04\n\x08PeerConf\x12#\n\rauth_passwo\
    rd\x18\x01\x20\x01(\tR\x0cauthPassword\x12\x20\n\x0bdescription\x18\x02\
    \x20\x01(\tR\x0bdescription\x12\x19\n\x08local_as\x18\x03\x20\x01(\rR\
    \x07localAs\x12)\n\x10neighbor_address\x18\x04\x20\x01(\tR\x0fneighborAd\
    dress\x12\x17\n\x07peer_as\x18\x05\x20\x01(\rR\x06peerAs\x12\x1d\n\npeer\
    _group\x18\x06\x20\x01(\tR\tpeerGroup\x12\x1b\n\tpeer_type\x18\x07\x20\
    \x01(\rR\x08peerType\x12N\n\x11remove_private_as\x18\x08\x20\x01(\x0e2\"\
    .gobgpapi.PeerConf.RemovePrivateAsR\x0fremovePrivateAs\x12,\n\x12route_f\
    lap_damping\x18\t\x20\x01(\x08R\x10routeFlapDamping\x12%\n\x0esend_commu\
    nity\x18\n\x20\x01(\rR\rsendCommunity\x12-\n\x12neighbor_interface\x18\
    \x0b\x20\x01(\tR\x11neighborInterface\x12\x10\n\x03vrf\x18\x0c\x20\x01(\
    \tR\x03vrf\x12\x20\n\x0callow_own_as\x18\r\x20\x01(\rR\nallowOwnAs\x12&\
    \n\x0freplace_peer_as\x18\x0e\x20\x01(\x08R\rreplacePeerAs\x12\x1d\n\nad\
    min_down\x18\x0f\x20\x01(\x08R\tadminDown\"1\n\x0fRemovePrivateAs\x12\
    \x08\n\x04NONE\x10\0\x12\x07\n\x03ALL\x10\x01\x12\x0b\n\x07REPLACE\x10\
    \x02\"\xac\x03\n\rPeerGroupConf\x12#\n\rauth_password\x18\x01\x20\x01(\t\
    R\x0cauthPassword\x12\x20\n\x0bdescription\x18\x02\x20\x01(\tR\x0bdescri\
    ption\x12\x19\n\x08local_as\x18\x03\x20\x01(\rR\x07localAs\x12\x17\n\x07\
    peer_as\x18\x04\x20\x01(\rR\x06peerAs\x12&\n\x0fpeer_group_name\x18\x05\
    \x20\x01(\tR\rpeerGroupName\x12\x1b\n\tpeer_type\x18\x06\x20\x01(\rR\x08\
    peerType\x12S\n\x11remove_private_as\x18\x07\x20\x01(\x0e2'.gobgpapi.Pee\
    rGroupConf.RemovePrivateAsR\x0fremovePrivateAs\x12,\n\x12route_flap_damp\
    ing\x18\x08\x20\x01(\x08R\x10routeFlapDamping\x12%\n\x0esend_community\
    \x18\t\x20\x01(\rR\rsendCommunity\"1\n\x0fRemovePrivateAs\x12\x08\n\x04N\
    ONE\x10\0\x12\x07\n\x03ALL\x10\x01\x12\x0b\n\x07REPLACE\x10\x02\"\xf6\
    \x03\n\x0ePeerGroupState\x12#\n\rauth_password\x18\x01\x20\x01(\tR\x0cau\
    thPassword\x12\x20\n\x0bdescription\x18\x02\x20\x01(\tR\x0bdescription\
    \x12\x19\n\x08local_as\x18\x03\x20\x01(\rR\x07localAs\x12\x17\n\x07peer_\
    as\x18\x04\x20\x01(\rR\x06peerAs\x12&\n\x0fpeer_group_name\x18\x05\x20\
    \x01(\tR\rpeerGroupName\x12\x1b\n\tpeer_type\x18\x06\x20\x01(\rR\x08peer\
    Type\x12T\n\x11remove_private_as\x18\x07\x20\x01(\x0e2(.gobgpapi.PeerGro\
    upState.RemovePrivateAsR\x0fremovePrivateAs\x12,\n\x12route_flap_damping\
    \x18\x08\x20\x01(\x08R\x10routeFlapDamping\x12%\n\x0esend_community\x18\
    \t\x20\x01(\rR\rsendCommunity\x12\x1f\n\x0btotal_paths\x18\n\x20\x01(\rR\
    \ntotalPaths\x12%\n\x0etotal_prefixes\x18\x0b\x20\x01(\rR\rtotalPrefixes\
    \"1\n\x0fRemovePrivateAs\x12\x08\n\x04NONE\x10\0\x12\x07\n\x03ALL\x10\
    \x01\x12\x0b\n\x07REPLACE\x10\x02\"K\n\x0cEbgpMultihop\x12\x18\n\x07enab\
    led\x18\x01\x20\x01(\x08R\x07enabled\x12!\n\x0cmultihop_ttl\x18\x02\x20\
    \x01(\rR\x0bmultihopTtl\"\x83\x01\n\x0eRouteReflector\x124\n\x16route_re\
    flector_client\x18\x01\x20\x01(\x08R\x14routeReflectorClient\x12;\n\x1ar\
    oute_reflector_cluster_id\x18\x02\x20\x01(\tR\x17routeReflectorClusterId\
    \"\x9c\x07\n\tPeerState\x12#\n\rauth_password\x18\x01\x20\x01(\tR\x0caut\
    hPassword\x12\x20\n\x0bdescription\x18\x02\x20\x01(\tR\x0bdescription\
    \x12\x19\n\x08local_as\x18\x03\x20\x01(\rR\x07localAs\x12.\n\x08messages\
    \x18\x04\x20\x01(\x0b2\x12.gobgpapi.MessagesR\x08messages\x12)\n\x10neig\
    hbor_address\x18\x05\x20\x01(\tR\x0fneighborAddress\x12\x17\n\x07peer_as\
    \x18\x06\x20\x01(\rR\x06peerAs\x12\x1d\n\npeer_group\x18\x07\x20\x01(\tR\
    \tpeerGroup\x12\x1b\n\tpeer_type\x18\x08\x20\x01(\rR\x08peerType\x12(\n\
    \x06queues\x18\t\x20\x01(\x0b2\x10.gobgpapi.QueuesR\x06queues\x12*\n\x11\
    remove_private_as\x18\n\x20\x01(\rR\x0fremovePrivateAs\x12,\n\x12route_f\
    lap_damping\x18\x0b\x20\x01(\x08R\x10routeFlapDamping\x12%\n\x0esend_com\
    munity\x18\x0c\x20\x01(\rR\rsendCommunity\x12E\n\rsession_state\x18\r\
    \x20\x01(\x0e2\x20.gobgpapi.PeerState.SessionStateR\x0csessionState\x12?\
    \n\x0badmin_state\x18\x0f\x20\x01(\x0e2\x1e.gobgpapi.PeerState.AdminStat\
    eR\nadminState\x12\x13\n\x05out_q\x18\x10\x20\x01(\rR\x04outQ\x12\x14\n\
    \x05flops\x18\x11\x20\x01(\rR\x05flops\x123\n\nremote_cap\x18\x12\x20\
    \x03(\x0b2\x14.google.protobuf.AnyR\tremoteCap\x121\n\tlocal_cap\x18\x13\
    \x20\x03(\x0b2\x14.google.protobuf.AnyR\x08localCap\x12\x1b\n\trouter_id\
    \x18\x14\x20\x01(\tR\x08routerId\"n\n\x0cSessionState\x12\x0b\n\x07UNKNO\
    WN\x10\0\x12\x08\n\x04IDLE\x10\x01\x12\x0b\n\x07CONNECT\x10\x02\x12\n\n\
    \x06ACTIVE\x10\x03\x12\x0c\n\x08OPENSENT\x10\x04\x12\x0f\n\x0bOPENCONFIR\
    M\x10\x05\x12\x0f\n\x0bESTABLISHED\x10\x06\"*\n\nAdminState\x12\x06\n\
    \x02UP\x10\0\x12\x08\n\x04DOWN\x10\x01\x12\n\n\x06PFX_CT\x10\x02\"`\n\
    \x08Messages\x12-\n\x08received\x18\x01\x20\x01(\x0b2\x11.gobgpapi.Messa\
    geR\x08received\x12%\n\x04sent\x18\x02\x20\x01(\x0b2\x11.gobgpapi.Messag\
    eR\x04sent\"\x97\x02\n\x07Message\x12\"\n\x0cnotification\x18\x01\x20\
    \x01(\x04R\x0cnotification\x12\x16\n\x06update\x18\x02\x20\x01(\x04R\x06\
    update\x12\x12\n\x04open\x18\x03\x20\x01(\x04R\x04open\x12\x1c\n\tkeepal\
    ive\x18\x04\x20\x01(\x04R\tkeepalive\x12\x18\n\x07refresh\x18\x05\x20\
    \x01(\x04R\x07refresh\x12\x1c\n\tdiscarded\x18\x06\x20\x01(\x04R\tdiscar\
    ded\x12\x14\n\x05total\x18\x07\x20\x01(\x04R\x05total\x12'\n\x0fwithdraw\
    _update\x18\x08\x20\x01(\x04R\x0ewithdrawUpdate\x12'\n\x0fwithdraw_prefi\
    x\x18\t\x20\x01(\x04R\x0ewithdrawPrefix\"6\n\x06Queues\x12\x14\n\x05inpu\
    t\x18\x01\x20\x01(\rR\x05input\x12\x16\n\x06output\x18\x02\x20\x01(\rR\
    \x06output\"e\n\x06Timers\x12.\n\x06config\x18\x01\x20\x01(\x0b2\x16.gob\
    gpapi.TimersConfigR\x06config\x12+\n\x05state\x18\x02\x20\x01(\x0b2\x15.\
    gobgpapi.TimersStateR\x05state\"\x81\x02\n\x0cTimersConfig\x12#\n\rconne\
    ct_retry\x18\x01\x20\x01(\x04R\x0cconnectRetry\x12\x1b\n\thold_time\x18\
    \x02\x20\x01(\x04R\x08holdTime\x12-\n\x12keepalive_interval\x18\x03\x20\
    \x01(\x04R\x11keepaliveInterval\x12D\n\x1eminimum_advertisement_interval\
    \x18\x04\x20\x01(\x04R\x1cminimumAdvertisementInterval\x12:\n\x1aidle_ho\
    ld_time_after_reset\x18\x05\x20\x01(\x04R\x16idleHoldTimeAfterReset\"\
    \xe2\x02\n\x0bTimersState\x12#\n\rconnect_retry\x18\x01\x20\x01(\x04R\
    \x0cconnectRetry\x12\x1b\n\thold_time\x18\x02\x20\x01(\x04R\x08holdTime\
    \x12-\n\x12keepalive_interval\x18\x03\x20\x01(\x04R\x11keepaliveInterval\
    \x12D\n\x1eminimum_advertisement_interval\x18\x04\x20\x01(\x04R\x1cminim\
    umAdvertisementInterval\x120\n\x14negotiated_hold_time\x18\x05\x20\x01(\
    \x04R\x12negotiatedHoldTime\x122\n\x06uptime\x18\x06\x20\x01(\x0b2\x1a.g\
    oogle.protobuf.TimestampR\x06uptime\x126\n\x08downtime\x18\x07\x20\x01(\
    \x0b2\x1a.google.protobuf.TimestampR\x08downtime\"\x9f\x02\n\tTransport\
    \x12#\n\rlocal_address\x18\x01\x20\x01(\tR\x0clocalAddress\x12\x1d\n\nlo\
    cal_port\x18\x02\x20\x01(\rR\tlocalPort\x12#\n\rmtu_discovery\x18\x03\
    \x20\x01(\x08R\x0cmtuDiscovery\x12!\n\x0cpassive_mode\x18\x04\x20\x01(\
    \x08R\x0bpassiveMode\x12%\n\x0eremote_address\x18\x05\x20\x01(\tR\rremot\
    eAddress\x12\x1f\n\x0bremote_port\x18\x06\x20\x01(\rR\nremotePort\x12\
    \x17\n\x07tcp_mss\x18\x07\x20\x01(\rR\x06tcpMss\x12%\n\x0ebind_interface\
    \x18\x08\x20\x01(\tR\rbindInterface\"f\n\x0bRouteServer\x12.\n\x13route_\
    server_client\x18\x01\x20\x01(\x08R\x11routeServerClient\x12'\n\x0fsecon\
    dary_route\x18\x02\x20\x01(\x08R\x0esecondaryRoute\"\xb4\x03\n\x0fGracef\
    ulRestart\x12\x18\n\x07enabled\x18\x01\x20\x01(\x08R\x07enabled\x12!\n\
    \x0crestart_time\x18\x02\x20\x01(\rR\x0brestartTime\x12\x1f\n\x0bhelper_\
    only\x18\x03\x20\x01(\x08R\nhelperOnly\x12#\n\rdeferral_time\x18\x04\x20\
    \x01(\rR\x0cdeferralTime\x121\n\x14notification_enabled\x18\x05\x20\x01(\
    \x08R\x13notificationEnabled\x12+\n\x11longlived_enabled\x18\x06\x20\x01\
    (\x08R\x10longlivedEnabled\x12*\n\x11stale_routes_time\x18\x07\x20\x01(\
    \rR\x0fstaleRoutesTime\x12*\n\x11peer_restart_time\x18\x08\x20\x01(\rR\
    \x0fpeerRestartTime\x12'\n\x0fpeer_restarting\x18\t\x20\x01(\x08R\x0epee\
    rRestarting\x12)\n\x10local_restarting\x18\n\x20\x01(\x08R\x0flocalResta\
    rting\x12\x12\n\x04mode\x18\x0b\x20\x01(\tR\x04mode\"3\n\x17MpGracefulRe\
    startConfig\x12\x18\n\x07enabled\x18\x01\x20\x01(\x08R\x07enabled\"\xc4\
    \x01\n\x16MpGracefulRestartState\x12\x18\n\x07enabled\x18\x01\x20\x01(\
    \x08R\x07enabled\x12\x1a\n\x08received\x18\x02\x20\x01(\x08R\x08received\
    \x12\x1e\n\nadvertised\x18\x03\x20\x01(\x08R\nadvertised\x12-\n\x13end_o\
    f_rib_received\x18\x04\x20\x01(\x08R\x10endOfRibReceived\x12%\n\x0fend_o\
    f_rib_sent\x18\x05\x20\x01(\x08R\x0cendOfRibSent\"\x86\x01\n\x11MpGracef\
    ulRestart\x129\n\x06config\x18\x01\x20\x01(\x0b2!.gobgpapi.MpGracefulRes\
    tartConfigR\x06config\x126\n\x05state\x18\x02\x20\x01(\x0b2\x20.gobgpapi\
    .MpGracefulRestartStateR\x05state\"S\n\rAfiSafiConfig\x12(\n\x06family\
    \x18\x01\x20\x01(\x0b2\x10.gobgpapi.FamilyR\x06family\x12\x18\n\x07enabl\
    ed\x18\x02\x20\x01(\x08R\x07enabled\"\xaa\x01\n\x0cAfiSafiState\x12(\n\
    \x06family\x18\x01\x20\x01(\x0b2\x10.gobgpapi.FamilyR\x06family\x12\x18\
    \n\x07enabled\x18\x02\x20\x01(\x08R\x07enabled\x12\x1a\n\x08received\x18\
    \x03\x20\x01(\x04R\x08received\x12\x1a\n\x08accepted\x18\x04\x20\x01(\
    \x04R\x08accepted\x12\x1e\n\nadvertised\x18\x05\x20\x01(\x04R\nadvertise\
    d\"\x93\x03\n\x1bRouteSelectionOptionsConfig\x12,\n\x12always_compare_me\
    d\x18\x01\x20\x01(\x08R\x10alwaysCompareMed\x121\n\x15ignore_as_path_len\
    gth\x18\x02\x20\x01(\x08R\x12ignoreAsPathLength\x12;\n\x1aexternal_compa\
    re_router_id\x18\x03\x20\x01(\x08R\x17externalCompareRouterId\x12:\n\x19\
    advertise_inactive_routes\x18\x04\x20\x01(\x08R\x17advertiseInactiveRout\
    es\x12\x1f\n\x0benable_aigp\x18\x05\x20\x01(\x08R\nenableAigp\x12:\n\x1a\
    ignore_next_hop_igp_metric\x18\x06\x20\x01(\x08R\x16ignoreNextHopIgpMetr\
    ic\x12=\n\x1bdisable_best_path_selection\x18\x07\x20\x01(\x08R\x18disabl\
    eBestPathSelection\"\x92\x03\n\x1aRouteSelectionOptionsState\x12,\n\x12a\
    lways_compare_med\x18\x01\x20\x01(\x08R\x10alwaysCompareMed\x121\n\x15ig\
    nore_as_path_length\x18\x02\x20\x01(\x08R\x12ignoreAsPathLength\x12;\n\
    \x1aexternal_compare_router_id\x18\x03\x20\x01(\x08R\x17externalCompareR\
    outerId\x12:\n\x19advertise_inactive_routes\x18\x04\x20\x01(\x08R\x17adv\
    ertiseInactiveRoutes\x12\x1f\n\x0benable_aigp\x18\x05\x20\x01(\x08R\nena\
    bleAigp\x12:\n\x1aignore_next_hop_igp_metric\x18\x06\x20\x01(\x08R\x16ig\
    noreNextHopIgpMetric\x12=\n\x1bdisable_best_path_selection\x18\x07\x20\
    \x01(\x08R\x18disableBestPathSelection\"\x92\x01\n\x15RouteSelectionOpti\
    ons\x12=\n\x06config\x18\x01\x20\x01(\x0b2%.gobgpapi.RouteSelectionOptio\
    nsConfigR\x06config\x12:\n\x05state\x18\x02\x20\x01(\x0b2$.gobgpapi.Rout\
    eSelectionOptionsStateR\x05state\"2\n\x16UseMultiplePathsConfig\x12\x18\
    \n\x07enabled\x18\x01\x20\x01(\x08R\x07enabled\"1\n\x15UseMultiplePathsS\
    tate\x12\x18\n\x07enabled\x18\x01\x20\x01(\x08R\x07enabled\"]\n\nEbgpCon\
    fig\x12*\n\x11allow_multiple_as\x18\x01\x20\x01(\x08R\x0fallowMultipleAs\
    \x12#\n\rmaximum_paths\x18\x02\x20\x01(\rR\x0cmaximumPaths\"\\\n\tEbgpSt\
    ate\x12*\n\x11allow_multiple_as\x18\x01\x20\x01(\x08R\x0fallowMultipleAs\
    \x12#\n\rmaximum_paths\x18\x02\x20\x01(\rR\x0cmaximumPaths\"_\n\x04Ebgp\
    \x12,\n\x06config\x18\x01\x20\x01(\x0b2\x14.gobgpapi.EbgpConfigR\x06conf\
    ig\x12)\n\x05state\x18\x02\x20\x01(\x0b2\x13.gobgpapi.EbgpStateR\x05stat\
    e\"1\n\nIbgpConfig\x12#\n\rmaximum_paths\x18\x01\x20\x01(\rR\x0cmaximumP\
    aths\"0\n\tIbgpState\x12#\n\rmaximum_paths\x18\x01\x20\x01(\rR\x0cmaximu\
    mPaths\"_\n\x04Ibgp\x12,\n\x06config\x18\x01\x20\x01(\x0b2\x14.gobgpapi.\
    IbgpConfigR\x06config\x12)\n\x05state\x18\x02\x20\x01(\x0b2\x13.gobgpapi\
    .IbgpStateR\x05state\"\xcb\x01\n\x10UseMultiplePaths\x128\n\x06config\
    \x18\x01\x20\x01(\x0b2\x20.gobgpapi.UseMultiplePathsConfigR\x06config\
    \x125\n\x05state\x18\x02\x20\x01(\x0b2\x1f.gobgpapi.UseMultiplePathsStat\
    eR\x05state\x12\"\n\x04ebgp\x18\x03\x20\x01(\x0b2\x0e.gobgpapi.EbgpR\x04\
    ebgp\x12\"\n\x04ibgp\x18\x04\x20\x01(\x0b2\x0e.gobgpapi.IbgpR\x04ibgp\"B\
    \n\x1bRouteTargetMembershipConfig\x12#\n\rdeferral_time\x18\x01\x20\x01(\
    \rR\x0cdeferralTime\"A\n\x1aRouteTargetMembershipState\x12#\n\rdeferral_\
    time\x18\x01\x20\x01(\rR\x0cdeferralTime\"\x92\x01\n\x15RouteTargetMembe\
    rship\x12=\n\x06config\x18\x01\x20\x01(\x0b2%.gobgpapi.RouteTargetMember\
    shipConfigR\x06config\x12:\n\x05state\x18\x02\x20\x01(\x0b2$.gobgpapi.Ro\
    uteTargetMembershipStateR\x05state\"]\n\x1eLongLivedGracefulRestartConfi\
    g\x12\x18\n\x07enabled\x18\x01\x20\x01(\x08R\x07enabled\x12!\n\x0crestar\
    t_time\x18\x02\x20\x01(\rR\x0brestartTime\"\xde\x01\n\x1dLongLivedGracef\
    ulRestartState\x12\x18\n\x07enabled\x18\x01\x20\x01(\x08R\x07enabled\x12\
    \x1a\n\x08received\x18\x02\x20\x01(\x08R\x08received\x12\x1e\n\nadvertis\
    ed\x18\x03\x20\x01(\x08R\nadvertised\x12*\n\x11peer_restart_time\x18\x04\
    \x20\x01(\rR\x0fpeerRestartTime\x12;\n\x1apeer_restart_timer_expired\x18\
    \x05\x20\x01(\x08R\x17peerRestartTimerExpired\"\x9b\x01\n\x18LongLivedGr\
    acefulRestart\x12@\n\x06config\x18\x01\x20\x01(\x0b2(.gobgpapi.LongLived\
    GracefulRestartConfigR\x06config\x12=\n\x05state\x18\x02\x20\x01(\x0b2'.\
    gobgpapi.LongLivedGracefulRestartStateR\x05state\"\xbb\x05\n\x07AfiSafi\
    \x12K\n\x13mp_graceful_restart\x18\x01\x20\x01(\x0b2\x1b.gobgpapi.MpGrac\
    efulRestartR\x11mpGracefulRestart\x12/\n\x06config\x18\x02\x20\x01(\x0b2\
    \x17.gobgpapi.AfiSafiConfigR\x06config\x12,\n\x05state\x18\x03\x20\x01(\
    \x0b2\x16.gobgpapi.AfiSafiStateR\x05state\x128\n\x0capply_policy\x18\x04\
    \x20\x01(\x0b2\x15.gobgpapi.ApplyPolicyR\x0bapplyPolicy\x12W\n\x17route_\
    selection_options\x18\x05\x20\x01(\x0b2\x1f.gobgpapi.RouteSelectionOptio\
    nsR\x15routeSelectionOptions\x12H\n\x12use_multiple_paths\x18\x06\x20\
    \x01(\x0b2\x1a.gobgpapi.UseMultiplePathsR\x10useMultiplePaths\x12:\n\rpr\
    efix_limits\x18\x07\x20\x01(\x0b2\x15.gobgpapi.PrefixLimitR\x0cprefixLim\
    its\x12W\n\x17route_target_membership\x18\x08\x20\x01(\x0b2\x1f.gobgpapi\
    .RouteTargetMembershipR\x15routeTargetMembership\x12a\n\x1blong_lived_gr\
    aceful_restart\x18\t\x20\x01(\x0b2\".gobgpapi.LongLivedGracefulRestartR\
    \x18longLivedGracefulRestart\x12/\n\tadd_paths\x18\n\x20\x01(\x0b2\x12.g\
    obgpapi.AddPathsR\x08addPaths\"E\n\x0eAddPathsConfig\x12\x18\n\x07receiv\
    e\x18\x01\x20\x01(\x08R\x07receive\x12\x19\n\x08send_max\x18\x02\x20\x01\
    (\rR\x07sendMax\"D\n\rAddPathsState\x12\x18\n\x07receive\x18\x01\x20\x01\
    (\x08R\x07receive\x12\x19\n\x08send_max\x18\x02\x20\x01(\rR\x07sendMax\"\
    k\n\x08AddPaths\x120\n\x06config\x18\x01\x20\x01(\x0b2\x18.gobgpapi.AddP\
    athsConfigR\x06config\x12-\n\x05state\x18\x02\x20\x01(\x0b2\x17.gobgpapi\
    .AddPathsStateR\x05state\"u\n\x06Prefix\x12\x1b\n\tip_prefix\x18\x01\x20\
    \x01(\tR\x08ipPrefix\x12&\n\x0fmask_length_min\x18\x02\x20\x01(\rR\rmask\
    LengthMin\x12&\n\x0fmask_length_max\x18\x03\x20\x01(\rR\rmaskLengthMax\"\
    \x9c\x01\n\nDefinedSet\x128\n\x0cdefined_type\x18\x01\x20\x01(\x0e2\x15.\
    gobgpapi.DefinedTypeR\x0bdefinedType\x12\x12\n\x04name\x18\x02\x20\x01(\
    \tR\x04name\x12\x12\n\x04list\x18\x03\x20\x03(\tR\x04list\x12,\n\x08pref\
    ixes\x18\x04\x20\x03(\x0b2\x10.gobgpapi.PrefixR\x08prefixes\"R\n\x08Matc\
    hSet\x122\n\nmatch_type\x18\x01\x20\x01(\x0e2\x13.gobgpapi.MatchTypeR\tm\
    atchType\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\"c\n\x0cAsPathLen\
    gth\x12;\n\x0blength_type\x18\x01\x20\x01(\x0e2\x1a.gobgpapi.AsPathLengt\
    hTypeR\nlengthType\x12\x16\n\x06length\x18\x02\x20\x01(\rR\x06length\"\
    \xca\x05\n\nConditions\x121\n\nprefix_set\x18\x01\x20\x01(\x0b2\x12.gobg\
    papi.MatchSetR\tprefixSet\x125\n\x0cneighbor_set\x18\x02\x20\x01(\x0b2\
    \x12.gobgpapi.MatchSetR\x0bneighborSet\x12<\n\x0eas_path_length\x18\x03\
    \x20\x01(\x0b2\x16.gobgpapi.AsPathLengthR\x0casPathLength\x122\n\x0bas_p\
    ath_set\x18\x04\x20\x01(\x0b2\x12.gobgpapi.MatchSetR\tasPathSet\x127\n\r\
    community_set\x18\x05\x20\x01(\x0b2\x12.gobgpapi.MatchSetR\x0ccommunityS\
    et\x12>\n\x11ext_community_set\x18\x06\x20\x01(\x0b2\x12.gobgpapi.MatchS\
    etR\x0fextCommunitySet\x12\x1f\n\x0brpki_result\x18\x07\x20\x01(\x05R\nr\
    pkiResult\x12=\n\nroute_type\x18\x08\x20\x01(\x0e2\x1e.gobgpapi.Conditio\
    ns.RouteTypeR\trouteType\x12B\n\x13large_community_set\x18\t\x20\x01(\
    \x0b2\x12.gobgpapi.MatchSetR\x11largeCommunitySet\x12'\n\x10next_hop_in_\
    list\x18\n\x20\x03(\tR\rnextHopInList\x120\n\x0bafi_safi_in\x18\x0b\x20\
    \x03(\x0b2\x10.gobgpapi.FamilyR\tafiSafiIn\"h\n\tRouteType\x12\x13\n\x0f\
    ROUTE_TYPE_NONE\x10\0\x12\x17\n\x13ROUTE_TYPE_INTERNAL\x10\x01\x12\x17\n\
    \x13ROUTE_TYPE_EXTERNAL\x10\x02\x12\x14\n\x10ROUTE_TYPE_LOCAL\x10\x03\"s\
    \n\x0fCommunityAction\x12>\n\x0baction_type\x18\x01\x20\x01(\x0e2\x1d.go\
    bgpapi.CommunityActionTypeR\nactionType\x12\x20\n\x0bcommunities\x18\x02\
    \x20\x03(\tR\x0bcommunities\"[\n\tMedAction\x128\n\x0baction_type\x18\
    \x01\x20\x01(\x0e2\x17.gobgpapi.MedActionTypeR\nactionType\x12\x14\n\x05\
    value\x18\x02\x20\x01(\x03R\x05value\"_\n\x0fAsPrependAction\x12\x10\n\
    \x03asn\x18\x01\x20\x01(\rR\x03asn\x12\x16\n\x06repeat\x18\x02\x20\x01(\
    \rR\x06repeat\x12\"\n\ruse_left_most\x18\x03\x20\x01(\x08R\x0buseLeftMos\
    t\"=\n\rNexthopAction\x12\x18\n\x07address\x18\x01\x20\x01(\tR\x07addres\
    s\x12\x12\n\x04self\x18\x02\x20\x01(\x08R\x04self\"'\n\x0fLocalPrefActio\
    n\x12\x14\n\x05value\x18\x01\x20\x01(\rR\x05value\"\xce\x03\n\x07Actions\
    \x128\n\x0croute_action\x18\x01\x20\x01(\x0e2\x15.gobgpapi.RouteActionR\
    \x0brouteAction\x127\n\tcommunity\x18\x02\x20\x01(\x0b2\x19.gobgpapi.Com\
    munityActionR\tcommunity\x12%\n\x03med\x18\x03\x20\x01(\x0b2\x13.gobgpap\
    i.MedActionR\x03med\x128\n\nas_prepend\x18\x04\x20\x01(\x0b2\x19.gobgpap\
    i.AsPrependActionR\tasPrepend\x12>\n\rext_community\x18\x05\x20\x01(\x0b\
    2\x19.gobgpapi.CommunityActionR\x0cextCommunity\x121\n\x07nexthop\x18\
    \x06\x20\x01(\x0b2\x17.gobgpapi.NexthopActionR\x07nexthop\x128\n\nlocal_\
    pref\x18\x07\x20\x01(\x0b2\x19.gobgpapi.LocalPrefActionR\tlocalPref\x12B\
    \n\x0flarge_community\x18\x08\x20\x01(\x0b2\x19.gobgpapi.CommunityAction\
    R\x0elargeCommunity\"\x82\x01\n\tStatement\x12\x12\n\x04name\x18\x01\x20\
    \x01(\tR\x04name\x124\n\nconditions\x18\x02\x20\x01(\x0b2\x14.gobgpapi.C\
    onditionsR\nconditions\x12+\n\x07actions\x18\x03\x20\x01(\x0b2\x11.gobgp\
    api.ActionsR\x07actions\"Q\n\x06Policy\x12\x12\n\x04name\x18\x01\x20\x01\
    (\tR\x04name\x123\n\nstatements\x18\x02\x20\x03(\x0b2\x13.gobgpapi.State\
    mentR\nstatements\"\xcb\x01\n\x10PolicyAssignment\x12\x12\n\x04name\x18\
    \x01\x20\x01(\tR\x04name\x127\n\tdirection\x18\x02\x20\x01(\x0e2\x19.gob\
    gpapi.PolicyDirectionR\tdirection\x12,\n\x08policies\x18\x04\x20\x03(\
    \x0b2\x10.gobgpapi.PolicyR\x08policies\x12<\n\x0edefault_action\x18\x05\
    \x20\x01(\x0e2\x15.gobgpapi.RouteActionR\rdefaultAction\"v\n\rRoutingPol\
    icy\x127\n\x0cdefined_sets\x18\x01\x20\x03(\x0b2\x14.gobgpapi.DefinedSet\
    R\x0bdefinedSets\x12,\n\x08policies\x18\x02\x20\x03(\x0b2\x10.gobgpapi.P\
    olicyR\x08policies\"\x8b\x01\n\x03Roa\x12\x0e\n\x02as\x18\x01\x20\x01(\r\
    R\x02as\x12\x1c\n\tprefixlen\x18\x02\x20\x01(\rR\tprefixlen\x12\x16\n\
    \x06maxlen\x18\x03\x20\x01(\rR\x06maxlen\x12\x16\n\x06prefix\x18\x04\x20\
    \x01(\tR\x06prefix\x12&\n\x04conf\x18\x05\x20\x01(\x0b2\x12.gobgpapi.RPK\
    IConfR\x04conf\"\xb5\x01\n\x03Vrf\x12\x12\n\x04name\x18\x01\x20\x01(\tR\
    \x04name\x12$\n\x02rd\x18\x02\x20\x01(\x0b2\x14.google.protobuf.AnyR\x02\
    rd\x121\n\timport_rt\x18\x03\x20\x03(\x0b2\x14.google.protobuf.AnyR\x08i\
    mportRt\x121\n\texport_rt\x18\x04\x20\x03(\x0b2\x14.google.protobuf.AnyR\
    \x08exportRt\x12\x0e\n\x02id\x18\x05\x20\x01(\rR\x02id\"\x86\x01\n\x14De\
    faultRouteDistance\x126\n\x17external_route_distance\x18\x01\x20\x01(\rR\
    \x15externalRouteDistance\x126\n\x17internal_route_distance\x18\x02\x20\
    \x01(\rR\x15internalRouteDistance\"\xbf\x04\n\x06Global\x12\x0e\n\x02as\
    \x18\x01\x20\x01(\rR\x02as\x12\x1b\n\trouter_id\x18\x02\x20\x01(\tR\x08r\
    outerId\x12\x1f\n\x0blisten_port\x18\x03\x20\x01(\x05R\nlistenPort\x12)\
    \n\x10listen_addresses\x18\x04\x20\x03(\tR\x0flistenAddresses\x12\x1a\n\
    \x08families\x18\x05\x20\x03(\rR\x08families\x12,\n\x12use_multiple_path\
    s\x18\x06\x20\x01(\x08R\x10useMultiplePaths\x12]\n\x17route_selection_op\
    tions\x18\x07\x20\x01(\x0b2%.gobgpapi.RouteSelectionOptionsConfigR\x15ro\
    uteSelectionOptions\x12T\n\x16default_route_distance\x18\x08\x20\x01(\
    \x0b2\x1e.gobgpapi.DefaultRouteDistanceR\x14defaultRouteDistance\x12=\n\
    \rconfederation\x18\t\x20\x01(\x0b2\x17.gobgpapi.ConfederationR\rconfede\
    ration\x12D\n\x10graceful_restart\x18\n\x20\x01(\x0b2\x19.gobgpapi.Grace\
    fulRestartR\x0fgracefulRestart\x128\n\x0capply_policy\x18\x0b\x20\x01(\
    \x0b2\x15.gobgpapi.ApplyPolicyR\x0bapplyPolicy\"o\n\rConfederation\x12\
    \x18\n\x07enabled\x18\x01\x20\x01(\x08R\x07enabled\x12\x1e\n\nidentifier\
    \x18\x02\x20\x01(\rR\nidentifier\x12$\n\x0emember_as_list\x18\x03\x20\
    \x03(\rR\x0cmemberAsList\"E\n\x08RPKIConf\x12\x18\n\x07address\x18\x01\
    \x20\x01(\tR\x07address\x12\x1f\n\x0bremote_port\x18\x02\x20\x01(\rR\nre\
    motePort\"\xd4\x04\n\tRPKIState\x122\n\x06uptime\x18\x01\x20\x01(\x0b2\
    \x1a.google.protobuf.TimestampR\x06uptime\x126\n\x08downtime\x18\x02\x20\
    \x01(\x0b2\x1a.google.protobuf.TimestampR\x08downtime\x12\x0e\n\x02up\
    \x18\x03\x20\x01(\x08R\x02up\x12\x1f\n\x0brecord_ipv4\x18\x04\x20\x01(\r\
    R\nrecordIpv4\x12\x1f\n\x0brecord_ipv6\x18\x05\x20\x01(\rR\nrecordIpv6\
    \x12\x1f\n\x0bprefix_ipv4\x18\x06\x20\x01(\rR\nprefixIpv4\x12\x1f\n\x0bp\
    refix_ipv6\x18\x07\x20\x01(\rR\nprefixIpv6\x12\x16\n\x06serial\x18\x08\
    \x20\x01(\rR\x06serial\x12#\n\rreceived_ipv4\x18\t\x20\x01(\x03R\x0crece\
    ivedIpv4\x12#\n\rreceived_ipv6\x18\n\x20\x01(\x03R\x0creceivedIpv6\x12#\
    \n\rserial_notify\x18\x0b\x20\x01(\x03R\x0cserialNotify\x12\x1f\n\x0bcac\
    he_reset\x18\x0c\x20\x01(\x03R\ncacheReset\x12%\n\x0ecache_response\x18\
    \r\x20\x01(\x03R\rcacheResponse\x12\x1e\n\x0bend_of_data\x18\x0e\x20\x01\
    (\x03R\tendOfData\x12\x14\n\x05error\x18\x0f\x20\x01(\x03R\x05error\x12!\
    \n\x0cserial_query\x18\x10\x20\x01(\x03R\x0bserialQuery\x12\x1f\n\x0bres\
    et_query\x18\x11\x20\x01(\x03R\nresetQuery\"Y\n\x04Rpki\x12&\n\x04conf\
    \x18\x01\x20\x01(\x0b2\x12.gobgpapi.RPKIConfR\x04conf\x12)\n\x05state\
    \x18\x02\x20\x01(\x0b2\x13.gobgpapi.RPKIStateR\x05state*D\n\tTableType\
    \x12\n\n\x06GLOBAL\x10\0\x12\t\n\x05LOCAL\x10\x01\x12\n\n\x06ADJ_IN\x10\
    \x02\x12\x0b\n\x07ADJ_OUT\x10\x03\x12\x07\n\x03VRF\x10\x04*L\n\x11TableL\
    ookupOption\x12\x10\n\x0cLOOKUP_EXACT\x10\0\x12\x11\n\rLOOKUP_LONGER\x10\
    \x01\x12\x12\n\x0eLOOKUP_SHORTER\x10\x02*\x82\x01\n\x0bDefinedType\x12\n\
    \n\x06PREFIX\x10\0\x12\x0c\n\x08NEIGHBOR\x10\x01\x12\x07\n\x03TAG\x10\
    \x02\x12\x0b\n\x07AS_PATH\x10\x03\x12\r\n\tCOMMUNITY\x10\x04\x12\x11\n\r\
    EXT_COMMUNITY\x10\x05\x12\x13\n\x0fLARGE_COMMUNITY\x10\x06\x12\x0c\n\x08\
    NEXT_HOP\x10\x07*)\n\tMatchType\x12\x07\n\x03ANY\x10\0\x12\x07\n\x03ALL\
    \x10\x01\x12\n\n\x06INVERT\x10\x02**\n\x10AsPathLengthType\x12\x06\n\x02\
    EQ\x10\0\x12\x06\n\x02GE\x10\x01\x12\x06\n\x02LE\x10\x02*/\n\x0bRouteAct\
    ion\x12\x08\n\x04NONE\x10\0\x12\n\n\x06ACCEPT\x10\x01\x12\n\n\x06REJECT\
    \x10\x02*U\n\x13CommunityActionType\x12\x11\n\rCOMMUNITY_ADD\x10\0\x12\
    \x14\n\x10COMMUNITY_REMOVE\x10\x01\x12\x15\n\x11COMMUNITY_REPLACE\x10\
    \x02*-\n\rMedActionType\x12\x0b\n\x07MED_MOD\x10\0\x12\x0f\n\x0bMED_REPL\
    ACE\x10\x01*6\n\x0fPolicyDirection\x12\x0b\n\x07UNKNOWN\x10\0\x12\n\n\
    \x06IMPORT\x10\x01\x12\n\n\x06EXPORT\x10\x022\xd7\x1c\n\x08GobgpApi\x12=\
    \n\x08StartBgp\x12\x19.gobgpapi.StartBgpRequest\x1a\x16.google.protobuf.\
    Empty\x12;\n\x07StopBgp\x12\x18.gobgpapi.StopBgpRequest\x1a\x16.google.p\
    rotobuf.Empty\x12;\n\x06GetBgp\x12\x17.gobgpapi.GetBgpRequest\x1a\x18.go\
    bgpapi.GetBgpResponse\x12;\n\x07AddPeer\x12\x18.gobgpapi.AddPeerRequest\
    \x1a\x16.google.protobuf.Empty\x12A\n\nDeletePeer\x12\x1b.gobgpapi.Delet\
    ePeerRequest\x1a\x16.google.protobuf.Empty\x12C\n\x08ListPeer\x12\x19.go\
    bgpapi.ListPeerRequest\x1a\x1a.gobgpapi.ListPeerResponse0\x01\x12G\n\nUp\
    datePeer\x12\x1b.gobgpapi.UpdatePeerRequest\x1a\x1c.gobgpapi.UpdatePeerR\
    esponse\x12?\n\tResetPeer\x12\x1a.gobgpapi.ResetPeerRequest\x1a\x16.goog\
    le.protobuf.Empty\x12E\n\x0cShutdownPeer\x12\x1d.gobgpapi.ShutdownPeerRe\
    quest\x1a\x16.google.protobuf.Empty\x12A\n\nEnablePeer\x12\x1b.gobgpapi.\
    EnablePeerRequest\x1a\x16.google.protobuf.Empty\x12C\n\x0bDisablePeer\
    \x12\x1c.gobgpapi.DisablePeerRequest\x1a\x16.google.protobuf.Empty\x12L\
    \n\x0bMonitorPeer\x12\x1c.gobgpapi.MonitorPeerRequest\x1a\x1d.gobgpapi.M\
    onitorPeerResponse0\x01\x12E\n\x0cAddPeerGroup\x12\x1d.gobgpapi.AddPeerG\
    roupRequest\x1a\x16.google.protobuf.Empty\x12K\n\x0fDeletePeerGroup\x12\
    \x20.gobgpapi.DeletePeerGroupRequest\x1a\x16.google.protobuf.Empty\x12V\
    \n\x0fUpdatePeerGroup\x12\x20.gobgpapi.UpdatePeerGroupRequest\x1a!.gobgp\
    api.UpdatePeerGroupResponse\x12Q\n\x12AddDynamicNeighbor\x12#.gobgpapi.A\
    ddDynamicNeighborRequest\x1a\x16.google.protobuf.Empty\x12>\n\x07AddPath\
    \x12\x18.gobgpapi.AddPathRequest\x1a\x19.gobgpapi.AddPathResponse\x12A\n\
    \nDeletePath\x12\x1b.gobgpapi.DeletePathRequest\x1a\x16.google.protobuf.\
    Empty\x12C\n\x08ListPath\x12\x19.gobgpapi.ListPathRequest\x1a\x1a.gobgpa\
    pi.ListPathResponse0\x01\x12I\n\rAddPathStream\x12\x1e.gobgpapi.AddPathS\
    treamRequest\x1a\x16.google.protobuf.Empty(\x01\x12A\n\x08GetTable\x12\
    \x19.gobgpapi.GetTableRequest\x1a\x1a.gobgpapi.GetTableResponse\x12O\n\
    \x0cMonitorTable\x12\x1d.gobgpapi.MonitorTableRequest\x1a\x1e.gobgpapi.M\
    onitorTableResponse0\x01\x129\n\x06AddVrf\x12\x17.gobgpapi.AddVrfRequest\
    \x1a\x16.google.protobuf.Empty\x12?\n\tDeleteVrf\x12\x1a.gobgpapi.Delete\
    VrfRequest\x1a\x16.google.protobuf.Empty\x12@\n\x07ListVrf\x12\x18.gobgp\
    api.ListVrfRequest\x1a\x19.gobgpapi.ListVrfResponse0\x01\x12?\n\tAddPoli\
    cy\x12\x1a.gobgpapi.AddPolicyRequest\x1a\x16.google.protobuf.Empty\x12E\
    \n\x0cDeletePolicy\x12\x1d.gobgpapi.DeletePolicyRequest\x1a\x16.google.p\
    rotobuf.Empty\x12I\n\nListPolicy\x12\x1b.gobgpapi.ListPolicyRequest\x1a\
    \x1c.gobgpapi.ListPolicyResponse0\x01\x12C\n\x0bSetPolicies\x12\x1c.gobg\
    papi.SetPoliciesRequest\x1a\x16.google.protobuf.Empty\x12G\n\rAddDefined\
    Set\x12\x1e.gobgpapi.AddDefinedSetRequest\x1a\x16.google.protobuf.Empty\
    \x12M\n\x10DeleteDefinedSet\x12!.gobgpapi.DeleteDefinedSetRequest\x1a\
    \x16.google.protobuf.Empty\x12U\n\x0eListDefinedSet\x12\x1f.gobgpapi.Lis\
    tDefinedSetRequest\x1a\x20.gobgpapi.ListDefinedSetResponse0\x01\x12E\n\
    \x0cAddStatement\x12\x1d.gobgpapi.AddStatementRequest\x1a\x16.google.pro\
    tobuf.Empty\x12K\n\x0fDeleteStatement\x12\x20.gobgpapi.DeleteStatementRe\
    quest\x1a\x16.google.protobuf.Empty\x12R\n\rListStatement\x12\x1e.gobgpa\
    pi.ListStatementRequest\x1a\x1f.gobgpapi.ListStatementResponse0\x01\x12S\
    \n\x13AddPolicyAssignment\x12$.gobgpapi.AddPolicyAssignmentRequest\x1a\
    \x16.google.protobuf.Empty\x12Y\n\x16DeletePolicyAssignment\x12'.gobgpap\
    i.DeletePolicyAssignmentRequest\x1a\x16.google.protobuf.Empty\x12g\n\x14\
    ListPolicyAssignment\x12%.gobgpapi.ListPolicyAssignmentRequest\x1a&.gobg\
    papi.ListPolicyAssignmentResponse0\x01\x12S\n\x13SetPolicyAssignment\x12\
    $.gobgpapi.SetPolicyAssignmentRequest\x1a\x16.google.protobuf.Empty\x12;\
    \n\x07AddRpki\x12\x18.gobgpapi.AddRpkiRequest\x1a\x16.google.protobuf.Em\
    pty\x12A\n\nDeleteRpki\x12\x1b.gobgpapi.DeleteRpkiRequest\x1a\x16.google\
    .protobuf.Empty\x12C\n\x08ListRpki\x12\x19.gobgpapi.ListRpkiRequest\x1a\
    \x1a.gobgpapi.ListRpkiResponse0\x01\x12A\n\nEnableRpki\x12\x1b.gobgpapi.\
    EnableRpkiRequest\x1a\x16.google.protobuf.Empty\x12C\n\x0bDisableRpki\
    \x12\x1c.gobgpapi.DisableRpkiRequest\x1a\x16.google.protobuf.Empty\x12?\
    \n\tResetRpki\x12\x1a.gobgpapi.ResetRpkiRequest\x1a\x16.google.protobuf.\
    Empty\x12R\n\rListRpkiTable\x12\x1e.gobgpapi.ListRpkiTableRequest\x1a\
    \x1f.gobgpapi.ListRpkiTableResponse0\x01\x12C\n\x0bEnableZebra\x12\x1c.g\
    obgpapi.EnableZebraRequest\x1a\x16.google.protobuf.Empty\x12?\n\tEnableM\
    rt\x12\x1a.gobgpapi.EnableMrtRequest\x1a\x16.google.protobuf.Empty\x12A\
    \n\nDisableMrt\x12\x1b.gobgpapi.DisableMrtRequest\x1a\x16.google.protobu\
    f.Empty\x129\n\x06AddBmp\x12\x17.gobgpapi.AddBmpRequest\x1a\x16.google.p\
    rotobuf.Empty\x12?\n\tDeleteBmp\x12\x1a.gobgpapi.DeleteBmpRequest\x1a\
    \x16.google.protobuf.Emptyb\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
